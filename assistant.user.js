// ==UserScript==
// @name Adguard Assistant Dev
// @name:ru Помощник Adguard Dev
// @name:uk Помічник Adguard Dev
// @name:pl Asystent Adguarda Dev
// @name:de Adguard-Assistent Dev
// @name:zh-cn 使用 Adguard 助手 Dev
// @name:he העוזר האישי של אדגארד Dev
// @name:it Assistente Adguard Dev
// @name:fa دستیار اَدگارد Dev
// @name:sr Koristi Adguard-ovog pomoćnika Dev
// @name:es Asistente de Adguard Dev
// @name:id Asisten Aguard Dev
// @namespace Adguard
// @description Provides easy and convenient way to manage filtering right from the browser
// @description:ru Позволяет легко и быстро управлять фильтрацией прямо из браузера
// @description:uk Забезпечує легкий і зручний спосіб керування фільтрацією прямо з веб-переглядача
// @description:pl Zapewnia łatwy i wygodny sposób na zarządzanie filtrowaniem bezpośrednio z przeglądarki
// @description:de Bietet einen einfachen und nützlichen Weg die Filterung direkt im Browser zu verwalten
// @description:zh-cn 提供简单方便的方法来管理浏览器筛选
// @description:he מספק דרך קלה ונוחה לנהל סינון תקין ישירות מהדפדפן
// @description:it Fornisce un modo facile e comodo per gestire il filtraggio direttamente dal browser
// @description:fa روش راحت و آسان برای مدیریت فیلترینگ مستیق از داخل مرورگر.
// @description:sr Pruža lak i zgodan način za upravljanje filtriranjem direktno iz pregledača.
// @description:es Permite fácilmente gestionar los filtros desde el navegador
// @description:id Menyediakan cara mudah dan nyaman untuk mengelola penyaringan langsung dari peramban
// @version 4.0.7
// @downloadURL https://AdguardTeam.github.io/AdguardAssistant/assistant.user.js
// @updateURL https://AdguardTeam.github.io/AdguardAssistant/assistant.meta.js
// @include *
// @exclude *://mil.ru/*
// @exclude *://feedly.com/*
// @exclude *wikipedia.org*
// @exclude *icloud.com*
// @exclude *hangouts.google.com*
// @exclude *www.facebook.com/plugins/сomments*
// @exclude *disqus.com/embed/comments*
// @exclude *vk.com/widget_comments*
// @exclude *www.youtube.com/embed/*
// @grant   GM_getValue
// @grant   GM_setValue
// @grant   GM_getResourceText
// @grant   GM_addStyle
// @grant   property:settings
// ==/UserScript==
(function() {
var Resources = function () {
var _resources = {
"button.css": "LmFkZ3VhcmQtYWxlcnQgewogICAgY3Vyc29yOiBwb2ludGVyOwogICAgbGVmdDogMDsKICAgIHRvcDogMDsKICAgIHBvc2l0aW9uOiBmaXhlZCAhaW1wb3J0YW50OwogICAgZm9udDogMTJweCBBcmlhbCwgc2Fucy1zZXJpZiAhaW1wb3J0YW50OwogICAgbGluZS1oZWlnaHQ6IDEuNSAhaW1wb3J0YW50OwogICAgei1pbmRleDogMjE0NzQ4MzY0NiAhaW1wb3J0YW50OwogICAgd2lkdGg6IGF1dG8gIWltcG9ydGFudDsKICAgIGJhY2tncm91bmQ6IG5vbmUgIWltcG9ydGFudDsKICAgIGhlaWdodDogYXV0byAhaW1wb3J0YW50OwogICAgem9vbTogMSAhaW1wb3J0YW50OwogICAgZGlzcGxheTogaW5saW5lLWJsb2NrICFpbXBvcnRhbnQ7CiAgICBtYXJnaW46IDAgIWltcG9ydGFudDsKICAgIGJvcmRlcjogMCAhaW1wb3J0YW50OwogICAgcGFkZGluZzogMCAhaW1wb3J0YW50OwogICAgd2lsbC1jaGFuZ2U6IHRyYW5zZm9ybTsKICAgIG9wYWNpdHk6IDAuNzsKfQoKLmFkZ3VhcmQtaGlkZSB7CiAgICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7Cn0KCi5hZGd1YXJkLWFzc2lzdGFudC1idXR0b24tcmlnaHQgewogICAgbGVmdDogYXV0bzsKICAgIHJpZ2h0OiAwOwp9CgouYWRndWFyZC1hc3Npc3RhbnQtYnV0dG9uLWxlZnQgewogICAgbGVmdDogMDsKICAgIHJpZ2h0OiBhdXRvOwp9CgouYWRndWFyZC1hc3Npc3RhbnQtYnV0dG9uLXRvcCB7CiAgICB0b3A6IDA7CiAgICBib3R0b206IGF1dG87Cn0KCi5hZGd1YXJkLWFzc2lzdGFudC1idXR0b24tYm90dG9tIHsKICAgIHRvcDogYXV0bzsKICAgIGJvdHRvbTogMDsKfQoKLmFkZ3VhcmQtYXNzaXN0YW50LWJ1dHRvbi10b3AuYWRndWFyZC1hc3Npc3RhbnQtYnV0dG9uLWxlZnQgewogICAgbGVmdDogMDsKICAgIHJpZ2h0OiBhdXRvOwogICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCg1cHgsIDVweCwgMCk7Cn0KCi5hZGd1YXJkLWFzc2lzdGFudC1idXR0b24tdG9wLmFkZ3VhcmQtYXNzaXN0YW50LWJ1dHRvbi1yaWdodCB7CiAgICBsZWZ0OiBhdXRvOwogICAgcmlnaHQ6IDA7CiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKC01cHgsIDVweCwgMCk7Cn0KCi5hZGd1YXJkLWFzc2lzdGFudC1idXR0b24tYm90dG9tLmFkZ3VhcmQtYXNzaXN0YW50LWJ1dHRvbi1sZWZ0IHsKICAgIGxlZnQ6IDA7CiAgICByaWdodDogYXV0bzsKICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoNXB4LCAtNXB4LCAwKTsKfQoKLmFkZ3VhcmQtYXNzaXN0YW50LWJ1dHRvbi1ib3R0b20uYWRndWFyZC1hc3Npc3RhbnQtYnV0dG9uLXJpZ2h0IHsKICAgIGxlZnQ6IGF1dG87CiAgICByaWdodDogMDsKICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoLTVweCwgLTVweCwgMCk7Cn0KCi5hZGd1YXJkLWxvZ28gewogICAgZGlzcGxheTogaW5saW5lLWJsb2NrICFpbXBvcnRhbnQ7CiAgICB2ZXJ0aWNhbC1hbGlnbjogdG9wICFpbXBvcnRhbnQ7CiAgICB3aWR0aDogMWVtICFpbXBvcnRhbnQ7CiAgICBsaW5lLWhlaWdodDogMSAhaW1wb3J0YW50OwogICAgYmFja2dyb3VuZDogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEQ5NGJXd2dkbVZ5YzJsdmJqMGlNUzR3SWlCbGJtTnZaR2x1WnowaVZWUkdMVGdpUHo0TkNqd2hSRTlEVkZsUVJTQnpkbWNnVUZWQ1RFbERJQ0l0THk5WE0wTXZMMFJVUkNCVFZrY2dNUzR4THk5RlRpSWdJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5MMGR5WVhCb2FXTnpMMU5XUnk4eExqRXZSRlJFTDNOMlp6RXhMbVIwWkNJK0RRbzhJUzB0SUVOeVpXRjBiM0k2SUVOdmNtVnNSRkpCVnlCWU55QXRMVDROQ2p4emRtY2dlRzFzYm5NOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6SXdNREF2YzNabklpQjRiV3c2YzNCaFkyVTlJbkJ5WlhObGNuWmxJaUIzYVdSMGFEMGlNVEF3Y0hnaUlHaGxhV2RvZEQwaU1UQXdjSGdpSUhabGNuTnBiMjQ5SWpFdU1TSWdjM1I1YkdVOUluTm9ZWEJsTFhKbGJtUmxjbWx1WnpwblpXOXRaWFJ5YVdOUWNtVmphWE5wYjI0N0lIUmxlSFF0Y21WdVpHVnlhVzVuT21kbGIyMWxkSEpwWTFCeVpXTnBjMmx2YmpzZ2FXMWhaMlV0Y21WdVpHVnlhVzVuT205d2RHbHRhWHBsVVhWaGJHbDBlVHNnWm1sc2JDMXlkV3hsT21WMlpXNXZaR1E3SUdOc2FYQXRjblZzWlRwbGRtVnViMlJrSWcwS2RtbGxkMEp2ZUQwaU1DQXdJREV3TUNBeE1EQWlEUW9nZUcxc2JuTTZlR3hwYm1zOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6RTVPVGt2ZUd4cGJtc2lQZzBLSUR4a1pXWnpQZzBLSUNBOGMzUjViR1VnZEhsd1pUMGlkR1Y0ZEM5amMzTWlQZzBLSUNBZ1BDRmJRMFJCVkVGYkRRb2dJQ0FnTG1acGJEQWdlMlpwYkd3Nkl6UkdRa1U0TlgwTkNpQWdJRjFkUGcwS0lDQThMM04wZVd4bFBnMEtJRHd2WkdWbWN6NE5DaUE4WnlCcFpEMGkwS0hRdTlDKzBMbGZlREF3TWpCZk1TSStEUW9nSUR4dFpYUmhaR0YwWVNCcFpEMGlRMjl5Wld4RGIzSndTVVJmTUVOdmNtVnNMVXhoZVdWeUlpOCtEUW9nSUR4d1lYUm9JR05zWVhOelBTSm1hV3d3SWlCa1BTSk5OVEFnTVdNeE5pd3dJRE0xTERNZ05UQXNNVEVnTUN3eE55QXhMRFl3SUMwMU1DdzRPU0F0TlRBc0xUSTVJQzAxTUN3dE56SWdMVFV3TEMwNE9TQXhOaXd0T0NBek5Td3RNVEVnTlRBc0xURXhlbTB3SURoakxURTBMREFnTFRJNUxETWdMVFF4TERnZ01Dd3hPQ0EwTERVd0lEUXhMRGMwSURNNExDMHlOQ0EwTVN3dE5UWWdORElzTFRjeklDMHhNeXd0TmlBdE1qZ3NMVGtnTFRReUxDMDVlaUl2UGcwS0lDQThjR0YwYUNCamJHRnpjejBpWm1sc01DSWdaRDBpVFRjM0lESTFZeklzTUNBeExEQWdNaXd4YkMwek1pQTBNV013TERBZ0xUSXlMQzB5TmlBdE1qTXNMVEkySURJc0xURWdPQ3d0TlNBeE15d3diREV3SURFeUlESTNJQzB5TjJNeExDMHhJRElzTFRFZ015d3RNV3d3SURCNklpOCtEUW9nUEM5blBnMEtQQzl6ZG1jK0RRbz0pIG5vLXJlcGVhdCAwIDAvY292ZXIgIWltcG9ydGFudDsKICAgIGZvbnQtc2l6ZTogaW5oZXJpdCAhaW1wb3J0YW50Owp9CgouYWRndWFyZC1hLWxvZ286aG92ZXIgLmFkZ3VhcmQtbG9nbyB7CiAgICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhacFpYZENiM2c5SWpBZ01DQXhNREFnTVRBd0lqNDhjR0YwYUNCa1BTSk5OVEFnTUdNeE5TQXdJRE16TGpJZ015NDJJRFE0TGpFZ01URXVOQ0F3SURFM0xqRXVNaUExT1M0MkxUUTRMakVnT0RndU5rTXhMamNnTnpFZ01TNDVJREk0TGpVZ01TNDVJREV4TGpRZ01UWXVPQ0F6TGpZZ016VWdNQ0ExTUNBd2VtMHdJRGd1TkdNdE1UTXVOU0F3TFRJNElETXRNemt1TnlBNExqSXVNeUF4Tnk0MklETXVOaUEwT1M0NElETTVMamNnTnpNdU5pQXpOaTR4TFRJekxqa2dNemt1TkMwMU5pQXpPUzQzTFRjekxqUkROemdnTVRFdU5TQTJNeTQxSURndU5DQTFNQ0E0TGpSNmJUSTJMalEwTmlBeE5TNHhOemRqTVM0NE5UWXVORFl4SURFdU1EazVMakE1SURJdU16VTBMamt5TTB3ME9DNHlJRFkyTGpSVE1qWXVNU0EwTUNBeU5pQTBNR014TGpVdE1TNHhJRGN1TnkwMUxqSWdNVEl1TXk0eWJEa3VOaUF4TVM0M1REY3pMalVnTWpWakxqZzRPQzB1T1RZNUlERXVOekU1TFRFdU1UUTNJREl1T1RRMkxURXVOREl6ZWlJZ1ptbHNiRDBpSTJabVppSXZQand2YzNablBnPT0pICFpbXBvcnRhbnQ7Cn0KLmFkZ3VhcmQtYS1sb2dvOmhvdmVyewogYmFja2dyb3VuZDogIzRGQkU4NSAhaW1wb3J0YW50Owp9CgouYWRndWFyZC1sb2dvX193aGl0ZSB7CiAgICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQRDk0Yld3Z2RtVnljMmx2YmowaU1TNHdJaUJsYm1OdlpHbHVaejBpVlZSR0xUZ2lQejROQ2p3aFJFOURWRmxRUlNCemRtY2dVRlZDVEVsRElDSXRMeTlYTTBNdkwwUlVSQ0JUVmtjZ01TNHhMeTlGVGlJZ0ltaDBkSEE2THk5M2QzY3Vkek11YjNKbkwwZHlZWEJvYVdOekwxTldSeTh4TGpFdlJGUkVMM04yWnpFeExtUjBaQ0krRFFvOElTMHRJRU55WldGMGIzSTZJRU52Y21Wc1JGSkJWeUJZTnlBdExUNE5Danh6ZG1jZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWlCNGJXdzZjM0JoWTJVOUluQnlaWE5sY25abElpQjNhV1IwYUQwaU1UQXdjSGdpSUdobGFXZG9kRDBpTVRBd2NIZ2lJSFpsY25OcGIyNDlJakV1TVNJZ2MzUjViR1U5SW5Ob1lYQmxMWEpsYm1SbGNtbHVaenBuWlc5dFpYUnlhV05RY21WamFYTnBiMjQ3SUhSbGVIUXRjbVZ1WkdWeWFXNW5PbWRsYjIxbGRISnBZMUJ5WldOcGMybHZianNnYVcxaFoyVXRjbVZ1WkdWeWFXNW5PbTl3ZEdsdGFYcGxVWFZoYkdsMGVUc2dabWxzYkMxeWRXeGxPbVYyWlc1dlpHUTdJR05zYVhBdGNuVnNaVHBsZG1WdWIyUmtJZzBLZG1sbGQwSnZlRDBpTUNBd0lERXdNQ0F4TURBaURRb2dlRzFzYm5NNmVHeHBibXM5SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpFNU9Ua3ZlR3hwYm1zaVBnMEtJRHhrWldaelBnMEtJQ0E4YzNSNWJHVWdkSGx3WlQwaWRHVjRkQzlqYzNNaVBnMEtJQ0FnUENGYlEwUkJWRUZiRFFvZ0lDQWdMbVpwYkRBZ2UyWnBiR3c2STBaRlJrVkdSWDBOQ2lBZ0lGMWRQZzBLSUNBOEwzTjBlV3hsUGcwS0lEd3ZaR1ZtY3o0TkNpQThaeUJwWkQwaTBLSFF1OUMrMExsZmVEQXdNakJmTVNJK0RRb2dJRHh0WlhSaFpHRjBZU0JwWkQwaVEyOXlaV3hEYjNKd1NVUmZNRU52Y21Wc0xVeGhlV1Z5SWk4K0RRb2dJRHh3WVhSb0lHTnNZWE56UFNKbWFXd3dJaUJrUFNKTk5UQWdNV014Tml3d0lETTFMRE1nTlRBc01URWdNQ3d4TnlBeExEWXdJQzAxTUN3NE9TQXROVEFzTFRJNUlDMDFNQ3d0TnpJZ0xUVXdMQzA0T1NBeE5pd3RPQ0F6TlN3dE1URWdOVEFzTFRFeGVtMHdJRGhqTFRFMExEQWdMVEk1TERNZ0xUUXhMRGdnTUN3eE9DQTBMRFV3SURReExEYzBJRE00TEMweU5DQTBNU3d0TlRZZ05ESXNMVGN6SUMweE15d3ROaUF0TWpnc0xUa2dMVFF5TEMwNWVpSXZQZzBLSUNBOGNHRjBhQ0JqYkdGemN6MGlabWxzTUNJZ1pEMGlUVGMzSURJMVl6SXNNQ0F4TERBZ01pd3hiQzB6TWlBME1XTXdMREFnTFRJeUxDMHlOaUF0TWpNc0xUSTJJRElzTFRFZ09Dd3ROU0F4TXl3d2JERXdJREV5SURJM0lDMHlOMk14TEMweElESXNMVEVnTXl3dE1Xd3dJREI2SWk4K0RRb2dQQzluUGcwS1BDOXpkbWMrRFFvPSkgIWltcG9ydGFudDsKfQoKLmFkZ3VhcmQtYS1sb2dvIHsKICAgIGRpc3BsYXk6IGlubGluZS1ibG9jayAhaW1wb3J0YW50OwogICAgYm94LXNpemluZzogYm9yZGVyLWJveCAhaW1wb3J0YW50OwogICAgdmVydGljYWwtYWxpZ246IHRvcCAhaW1wb3J0YW50OwogICAgd2lkdGg6IDQwcHggIWltcG9ydGFudDsKICAgIGhlaWdodDogNDBweCAhaW1wb3J0YW50OwogICAgcGFkZGluZzogMTBweCAwIDAgIWltcG9ydGFudDsKICAgIGZvbnQtc2l6ZTogMjBweCAhaW1wb3J0YW50OwogICAgdGV4dC1hbGlnbjogY2VudGVyICFpbXBvcnRhbnQ7CiAgICBib3JkZXI6IDFweCBzb2xpZCAjY2RjZGNkICFpbXBvcnRhbnQ7CiAgICBib3JkZXItcmFkaXVzOiA1MCUgIWltcG9ydGFudDsKICAgIGJhY2tncm91bmQ6ICNmZmYgIWltcG9ydGFudDsKfQoKLmFkZ3VhcmQtYS1sb2dvX19zbWFsbCB7CiAgICB3aWR0aDogMjRweCAhaW1wb3J0YW50OwogICAgaGVpZ2h0OiAyNHB4ICFpbXBvcnRhbnQ7CiAgICBmb250LXNpemU6IDEycHggIWltcG9ydGFudDsKICAgIHBhZGRpbmc6IDZweCAwIDAgIWltcG9ydGFudDsKfQoKLmFkZ3VhcmQtbG9nbzpiZWZvcmUgewogICAgY29udGVudDogIlwwMGEwIiAhaW1wb3J0YW50Owp9CgouYWRndWFyZC1hc3Npc3RhbnQtYnV0dG9uLWJvdHRvbS5hZGd1YXJkLWFzc2lzdGFudC1idXR0b24tcmVzcGVjdC12ayB7CiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKC03MHB4LCAtNXB4LCAwKTsKfQoKLmFkZ3VhcmQtYXNzaXN0YW50LWJ1dHRvbi1ib3R0b20uYWRndWFyZC1hc3Npc3RhbnQtYnV0dG9uLXJlc3BlY3QtZmIgewogICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgtNXB4LCAtNDBweCwgMCk7Cn0K",

"selector.css": "I2FkZ3VhcmQtYXNzaXN0YW50LWRpYWxvZyB7CiAgICBkaXNwbGF5OiBibG9jayAhaW1wb3J0YW50OwogICAgb3ZlcmZsb3c6IGhpZGRlbiAhaW1wb3J0YW50OwogICAgei1pbmRleDogMjE0NzQ4MzY0NyAhaW1wb3J0YW50Owp9Cgouc2dfc2VsZWN0ZWQgewp9Cgouc2dfc3VnZ2VzdGVkIHsKICAgIGJhY2tncm91bmQtY29sb3I6ICNGRjUgIWltcG9ydGFudDsKICAgIGJhY2tncm91bmQtaW1hZ2U6IG5vbmUgIWltcG9ydGFudDsKfQoKLnNnX2JvcmRlciB7CiAgICBwb3NpdGlvbjogYWJzb2x1dGUgIWltcG9ydGFudDsKICAgIHotaW5kZXg6IDIxNDc0ODM2NDYgIWltcG9ydGFudDsKICAgIGJhY2tncm91bmQ6IHdoaXRlICFpbXBvcnRhbnQ7CiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMTNhMzVlICFpbXBvcnRhbnQ7CiAgICBtYXJnaW46IDBweCAhaW1wb3J0YW50OwogICAgcGFkZGluZzogMHB4ICFpbXBvcnRhbnQ7CiAgICBkaXNwbGF5OiBibG9jazsKICAgIGZsb2F0OiBub25lICFpbXBvcnRhbnQ7CiAgICBib3JkZXI6IDAgIWltcG9ydGFudDsKICAgIGZvbnQtc3R5bGU6IG5vcm1hbCAhaW1wb3J0YW50OwogICAgb3V0bGluZTogMCAhaW1wb3J0YW50OwogICAgdmVydGljYWwtYWxpZ246IGJhc2VsaW5lICFpbXBvcnRhbnQ7CiAgICB0ZXh0LWFsaWduOiBsZWZ0ICFpbXBvcnRhbnQ7CiAgICBsaW5lLWhlaWdodDogMTJweDsKICAgIGJveC1zaXppbmc6IGNvbnRlbnQtYm94ICFpbXBvcnRhbnQ7Cn0KCi5zZ19ib3R0b21fYm9yZGVyIHsKICAgIGZvbnQtc2l6ZTogMTBweCAhaW1wb3J0YW50OwogICAgZm9udC13ZWlnaHQ6IGJvbGQ7CiAgICBjb2xvcjogd2hpdGUgIWltcG9ydGFudDsKICAgIHBhZGRpbmc6IDJweCAwcHggMnB4IDVweCAhaW1wb3J0YW50OwogICAgb3ZlcmZsb3c6IGhpZGRlbiAhaW1wb3J0YW50Owp9Cgouc2dfYm9yZGVyX3JlZCB7CiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRjAwICFpbXBvcnRhbnQ7Cn0KCi5zZ19oaWdobGlnaHRlZCB7Cn0KCi5zZ19yZWplY3RlZCB7CiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRkE4MDcyICFpbXBvcnRhbnQ7CiAgICBiYWNrZ3JvdW5kLWltYWdlOiBub25lICFpbXBvcnRhbnQ7Cn0KCmltZy5zZ19yZWplY3RlZCB7CiAgICBib3JkZXI6IDVweCBzb2xpZCAjRjAwICFpbXBvcnRhbnQ7Cn0KCmltZy5zZ19zdWdnZXN0ZWQgewogICAgYm9yZGVyOiA1cHggc29saWQgI0ZGNSAhaW1wb3J0YW50Owp9CgppbWcuc2dfc2VsZWN0ZWQgewogICAgYm9yZGVyOiA1cHggc29saWQgIzBGMCAhaW1wb3J0YW50Owp9CgojX3NnX2Rpdi5zZ190b3AgewogICAgdG9wOiA1cHggIWltcG9ydGFudDsKfQoKI19zZ19kaXYuc2dfYm90dG9tIHsKICAgIGJvdHRvbTogNXB4ICFpbXBvcnRhbnQ7Cn0KCiNfc2dfZGl2IGlucHV0IHsKICAgIG1hcmdpbi1yaWdodDogMTBweCAhaW1wb3J0YW50OwogICAgZm9udC1zaXplOiAxNXB4ICFpbXBvcnRhbnQ7Cn0KCiNfc2dfcGF0aF9maWVsZCB7CiAgICB3aWR0aDogNDAwcHggIWltcG9ydGFudDsKfQoKI19zZ19kaXYgLnNnX25ld19saW5lIHsKICAgIGNsZWFyOiBib3RoICFpbXBvcnRhbnQ7Cn0KCiNfc2dfZGl2IC5zZ19vcHRpb24gewogICAgZmxvYXQ6IGxlZnQgIWltcG9ydGFudDsKfQoKI19zZ19kaXYgLnNnX3NlbGVjdGVkX29wdGlvbiB7CiAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTsKfQoKLmFkZ3VhcmQtcGxhY2Vob2xkZXIgewogICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKGRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQThBQUFBUENBTUFBQUFNQ0dWNEFBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBeUZwVkZoMFdFMU1PbU52YlM1aFpHOWlaUzU0YlhBQUFBQUFBRHcvZUhCaFkydGxkQ0JpWldkcGJqMGk3N3UvSWlCcFpEMGlWelZOTUUxd1EyVm9hVWg2Y21WVGVrNVVZM3ByWXpsa0lqOCtJRHg0T25odGNHMWxkR0VnZUcxc2JuTTZlRDBpWVdSdlltVTZibk02YldWMFlTOGlJSGc2ZUcxd2RHczlJa0ZrYjJKbElGaE5VQ0JEYjNKbElEVXVOUzFqTURFMElEYzVMakUxTVRRNE1Td2dNakF4TXk4d015OHhNeTB4TWpvd09Ub3hOU0FnSUNBZ0lDQWdJajRnUEhKa1pqcFNSRVlnZUcxc2JuTTZjbVJtUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMekF5THpJeUxYSmtaaTF6ZVc1MFlYZ3Ribk1qSWo0Z1BISmtaanBFWlhOamNtbHdkR2x2YmlCeVpHWTZZV0p2ZFhROUlpSWdlRzFzYm5NNmVHMXdQU0pvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNoaGNDOHhMakF2SWlCNGJXeHVjenA0YlhCTlRUMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMMjF0THlJZ2VHMXNibk02YzNSU1pXWTlJbWgwZEhBNkx5OXVjeTVoWkc5aVpTNWpiMjB2ZUdGd0x6RXVNQzl6Vkhsd1pTOVNaWE52ZFhKalpWSmxaaU1pSUhodGNEcERjbVZoZEc5eVZHOXZiRDBpUVdSdlltVWdVR2h2ZEc5emFHOXdJRU5ESUNoWGFXNWtiM2R6S1NJZ2VHMXdUVTA2U1c1emRHRnVZMlZKUkQwaWVHMXdMbWxwWkRvMU9VTTVPVUU0TUVaRVF6VXhNVVV5T1RBek0wRXlPRFF5UmpjNVFqSTJReUlnZUcxd1RVMDZSRzlqZFcxbGJuUkpSRDBpZUcxd0xtUnBaRG8xT1VNNU9VRTRNVVpFUXpVeE1VVXlPVEF6TTBFeU9EUXlSamM1UWpJMlF5SStJRHg0YlhCTlRUcEVaWEpwZG1Wa1JuSnZiU0J6ZEZKbFpqcHBibk4wWVc1alpVbEVQU0o0YlhBdWFXbGtPalU1UXprNVFUZEZSa1JETlRFeFJUSTVNRE16UVRJNE5ESkdOemxDTWpaRElpQnpkRkpsWmpwa2IyTjFiV1Z1ZEVsRVBTSjRiWEF1Wkdsa09qVTVRems1UVRkR1JrUkROVEV4UlRJNU1ETXpRVEk0TkRKR056bENNalpESWk4K0lEd3ZjbVJtT2tSbGMyTnlhWEIwYVc5dVBpQThMM0prWmpwU1JFWStJRHd2ZURwNGJYQnRaWFJoUGlBOFAzaHdZV05yWlhRZ1pXNWtQU0p5SWo4KzlySm05d0FBQUFaUVRGUkYyKzdnMU9mWitMWC9FZ0FBQUN0SlJFRlVlTnBpWUlRQUJoaEE1VEl5b0hJaGZDUzFES2hjRUIvRkpBWkc3QVl6b05sTEx5NUFnQUVBTWlnQWFyNlRjcWtBQUFBQVNVVk9SSzVDWUlJPSk7Cn0KLmFkZ3VhcmQtcGxhY2Vob2xkZXItaWNvbiB7CiAgICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFDWUFBQUF3Q0FZQUFBQjlzZ2dvQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5RnBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5TMWpNREUwSURjNUxqRTFNVFE0TVN3Z01qQXhNeTh3TXk4eE15MHhNam93T1RveE5TQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJQ2hYYVc1a2IzZHpLU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRHBFTmtOQlFUTkdNa1pFUXpVeE1VVXlRalZGTWtaRU1VRkZSamxHT0VReU15SWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEcEVOa05CUVROR00wWkVRelV4TVVVeVFqVkZNa1pFTVVGRlJqbEdPRVF5TXlJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09rUTJRMEZCTTBZd1JrUkROVEV4UlRKQ05VVXlSa1F4UVVWR09VWTRSREl6SWlCemRGSmxaanBrYjJOMWJXVnVkRWxFUFNKNGJYQXVaR2xrT2tRMlEwRkJNMFl4UmtSRE5URXhSVEpDTlVVeVJrUXhRVVZHT1VZNFJESXpJaTgrSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGlBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSnlJajgrNDlzYkR3QUFBbDlKUkVGVWVOck1tRTBvNVZFWXhxOXZKbXBJMlNCWmpDU05LS0d3a0RFMG04bWcyUXd6RXRrTkNlVWpHeVZoWVRiVFVJWkVNV21rYkNWbHc5UWtHNG1hbW1iSzV6QVd1THFlazNjaDNXN3YrWjhQLzdkK3UvY2N6ejNuZU03elAwSHRnMTJlUjZ3VWtBK2VnMnlRRE9MQVllZ2ppSWtFcjBBanlBUFJmbnA4dG9XOUJlMjBRb0hLYTB0WUVoZ0NWZHdCTm9RVmdDbVFLalBJdExBS01BdGlaQWVhRkZZTTVzQVRKNE9ERFlsNkJ1YWRpaklsTEFKTWdIaUZPV0pNYkdVZm1hWnNIWU45OEJ2czZoYVdBMW9seDJ5Q01mQWQvREYxK1BzbDVyd0dQV0FZWEpuOHIzd05YakI3TDBFTnJaTFJ3eS9tNlpEb3J3OGtTcWV3VXBETDdQMEVwbTNZUlJCb1lmYnVnVzViUHBaREs4YXBUbkJxUzloN1dqV09MWHl6NWZ4UFFTV2p6MGRXY21QckVoZEpOSUVwcklsVzE5OFo3YVVWMVNhc1FXSm5BcDNEencrRnFXeGxPbVYySGVYVmVjYmVnSEJUWVM1WVlWeTF5ZWpyVkpoSXB4bHVGUGFCNlYxV2hTV1FUWGpjSnF5S2pGVm5oYWdhYkJoRkZrN3RnblBtbHArb0NoTmJtTVhNNzBYZ0wzTmVuNnF3ajh5K3hmdjUzZlFaS3dlRnpONXhXNGMvQ2d3d2U5ZkF1aTFoSXVCbE1udEhaT0tOaXJBeWlRK05MYkJrdzhmRUU5SU0yUVNuQnYxOUkrb1dWZ3VXUVN4enJuWDZFVnJxb1YySTE1a1MwQXhlU3N6am8rMzI2aFFtM2hvU1FScVI2bUNlTDJCVjV4MFZTallRb2pESE5tZ3pjWW4vVXhqL0g5U0JNN2ZrTVE5NTFUdXc0YWFnZUVNcFk4RlVIblB5K1haRUNYYlJUVUZ4aGV6RXFDaVpGZnNGUm5YZGcxeGhnY1Q5QkYvQkpHMmh0UktpRGp4Mzc2RVg5TWQzNkhvUi9ORHA1akoxSzhBQWNRQm1vb1poVGdRQUFBQUFTVVZPUks1Q1lJST0pOwogICAgYmFja2dyb3VuZC1wb3NpdGlvbjogY2VudGVyIGNlbnRlcjsKICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7CiAgICBoZWlnaHQ6IDEwMCU7Cn0KLmFkZ3VhcmQtcGxhY2Vob2xkZXItZG9tYWluIHsKICAgIGJhY2tncm91bmQ6ICM3NzhiN2M7CiAgICBjb2xvcjogI2ZmZmZmZjsKICAgIGxlZnQ6IDA7CiAgICB0b3A6IDA7CiAgICBwYWRkaW5nOiAycHggNHB4OwogICAgcG9zaXRpb246IHJlbGF0aXZlOwp9Cg==",

"button.html": "PGRpdiBjbGFzcz0iYWRndWFyZC1hbGVydCBhZGd1YXJkLWFzc2lzdGFudC1idXR0b24tZml4ZWQiPgogIDxzcGFuIGNsYXNzPSJhZGd1YXJkLWEtbG9nbyI+CiAgICAgIDxzcGFuIGNsYXNzPSJhZGd1YXJkLWxvZ28iPjwvc3Bhbj4KICA8L3NwYW4+CjwvZGl2Pg==",

"style.css": "QGZvbnQtZmFjZXtmb250LWZhbWlseTpHb3RoYW1Qcm87c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL2ZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUlIa0FCTUFBQUFBLzVBQUFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJHUmxSTkFBQUJxQUFBQUJ3QUFBQWNYcHhFS0VkRVJVWUFBQUhFQUFBQU9RQUFBRDRGY2dQc1IxQlBVd0FBQWdBQUFBK0RBQUFnd0xPTURMdEhVMVZDQUFBUmhBQUFBTlVBQUFIdWZudU10RTlUTHpJQUFCSmNBQUFBV0FBQUFHQlI3RTVLWTIxaGNBQUFFclFBQUFJa0FBQURIdU8zWWFsamRuUWdBQUFVMkFBQUFDd0FBQUFzQ29zT1ZHWndaMjBBQUJVRUFBQUJzUUFBQW1WVHRDK25aMkZ6Y0FBQUZyZ0FBQUFJQUFBQUNBQUFBQkJuYkhsbUFBQVd3QUFBWDNzQUFNSTQwL3BoWldobFlXUUFBSFk4QUFBQU13QUFBRFlGbmNMNWFHaGxZUUFBZG5BQUFBQWhBQUFBSkE4Y0NWWm9iWFI0QUFCMmxBQUFBMEVBQUFVeVZOT2E4V3h2WTJFQUFIbllBQUFDbUFBQUFwenp2Q1lrYldGNGNBQUFmSEFBQUFBZ0FBQUFJQUpzQWFWdVlXMWxBQUI4a0FBQUFVY0FBQUo0SzR3UFpYQnZjM1FBQUgzWUFBQURhd0FBQjFjcCtUcnRjSEpsY0FBQWdVUUFBQUNXQUFBQTBCK1VUVUIzWldKbUFBQ0IzQUFBQUFZQUFBQUdDMlJTc3dBQUFBRUFBQUFBekQyaXp3QUFBQUREaGVWMUFBQUFBTTdZdStONDJtTmdaR0JnNEFOaU13WVFZR0pnWTJCa1lBZGlEaUJrWXVCa2RHQmdaSFJrZEdSZ1luUmk5QUN5UFJsOWdPSXNZTFVNQURwc0FtWUFBQUI0MnJXYWY0eFUxM1hIejkwZDlzZXc3TS9aWlptRklkbHNpSGRsbXBhaC9OaGxpMlcyeTRCdDdLenhHdkRna3NiWnVEVkVHZU9XaGkxT2JYblNsVlhGVlJKRnE1V0ZFbXNWclJBYStZOFZtcitpYWw5YU5hTFRrR0Q4cE1na25SVEZHRStqcUhLb2kvRytmdTU1ZDJabktkaVZTdlQwNWI1NTc5NXp2K2ZIUGZmY3Q0Z1JrYWhza2dOUzg0V3ZQbnRVbW85Ky9ya3ZTMXdpUEpjZ0VQdStmRi9EcnhxcC9jSlhqbjlGWXZwdi9Ka3ZQdnRsK1FTdmpmYTBrTENYTkVpcmRMdW41ZllRYjJ6N0tvaktDb2xKUDAraTBpZkRQUDhpVjF5K3hOVWpMOHEwckpVWithNGtaWUZyVUg3SU5TVC9MTCtWSGFiUDlNbWZtMUV6S3MvY1RVbUpsMVhYYjV0TlpwdlphLzdPL0ZQTlNNMDNhNXRxYjBTNkk0bkl2WkhCeUNPUlA0MzhkV1FoOGkrUlgwZCt2VUpXbkY3eEQzWHh1cU4xMzZqdnJ2K2orZ1AxUDI5NHFpSFgyTm80MEhpZzhUdlJwNk12cjN5NmFiVHA2cXFGNW51YlgyeSswSHl0NWQ2V2t5M3pyYjJ0OTdUZUQrNXBmYlg1R3I5KzFYWmYyNHV0dlczejdRUHQzKzJvNmZpcmp0YzYzdTlZakVWaTBkaUREVS9GeG1PemRVZGpOMXBPMWgxdE9kblowTm5WT2QxNW1xdWhNOS81eTY2LzZWcm9lcVByMnVyblZwOWNQUThXVnBlNkI3cTNkYis1Wm5yTnVUVS81UHBsdkNHZWlOOFRINHcvR0g4Ky9sTDhtMXo1K0EvaVYzcnFlbmIwUE4vejdaN3ZjODMzdkJsL3FlZTluaHRyKzliMjlieTNkc3ZhL1oxZC9IcVo2OEs2MzF2M0ZQOCt0ZTVmWTlIRTVzU1RpWmV3ZlR3b1liT3R3Wk95UGZoYkdReGVsUjNCQ1R5L0lmQmtBR3dNaXJLSmRqTVlCYnRCQ3V3TmZIa0lYNDF4dngrTTArOEU3UUx3UUxQMEJVbEdwMldFR1VicHZac2VLZHE5dEdPMCsybkhlZmM0dnAraTd4ejNIcy9YU3dmL3hvSVp1UG53eU1FakI0Y2NISEl3VGNvMlJtNFBvckJOeW83RjYwNTZTYVh2NGQxZTdoOUNUamdMTXdRRk9SaU15YUVnSStsZ0ZwNDVlT2JzYkdacmtET0RnSEhHTXV0Z1prKzZHQlduUjUvT21HSzJITFBsWlFoV085QnBtRDRINlgySWZrOXduK2IrTVBmSHdSUjlyd1lwMDBEZnhGM1I1Zlo2WkQ5U2p5RnBYenpEN0htc0c1Tk9KRmlkVmdmRDBzMzlHcDViei9mUWN5Mi8rMkJRWnJjUkZtV0dXOUJ0bVBjandTVE0wakRMd0N3TnN3TE1NdklJbW4wT2pQSHNVZHI5UEh1TWRoeVdqelB1QVBjSHdTSHdCRWlEd3pDM2RyTHNwNWgzRHRtaEZtbTV3THNpdUlHY0Q4Q0h3WXd4UWRaRWdveXBCMUYrZDlHdUFRbWV3d050QzFJdkxjeldCdHJSckJQcG9RZi9rWm1LWXN5SVpNaG9xNFB6UEh1Ylg1UDhhdGNlUCtiWE1QbW5YZjNrODJRZWk1VDBhVVNmZG1vL2p5ZjlVcWVqWXNGbEovOWlwVzhiREpMU2lyM2FhTnNYaTZIbjFmWkZldnZNUG9idEM5amV4KzRsUmhhdEhRd3J5L3lobFIrc0p3UEdWZDRZMmJlRlBtMmduVEZMR2wzU01TTkV0MTIxcnhNN1ByRlRKQ3B6OGhsWnBSeHkwb3NOTndSbjhlZFpmSGtXWDU3RmwvK3VzYndOZWR2cE44ajlEdWJjaVE5R2ViWWJwTUFlWGFNRmZGckFud1g4Nk9ISEVuNzhHbjQ4alEvbjVCaDlUaUJ6QVhqNGdGaEJoNXpaRXFTSnhMVFpEZ2JCN2lDSmozeGpzMFVEczErdThCMmkzYUdycUtTcktHMDFoSHNKM2o2OGZYajc4UGJwV2FLbnpTRWx0ekpLYmxXVWRGV1VKVHpocEp4Z3pBTHcxTFlsZU9FeGFXS3VGaXpUQnRyVlFqYnFYeU5EMlNndndXMGFick53TzhlTXJ6RGpKSkgvZmF5VGsvdm9hNlVmb1owS1hqUDJXY015UG1OVlBOS2F4MHJTSzQzRW00MEtqUWlpdVJjZWZVVDVCdlFmQUJ1eC9pYmF6V0NZRVNOWWU1VDdVR3A1N1JkVnkzR2RvZWhtc05uRzV0dWluQUpUeUp4ajdBTDNIdXQvcS9TYlFiQVQ2Ky9pV1NQYWxwejFMNkhoTDV4TlBiUXJ5Z2lzNWtBZFhJdHdMY0t4QURlcmE4SFlIcC9FTHpPd25vYjFOSXluWVR6dHJGWnlHY3hEcm9mTWVaZnZQUmRQWGxVOGVTNmVDc1NUanpaWnpRczJKNFR4TksxN3dBSXRPd2krbThGM001WDQrU1RSbmE2Szd0dmxVaDhtc1VvdURTTTc5SkJsTWFZNXRIcm02aHhhcW9yaW5PYlQ3UzZuN2lhYmwxbTAzeUdTem1JeER4YW5ZWERXUlpIZEs3SjQ5dlZLRklVUmRGWWpxSnY0S0ZiRlJ4WXBHYVFra1ZCaXRLZFJQMnc5WlBtejRoOEhCL0hVSVpBR3gzVG56RmlyTGZNNWZjMWUrdGJCdGFUOHFublp5RjVabFRjS1N6WkMzcGpia2EwOStJMmNtTFJvL1BUUk8vUjUyZDhGV0JZMGptejA3bFRMbHZmRW9rYnBsSTF1OVB5YXk0NHBwMnRLMW1HVkJPampmZ1BzQmtDNEhrN2p6OVBNWk5mRVpSbFp2Q21qWUhmUUtpbmFQYXpSdmR3L3dQc0hneC9JUStEaDRHMTJvcjNzUkh0bGpENlAwdTZuejJPMDQ4R244UGtaSW00ZjdQYkJiai9zOXNGdUgydm9zMFJlaWhnNHpUckt3RFlsYzR4ZjRMZTNlSk40U0JFUEtiZU9Nc1RBTERFd3E3azVYQ250VmF0bFNQZitjTVZzUmVkcGVrVTFYdHRvMjhFNmVpVTBXcEtWN0x5UjUwc1p1cUMrSDFULzIvem91N3lRd1VjWmJEQ0puekp1OTUxRWYyb3c4REI5SG1HZXo0RXgzajlLdTUvM2o5R09FMWZoVHB4RC94ejY1OTFPbkVQL1Y5QS9xNW44bE83R3Rnckx1S3llcWF3SDFoSDY1eXE3cmRYdXJQTm8zbmswaVhaRnRDczZqNTVEdTNObzE0OTI1OUR1SE5yNVZkb1ZiOUZ1RXUyeWFEZUpkcmE2ektKZEVlMktUcnM4MnVYUmJoTHQ4bWlYUmJ1ODA4N21renphNVoxMk9iVExPKzFtME80YzJ1VkQ3NnAyNTlCdUV1M3lhSmQzM3Myam5ZZDJudHlEZGlYTmVMM012b0YyQUd6azJTWmFzcEpXUmR2NHZiU0dmdUt5M2l4YTVOQmkxbVc5SEZwUWk0S0hOWmZQd2p6bi9PRzd5aWludmdpWnpzRFVkMWx3QnBhemxTeTRpL3hUemtGYllQaFZhU0hEdFpJUjIyamJXVG5ya0pMUW1uVTlyTE93enJwYUxndnJMS3p6anJHTjFaODQyeWRodlI3Vy9iQmVEK3NjclB0dmlhd0piRDhCKy9YWWZnSU4rckg5QkxaUHV0cGd3bVhVVjdCOVdKa2VodGN4M3AvZy9oVHZweGc3eCs4RmZudkJlclJLbzFYYTdGeThqbVlUYUpZejFscHhOSHRIcTZnTjVJWUJzQWxzQmxzMEY1WmNwZUs3U3FXazU1Q3dVckgyOUdFUlpwNXdSM21kR1Y5M0ZVcFlaVEhHMkgyMXMxSm5oSjROYTQybHM0cXZGWGg0d3ZGVnVqM2hoRFA0eTJxTjBGdStubDA2YnJNdnBaYlgrR3Jsa2twK1hPdWZEQkt6MVh0UmhXTWRPMTZSS015VFd5Y3FjNmRCcSs1Q3EzVC9DS3ZFc0ZkR2Q1bUQyQ05rYVU4bUJhMFZqbEFYWUVQMnRCSVJYNEpwazhvdTZ0NTBwNnJENm5rTW5OSWRBUW5zQ0Z2WlhiYlREdExlajdSZHZHdDJmUHdxUGpra3A2djRGRzdoRS9Mb2tTWXNzUXEwc0RyYVFEdm9sWlRzNU5sOTFOd2o5TDVUN1dmUFhFZm9kNHcrYzFyOWxPQTRETWNVSElmaGFMUDNMRHlMWnJjOHpYbDNKK3VxYkZldnlxNWgxTmdLMUZlTGpGUmlMYXlLbDFmRUpWY1JsejBTeHRzcG5vV25XQnR2UHZIbU03TlBoSmRjM1JCYUtEeXA5TUpreVVLZXMxQWVhUjU2MlZyQlZuZm9nd1RXTFhxRWtycXdWajlTN0Y2YXdsb1RTUEZjN1hnUnZwZmdleEcrbCtCN0ViNlgxRXJIbEZzQmJoZXhVTCt6VUwrelVNcDZVcVBLcjhUYmZlWHplVVhUSXZ3S2xiUHVrVkJxSmFxc2hLYXFhQ3E2YUNxNmFDb3FoN0ErdGRFVDB4SHIwR1FNcTl2OWRDeXNrcldXbUZHN2hGb3QxWkxWZGVSNHBkNG91dlZZZEp3OHJZcERiVzBkV2NRVFJiUWNZMFpQSzJJN2EwWlBHMjIwdHZaYVBxdS9MTTlVNTVnd0N4U1huVGpDV2N2Kzk1My85ZVRCckpsS0RIUnJaZ3ZYbkoycDVHSTc3NzZxNU1YdVAyTzZ2M2xPdjZVelJUakxyTlBOeG5xK2t0WHVKOGJMZXYxL3JYbXJYaDl2elNnenpINkUxOE5UQ1d2d0RsbDMrVWliRzFPVjBlTzNPZUVkWG5iSzQzelAyVHI4MTljdldrVWllU3U2TDMyMXNiWFVSS1hPSGFzNlM1VXJWWHRpK3hGamZncXVzcTdzU2R6WGszMEhPNnJ2S2wvN0pTaUx6QmxYM1NlMVB0L2p6bWZoU3ZGYzdwMnRyT1FwM2J0djNYZksybTlGWXJoRGxDWGJzMWxHejJWN1ZLcU51Rm10Yld4ZG8zc083eGFxcE5hcWpjcjJxWlYzcUJpMkFpdnZFMVFLQldJaVNxVlFrSGF3RGowUzRCUjRrK2MvZzJlUm5sZW9LcTd6L24xd0Ezd0Fib0lQd2VKaXdSaFFBMnBCQk5TQlJyQVNOQUhrRytTYkdPZ0VRMkFYY3hobThjaTZWOUhxSFh6eUxocjhoNTZ4TWpETVNGU3JyY3M4dlFMZUJ0Zm8vd0g2UlVBOWFDRFNHbm4yR2RWRjlWRHVTYmpuR09ucFY2TXIzTCtOcEd1MHYrWFpkWjc5RjNnZi9MZCtWY29pTlNzM3dZZGdNY2dhQWZZTFV3Mm8xUzlOV2JNQzFJRjYwQUNpWUNWb0FxdEFNMmdCSFNBR09zR1F0VEVSbEpienpQNVQyamZRSTlUSnN0SnZnbWh2ZGJQYVc4azVkTXFaWHJWRXl0anZNUkc1QU8rMzZGR2t2UXBXOE1SSFUvdkUxeWZ2NnJlRmovTHBCV3dRK2pYci9EcHpWLzJhV09iYm43RkdtdFdENTJFWGF1eWhzWGNuTDVvdTd0Y0F1d1BYcW01VzQ5K0FLTnh6V003amFRNys5azBvczZnV25NR0MxZ0k1enFUMmRCV2VyTEw2M1RBY2xkRm9mc3RGeEZWR2hpT3NmSThJeUpraHh0UnFSREtyYWRYdlp2LzdkSnJCbWhtMTVubTFaa29qelZxeUhHSFg2ZnMrK0FBc2NvWVFZRUFOaUlBNlVBOGFPVDJ0cEcwR3pNT01VY004aGpNVEVaUWtncEpFVUJLckpMRkswaVJBTDMyRzlGeVNrdDlmRnZPV3pZKzV0eHJmaGZpWDRDNnVnUzdRRGRZQSszWDIwMjVkMUd0VWgvNHBSL2FTSjJ1dFZUVXViRHpVMHk5M3gwelI2Q1Q1eStKalNhTFBpQm5XVEhYa1hGVTVNMUxESERibWZGYlpUWTFFSDQzY0UzVDBsY05LRjVkTldtRzFNbWRZWldXeFpnNEwraHJSaHA0UkY4a0oyaUZkQ1RkWUNiVXF1eUdVRGQvck9zTEQzcjZPcUFkUjBLR2pQV3psaWJFcmhMNDNXTmszWFY5RFpnODVoU3dUL083VnI2aFd2dEhWdFBTMlZYdUV1cXh5dGMyTTFqYlhLNHlYMW1FVWxOZWdIVFZrKyt1bzhvZ2JWYXpMdWk0eDkvRzJYMmJ2OU0vSWltV2N5M3dqeUN0VnNvRDlEbDZybWEvczBZYVAxYmorRnJ1RWVTVHN3WDZ2KzBMMC8rUXQ2NlZJSmUrV0dkU1hiZVI4VkxhUitzaFpjN2xkL0NxN0xGazB0RXRKYmRGMlYvNkt0RnEvcFN6OURlMzI5Vlg0TjdUMU92S0Z5bmNPcmJSWkxXbVh1ektza3JUbVB3UHNkNEpWN2k5MFNWZnZua0g2UE5MUElIMGU2V2VRUG8vMDgrNjdrSzIxem5CQy8xMy9SYTc4RjZ3MXY5Ty9sNVZuaVg1YzlWYXBzUnFwdVNhcDMyS2N3TWFvTlNlbzUvdXh4ekJuMkg1WkM0NmpvWEYveWY0RDRxcGVoRkdOUEZ2SlZZUEZWNUVmV2lUQnF1aVRBWHB1bE04eWVoTm4zUVQxM3FqY1MrWDdBTS8yY1NYbEVYbFNOdXZmd25mcDM4Skg1TSs0L2xpT2NZMHkyM0haTFNlNDJQVzU5c2dMWEh0bGl1c0IrUjdYZzlTSmM5aDlRVHprL1VqT0kvR0N2Q0dQeXB2czJnZmtMYmtzaCtYZnVQNUVybkFka1YvSnUvSjUrUTNYbCtRLzVUMU96TmZscGp5ai96bmdXVk5qYXVTNGlaaUlQR2ZxVEozOGhXa3dLK1V2VGF0cGxaT20zV0FmMDJXNjVYbVRNTDN5Z3Vrem41YXZtODJjTTZmTWtCbVNiNWlkWnFlOFl1Nm5ydjU3L1p2OXQvNEhVeVdiWmdCNDJyVlBPd3JDVUJDY1RaNGlLVklrd1NLSUJBdXhFQXRKWldjWkRYZ0ZnNkFJd1NMWWVBZFA1RUc4VHB5M2laTENTckI0czUrWm5kMEhBZUFoeFJITzRWYVY4TXZpZXNFSWhuM1VOUndHcDFNSlhKaGpWUndRS3libCtWUmdxamlueVBJV0hVVlJCUHJ3TWNRWU15eXhVamZoemlidXlkb2RkenphN0NtbTRTUnBZMHJkZ20vQTJrT0FHSW5rM0pSaEoxdU51V3c0dVpPTW1Pdm03S2NaZTczaHJTTk1lRzF6dlZFdVZBdzZlYWhxRjVIMWJyVzlMOXAvZUFyOTdOOEVSdFowQzlnTFAxejA1b2l1Y3NxOEFINU9IeUFBQUFCNDJtTmdZbUZnbk1EQXlzRENPb3ZWbUlHQlVSNUNNMTlrU0dOaVlHQmdZbUJsWmdGUkxBME1YT3NER0JTOEdLREF4UkZJT0REdy9tWmh2ZjV2QjBNbnV4UGpMQVVHQm51UUhJc3k2eXdncGNEQUFnQXhMUXpMZU5xZGtWZFBsRUVVaHAremZLS3NpS0NvZ0lBRHl0b0ZsYlpVS2RKY1JjQXVzdFlZYTFBVFJhTW1WdXhDeEJJc3NWZHNzZGRFcFB3SDlXSy9tSGlqdHlZbUx2a2NkdzBoOGNMRVNlYk1leWJ6bmpQekRCQ0FmMFlqT2lMaE9oTmZidkJEcnhrb3JhSzA2c2RPTEttU09sdUg3WVB0a3hGc2xCdlZodHRvVkhZVnJxSlVySXBYRHBXa01sU2hjcXVXdVBnRTcwL0RzbjVYMVY3RlJhbnM5b29SWWxRWU5VYURRb1dxQ0JXdGxQWW1LbWNQcjJpdldOK3R6MWFyVld1NXVxeXViMTFmdlozZURtKzd0ODNiWkRyTU9EUFdqREdqelVnenpBd3k4WHp4TkhzU1Byb0NTL3h2K2M4UmFMUDdTUEJYRmNIMlI5bitVY1B2RE5Ea2VoRkliL29RaEoyK0JHc1NJZlFubERBR01KQndCakdZSVVRUXFSa1AxZFJqaUdXWXBoVkhQTU1aUVFJT1JqS0swWXhoTE9NWXp3UVNTV0lpazVoTU1pbWtra1k2VHYxVG1XU1JUUTY1VENHUGZBb29aQ3BGRkZOQ0tXVk13OFYwWmxET1RDcW9wSXBaekdZT2M1bkhmQmF3a0dvV1VZT2J4U3pSOTk5UFBRYzV6QW5PY0lFclhPWXExN25HRFc1eGg5dTBjSmY3M09NQkQzbkVFeDd6bE9jODR6V3ZlTU5ieVdJankxbkJLc21oamt2VXNrYUsyY3hxWGZzQXpUcHU4bkZheVpZZTdOYXlYY2VidkdRWHkxamZ2YitPSFpMTFVuYXpqOU8wOGw2U0pVV2NraUdwa3NZTGZlSWRiVklvUlpJdkJWSXFaWkxOVmttWFRNbGpMMGZZdzFFT2Nad0dHam5HU1U1cFJ4UG5PTTlacmRycFpJT3ZUd2ZiL0ExL0FkWXdqU2tBQUFRakJab0FrUUIvQUlVQWl3Q1dBS29BcmdDZUFKVUFuZ0NpQUtnQWpRQ0NBSThBa3dCekFFUUZFWGphWFZHN1RsdEJFTjBORHdPQnhOZ2dPZG9VczVtUXhudWhCUW5FMVkxaVpEdUY1UWhwTjNLUmkzRUJIMENCUkEzYXJ4bWdvYVJJbXdZaEYwaDhRajRoRWpOcmlLSTBPenV6Yzg2Wk0wdktrYXAzNld2UFUrY2trTUxkQnMwMi9VNUl0Yk1BOTZUcjY0Mk10SU1IV214bTlNcDErLzRMQnB2UmxEdHFBT1U5YnlrUEdVMDdnVnEwcC83Ui9BcUcrL3dmOHpzWXREVFQ5TlE2Q2VraEJPYWJjVXVEN3huTnVzc1Arb0xWNFdJd01LU1lwdUl1UDZaUy9yYzA1MnJMc0xXUjBieURNeEg1eVRSQVUydHRCSnIrMUNIVjgzRVVTNURMcHJFMm1KaXkvaVFUd1lYSmRGVlR0Y3o0MnNGZHNyUG9ZSU1xellFSDJNTldlUXdlRGc4bUZOSzNKTW9zRFJIMllxdkVDQkdUSEFvNTVkekovcVJBK1VnU3hyeEpTanZqaHJVR3hwSFh3S0EyVDdQL1BKdE5iVzhkd3ZoWkhNRjN2eGxMT3ZqSWh0b1lFV0k3WWltQUNVUkNSbFg1aGhyUHZTd0c1Rkw3ejBDVWdPWHhqMytkQ0xUdTJFUThsN1YxRGpGV0NIcCsyOXp5eTRxN1Zybk9pMEozYjZwcXFOSXB6ZnRlenI3SEE1NGVDOE5CWThHYnovditTb0g2UEN5dU5HZ09CRU42TjNyL29yWHFpS3U4Rno2eUo5Ty9zVm9BQUFBQUFRQUIvLzhBRDNqYTdMMEpZRk5WMWpqKzdsdXlKODJlN2x0S0N4UUlKSlJha1dVRVVSRVJBUkVSQVFIWkZ4RVJFUkVCUzRYS0pudUJBcDJLRENLK3BBRUxBb0tNQ3lJeURnT0lpc280aWgyUlFWekdnZWIxZjg2OUwya0taZm5tKzc3NXZ2bCtmelRweTJ2Njdybm5ubnYyY3k3SGMxMDVqaDh1M2NjSm5KWnJGU1NjNzVhUVZuUis3dzlxcE05dUNRazhYSEpCQVc5TGVEdWsxYmhxYndrUnZCK3daZG1hWk5teXV2S1pTZzVacFl5UzdydjRTbGZ4TUFlUDVLbzVqa3lSeXVDNWV1NFdMZ1QzOHNORXp6bkUvSkRFYy9sRU52aGs3cmdzK3NPQ2hXc2g1c3VhNkZYUVNQSzVvRVJzZGxsWDFMcE5vQ0RnRXZEbHJkN3p4czQyRDV3NElUV1pNcVYyRW94UkxJd1hyRENHQ0dPMDVRQW9EaDRUQ01NbkhUeFE4cXVEaEhVV1RzdWVHOVJ4Tm51SWw3UkZSVVZjNnpZcEJKNmI1WUMzNG81N041R2l6cnMzQ2VQNWxzYkk1L1FONXpHUTQ2VDJNRVlLbDBIdTRVTEpNSStReTUwVUNBUkNXaGd2cERPYThGb2lYSDZWUm04dzUzZ0NRVkZUVXlWWTB6TnlQUDR3UjVJbGMzNFZiMHROdzE5eFFrMlYwNU9ZQXI4aWNxWlBUajRlVERMV3lFbldvQmFoTTlhRXREcERmbFZucmFqUGwzWFdvQnZ1dXVDdXk0MTNYUTY0NjdMU21aaU1OY0Vza2krM1M5N1Z5ZkRUTDV3cjM3Q3JVOHJQL2ZCQ1RyWlc4Y2xhUjM2VlFOODErQTZEVk9tVGRIRGh0bFlaM0VZSFBxcks3RExCRjZ6MDNVYmZuZmlPMy9IUTc4QmZKZEsvZ21lbVJKK1RHbjFPR242bktqMzZ6UXk4TDNTMjhnTGl3bXJEcWFhbXBXZTB1dXlmM0RrWjBPOG9DRGk4QllCL1hBTWg0UExDSzB2d092QlZtT1hJR3Zocmo1K0lvZU9pOXFTNHcrSmJUdjNjNDRMeTkwNkxPeXJUT3kvcXNJVVVkMWVta3pFTFNXZ0JHYWFzdzljQ3BlZENaUVVaZ3krNER6UW5jSlByQ3NVRkdpdVh6dVZ5TGJsRlhNaUlWR0lKQkhNME5iTERIekxtSUdLTkprQnNtZzlYVHM2RGxXbmxrM1hIZ3htR0dqbkRHaFJKZnNpWTZ2WDcvZUU4STVjRkZHeDJKTU1uT2M4YWJBNHI0VEhVQkgzd00wTUhKRXVLZ3A3bU5udlFaZ1VLQzRwcGNKbWVWRlFrNTloZTU0ak9hdk40VytaNGltU2pYVFlBY1hjaTZjUmphMFVLMnJZckJCcDNlN1M1ZWJaMDRuSnF0QzV2UVk3Z3hGOWJDT2tJMzhqTm16enc0VDBUdi9ud2h6MXpEdTN1WDdxbDVxTWZEc3hSL3E1dDhmU0VtU3ZKZ3RscnBsV2VtSDcvRUJQUEZlN2FXUDVIL1JOUDJWK2NQalZWMGJYYlUvN2JQNW9PSHZhSXBnNzNkVThscDhVNXRaeW1lT1RnU1UwQlJ4STNwdTY4cHBPMGhUTnhIcUR6cHJDWHlyaFFJbEo2TG03YkZpS1hBNU5PUW5JWDRDM29GbXZDL3N4Y3dad2Y5TU9sMVlDWFlTdjlHcEVMY004RkxVRFZGbXZRQVhqUndLWEdHa3lGeTJadzJjeEtzZVVGK20wSFB4MFdtNzNLSU9DV0tBcjZtc0dIcE16Y1pQakFCZjJKZ0wxVWIxRlIwRzJGS3cxWEJDaHp0RzBYOEx0ZFRndnhadWZhbmU2QXZ4M2d4cHN0a0lDZXRPMUk2QzgxOEx2Qyt0OXB4bFF2WHJDOTE4ckJpN2JQbjlDcjkraEg3K256a0ppMjVOTFhmQjdjWEZpMUhYNWJNckZYbjVINFM3SDl5bzlQckJxNmFjUnhJaHhmc21Uc21CY3ZIcFRLTG80Z2c0YStQT0xFcXBVbmpxOGF1MlR4dUxGTFhrVDZHbGozbGRSTENuSEpuSmZ6Y1JNWjNvTHBtcHFRRGxIVlVxb2hjbXVLa1JSempaeGlCY2FXSDh3QndzcGh4R01FTkxUQld4SVFEMThrTjdlRmRZbnBXV1pHSkNHTE94TlpWVEFkVUNFN2krU1d0aDJjWkhTNHMvTGdDNEFNYXhOS1BIVFNFbWxYNk5Gb0hkbzhUWlk2L1VKaUlRNm4yMFBwQi9Bd2tBem8wZVZQTHk5L1Y5bEc3aGpVczNqczhJdlRUeDlSTHY2K3JuTHpuTDJibFZuem56L1FvZmY4K1kvMUh6S056Q0x1NXg5WWN0L2kzKytkWC91a0VwcS92Y1BYYytxNHdkOSs4ZVhyajVmdElxV0JDbjVLcDBuOVd6MC9xTitrcWNEdWtSK1RPWlFmTjJmY1dHWEZSSllvSHdiK2JnTStySUhwQ2h5ZGJwUUhGM2ZjRitXODhKeFM1UXRCSTFWelJzN0JFZG5razhueG9CWTJtUmtFUStzMmRpdlh4S1BoclhhUE5xZVVlSW1yeS9mbnpuM2ZSZm1PRlBDdHlNNjFvMVlwYzVWVVplNnEwV3ZoV1pPVkwvaHo4YzhTamdmMXNXZDUydG10ZkY2aHlGazVhVEo5REhFUnIzSksrYTU2RlhtSy9JVTh0V3JVV3VYMnlCK1ZibXRocThEekZnZ3QrYStrY3M3RytUa3F5Y0lKZXBRdVJMWlRnY2I3dzBZcWJtUzluMUsvRVdZYUpBWXFieHlGZVlVZUlTQVVlclFlYlo3RDY5QXVPSGZ1cHFPdXNhNmpoZDkvWDBndmhGL0hUUnkwbEhCMTNOSkJFOGNOV1Y0SGd5NW5ZNWR4cDhWaWNUL01wVGNuY3o1Wkd3Z1NiUTBJdWhCSGtJdHhCbjEraUhCNFNRUjlQcDJ1QVVFSzZtSGZpZjZRM29DLzAydmhhd1k5WGhvNGZiNktDa2RCbGcwa3Vpdkw1cldWa1MwcnlSYWwzMHErWkJuWnBBeFlwZ3dnbXhnTWcrbzBaQUIzQW1Cb3ljbEdYMWlqNS9RaUcwcWlraFpsdWM0YUZpaW5sQVZmRk5NZFNRZmlCUjRIckczUTdiZmV1WHZjMUZEeVhVWE9FOVhUNTZRZzdmQk9maSsvQzNaVU5zNHRTSFExK0NLeTZBdHlKQjlwQnlnSmR3K0QxVlhNRi9IT1Rac1Fwbko0UTVnRXJxQ2hwaEYzalE5U2FSQWdqS29hN0hHb1lwVHZQbkVDSGxOM1RMa29wbW1Hd3JNNDRDZ2tYOWp4WXUyZHlrWHRxRjlYVWIxbVp0MFpxUWoydTVYTEF0MHBaTUxkN3RiV2hFVGM3ZWtDQUp4TmQ3dk5VaVBick1Ga2xPcVdtcUFYZmliYmdCSkVFOTNPYnJqVXFmek1uaFB3aTNhWGt4ZTkyYTBJWCtoTTU0RngyUXZhOHJobCtabkxTRkpWbUxpV0xGVytyWHIrNjlYOU5uZDY5T1doc3crT0hITm8xdXozUi9HSEQ1SmVIN3l2QkQ4NHFMejJ3UlB2RTh1cUtTY3FoMjRpcGczbHhQenlTOHBQZE4yS0FIaUxWTWxwdUNaY1NFVGVUcWdhcHZYSjR2R2dBRHRDaDl0U3BDSU1VZHdrQUlRZ0ZaSEJUNnhYZnBEeXAxMGNLTmIyWlRRd2xPUEVIdEkya0JYM00zd0hrNFNha0JVeG9BUDl4c2haZGZEa1ZLUUlZTzgxSVllRXRPWklBYktUSEhncElkbWxvWnFYeE5FQlphTXRLRGxBVE9yc3Nva3FmU1RLc3JSNUhYbkc4SGt0eVhJTjVYV2JuOXM4N1FuNXdhbTN6WDN6cWYyWG1nNmRObEtaeGY4Nmd4eGE5dnN4MDFkTm5kbHY1TXk3emxUMW5GMHkvVUZsNjFLQWQwVGRHWEVnMWVGdTVVSkpDSzhBSzJaQmVNMjRZZ0NwNW5qUWJhNUJtSUp1RGF4TkFoWGZaZ0hFRVVkc2J1VEdGcHRzcFNKYkZTdjVKSTlrQVNHU2RNSGxoS1hMR1RIbHRaK0x3NTl0SDVoRjNvNTBFWllwSFI3ZU5MZUhjdmJRcThxRk02T1ByWHRtenBJaFJIbHhxbUxTRlE1Wk5XVFBUODhEUGZVSFhKNkhkVEZ3WnE0N0Y5SkZWeVpzTU9xSUdUWlFJR2lRYXFneWEwR2xSRGI1a1JmaXBrNEFZTFZNNStDQ1JnTmNjRVV5c2NsbXBDb1NzSUZDQlV1WVZaaGw2eS9rTC9qeXl6VVJVeGsvZ0J3VVBxMHRMRkcya3I0bC9GZDBQY2NEZnNaVC9FeU53NDhaOFdQVjFvUWQraVF6aUhySEZhaWl1dWVubDJTcWNwcGJXV1RUUGduKzRoOFcyYmFQQzVwc3JWcVJLaE5vZ2FyR1J4aHFMUW1JV2oxRHJkRk41VmdNcWQ1czRJdkFoQVFRYWFMTHlRRmF4NDk1LzhQVis5OWJ0MkxsdUdaQ1VhUnZ4cEw1SjBpU2N2cjBpOHJGUTQvL2Z2c0x4WnZ2dloxL1k0VlMwUG1IOS8rb1hIcWE3dE1aTUtldHNFL1RRUmFOVkdlVkRWU0tMRHRvRW1yQzlxWkpvSmdIN1JxWVZUN2RzbGJZc2xacnNBblNBR3paRnZDekNlZ2RZY2xrVDhwQUNuRGJnbm9kQXQ4MEc2d0l6ZzAwVWhRMDJYRXI2OVd0VFBVUGo3WVZLQ2U4emRVdXk0L0tITXlpbGVDSlUwZG05Rjd4MWJ6cEI0Y1A2cnRoMEp0Zkx5ZjgzQy9uS3ljL0hiYnBoYUh0M2o2OGJzMmJ2eTliK3o2L3VaS2tISDJ5ejcwemJyOWRxVlJxTkorT1BmemNoOHI1MW1NcnpnMllWNzEzWWZHMnZXdy9sZ0lOOVlmMTB3RHZERWxSQ2dweTJocmMzN2l4T2JEc2dENkVJc1k3UVdxV0NvY2pVOEo4aWFSWk51M2lGNUlHZFpreGRXZkZEYkN2UGZDY0Z0eHpYTWlGV0VzQlhVYVB6OHZYMUlSenMxeDZ3Rm91cWpVdEtkWVNRYTFKdE1yZXpPT3doZUZhOGdXOTlGWXdIUkJvZzh1bStDc1RrRXdydU5IVWE3TjMxdXYwRnFjckpUTkxvSHBlVmdvcXpNQU41VnhiMENMQXozeDdVREtwMmw1aGJnR29kWm1JU0MyK1dVaG1LeEpUN2pJMW9OOWtzcXN4RzBwK0x2bUNhTDU0L3BlU0RRdC9Wdjd3ODhMS0QxN1pldWhqNWEyUGZYdUllODl1NWR2ZHBIajY5dGFQZmo3dXRTRkRRdU5QVHZKWHpYaHkxeU1qM25oeTBwcTFqMDh0Vzh2blRWNjY3SWt4Q3hjQ0RjMENHcExyYWNpQzJIQkZlWDFUb0tIVWJJc0kyRWl0cDZFTUN6VVprbUNtQnBXR01sQUJzTmxoVmttMnNNVWxwamFoazA1MXFiY1pOUm00NUNJMllTUWhaQ2tvRG5MekN0TUpDb01PQkhTNm5IaVZkdGFzYzhzZnJsd3d0SEM1Y3Y2MTJYOGNNV2pBNWtFekRveFpyRnc2cGRScyt2M2E4bmMvWEw5MnQzQ281UFBadmpFVjUxZWVWc3JmZWFqdjB6M3ZXa3Zjc3VPYjJvUHo1QVBQemQvOURzeHpNeERSY05GTGZRRHRMN1BWd2E0Tmk2b0UxVjNWWk5mSDVDaWE2cHQzN3dacEt2UkFpWXA3Y1JUb0RQaDhJNWVBRXRxTXp6U3B6N1NpbEFDbUZsVWRMUDZHMm9QdEN1MEJyRWJYcU51N2RBY05JbTkzS09XdW01Z09JWGFENFFpM2xKUEZ2dUlGMkF1Y280QzQ5TVMxVk5oZis1M2c0aGVVa00vTGxabktqQTNVUDBGV2lDTkVFNTF6TXRNNFFKVUNaVVBDWGFQenFWT2l1d1ZlMWNLMjJ0N0NOckppNVVyeXhjcVZiTjhkZ3JGSzJWaUZCWG9Dd3gwU25MVm5oWDF5T1NqUGN6WW8yU1YwL2gxZ2M5VklXNmwxOVJpekVNSkpETC9Vbm5LcG5EWHhlRGlGWXFIS2xKS295dytiR1JiTXZyQ0pYWUg1WUVlRFNwVlU1a1NWbmNvbVcxQnd3YzhVdTJ3RTJuSWxJWFBWbUR6TVNGQ05JZ3VmUUx4Q29TcFlLUjQ3RFA1MnplRklsNmtyQmpoSFpSamVQbHBaY21UVGhkM2kzc2VlL2liODBQSmhIY3lueUYxR3NXenVwTEw5bHpZQmZubHV2QkxXam9FOWNSdDNMeGRVTmVCV0l1Y0c2RHI1d2tYc3l1bVRFd0xCTzhFMnpHVTM3dkVGVTBXWVpHK3Fnd1dNbkJOdUJxeEJEOHlpRytpbTNhekJIcURrZWRrMHZkWmdNNElTRUw4VzdBUGY2ZEhOWnQ5aGQwcXRpanFsSWlmMjJvTHBHVERmWnZhcWhNeGJPdEFONVN3Q2JOelNBVGJVUFhmYTdLOGJPRSs2dDFuQWpsOVB0UVV6TWxVTzNRNjFMYmNkMFlIN0N5MUY0QytnWW5oQU5kZTQxQjNHNStaNHMwVU43d0psVElRN1lGaGxaYmNTbThSdHdQRXYvSTNjdmJPYTNIMjI5TllKeFhlT1g1Yis0cjZ5WTMzbWJ1bjMvc01wODNwYkh1d3pkZk16eDVVUFhubFYrZURrTS9lcytJQm9saXcvTnowcm9udys2NGYzTmozV2lRK1VUbnp1ME1LeHozM0F0OWxPdWw5WVBQZHo1VVQ1akhlZTZQRFFQVnYvOE5LWWZjWDNiRmxnVjN5OVd2YnNmL0x3QzhSODVKbm5QbGMrM1B6OHhVTXIrM1M1bzdEc040Ky85UHR2K2srZDkrV1NSNWQ5QW12VGkrTTBQT2dTV3RBbVdyQjlEUG9EVXljME9nN1VpYUFHU2Mzb0M1cW9URURsQWQwUUFkQjB2VUtXNE1naXZmZ0ZxL2dGMnpiWC9yU2xobCtvN0pJcUx3NGswNVZpM3NSL2lqTGlFTWVCdlZ2R1dZQ2FNN2xocXY2WEFKS1Z5cHhNNElxSkhqcFVJZzZWUmJsaUFpZ3NpWDQ1Z1RrQmdIeGxCOG9FSTlCeE50eElUUUE0OUxDRUhyd3dGc21KTnZnb1o5cGxEUUpueS9KNzBLYlhpamJRczVwa3NRVUExVXU5T01RUHZmVDB3R2VIa1lEeTlmZEtOdmx6NWU0RHU1VDJaUFBLcWswcmxidWtzcG1EUzUvZG1EOVFVVjcvdzVMU3A1Nll1WGp1TStObW9Od0VYWDRWNWU4QkxwU0M4M0Jxb3hvQ2NvR01xRm9RekVSMG1aeWdET2c0dlNlUmJTdEdTNnEwUjFLeHE1U0N5aUJmT240UHNhN1pIcGsyWnZqeGVXdnJGaS9oNnRhOGNHekMyQ2VWSDNjZVVyYnY1QSt2Sk5iM25wankyT1RCSTlZcVA3eFVxZnl3YnNUb1NVODk5VGJwQTJ1SmVONEJlRFp4U2R4TktwYk5XaFhMU1FoZE1vWE9ETWcwTXorTEZnQk5vVXExR2RDb1ZWRkhhWjNYVU1SMTVBdmF0dUlCWStTSFRTVDluVWNmZlVmNTh5WWxTTzRwL25MVmZmZXQrckpZQ1VwbEU5NVUvcjV5aGZMcnZva3I3bC81MFpOUC9HRjFmOHJyT1BFMHdHUGtibGVoMFVmWFhBUWRVV0xrUlptbmlRS21Oek9UazVxamVqQkhaWU9mMlo2cVJjaU1UZlk2SkpwcVZ3aVcyZ3ZDNDFMWk1zV3pUREVzamZKWVR2d0l4dFZ6bmRtNDlXUHFKRHFtRHVuTTBQaVk2b0RHeXdZOEpHcHExd3E2MmwrbHNoVUt0elN5U05XamdCNHFnUjY4M0tOY0tJUFNnMUJQRCtHazVBelVHSk53dkp4NGpSRzVXS3FoSnVSSnhYRTlTVEFpS3BFZVVCNURlZ240RkhJZ1dRY0VuZ1FrSktjV3ljbTJvQlgxSFZPYzZ0Z29NZG1BekcyVW9ITDUwdEU3aVhYZHE3OCtOdnFoZ3d2WFhDcWRSNFJYbnZpa3A5S0Q3elZlK2ZpVmw1VHZkbzdnRHk4bDVnK21EUm95dlZmZkRjb1BHMTlSTHF6cDFZazhzaVR5OXRDbkhuK1BKS2c0bGJyVHRleWtjZ2t0NHhLeUZBZ0xCb3BWb1g0bFladUN1U0VicmFoSkFuNkRXbk5OYkEweENJQ1dJaUMxUW1oZlVWSDd0bFFXbWNQUHVEaUNMNDVNWjNnOUNXL1RhU3dnSzI0TlZZczhLTURUOENYRm5uaXlBdjF0N0c4NzFaMFZxdUZ2RTdoOFZRT0RwYWUrTmFvN2FJOEhEZkMzcUNVRWRXQzhCamxTcFBwVmtWSER3NXhhalRlejA1UnVLOFk5VTFZNVo5cGJ5cGMxajR3ZVh2VVNhQVcvK1dYT0UxRjhMS0w0YUgwWlBzUkFReVRRYVZOZE9palFkVU53MGZIbzFSTkVRT0ZIa2RYOHJQY2pKNVVqVWxudFpxRi9aRUh0U1g2SGNraVpxZEx5VWhoSGluSm5hbWN4WEdpaXVBZ0psSG9GQ2FoSVc0OWtGenc5RjlCU3V5SzJMelI1bEQvY3FzS3NpWVBaVEo5bUFyWnJZcEVGVkJrc3lDTk1BRG92b2hIRFpxRlRaNkVudUlwZ0dOZ09WZklHM2xCWkVmbEZGL2taWnZHRGtIQnhoRGd2d3ZIS3BXblJzYVVTdWlmdmFHUnNkU3ZDMkhwclVNQ3hEVFUwWXFGblBqK1FRWlE5WFE0QlFUcUM0VmNLSmVXemFvZEtaWmZtaUVCRzRxcExvNEFmd3Q3VTNBcDcwd20yU1ZjdVpPVVlHMlM3TXhPSjFVdkhkY0dXZERFNWd3cDREbTVOMUxTdEVzNDVFeFNqb0lHN1FoVVE2QVlyaEUyWG1ZT09sNXhNa1M4ZHQ0ZTQxbThnanQxanU4NE9ubmwydlhMMmpiR2JGeE9SM0VyNFJVdVVXbVd2b2l6RURXYzVOTzNKOTVVTHk1LzRmR2RwenljUEVjdnlDdVhDaG5KaXFhd2dsZzNseWdYR3o4VmF1bDZ1NklveFRnWUdSZGhvcG52T2lKekZ6WllPMmJvZlZ3OUlHKzBxWkRLZzJDRm5sNktjbmVvd1dVbWtYaEFtL2t4eUJxeDUvM0dsa2d3Tm5maERVRmtobGYxeWJOTDJ4em9vR243QmEwdFdiT1FvTG85cCtnSXUzVnhUcmg4WHNsTXJMNHJMWE1SbE13cUVCM0Rwc1ZJUmpiaEVkM1cyQnpSTHlXcW4vbW1EVFU0QXBLYUFCU3hiMEhpck1wZzVhN3h3cE5qVm9MTVR6UmVHNFlDL3NFbWgxTzVLTEQvUVorL0UzVzhwa1JpaU4rNTlRZmxsSE5IUGFBelpKYjhPTForMnRTeUc3bkYvbVhaK3c0a293cW5lalhRNlh0VlZIbFFwMWNBb05lZ0J0SnNUS05xcER5aVJSUzBBN1FuK1dPQUMwSjZraGlpQ0p0anZzc1pHOWVzRU0xVllaSTh0cXFGa01nMEY5aytEOVJoRmRJc24vQ2xJZHI2ckRGRkdrdXJLdzIrOXFuU1R5aFpQa0xjZXo0enM0RnRHanZKN041USt0NUw1WVpqOW5jY041R2pvSlNpQy9ISHduQ3AwbXZwazYvRmdLc0NZeW5ZMUdOcW9LUWRUcmN5THByVnRGMDJPcEt4Y3FpUGJnMjRQRW4wUzhNWHRITEc2UFY3VjJjS1lZOXRXSksrVlVOQ1d5UjFVYVYwWWIwSWJXL1JtamgvKytEZExGc3UzdkxUczJXM1RieUxHRDFiLzdkRkJlNytjdDduaksydC8vRkk1OTdIeStrZFRSdytkUDZIYlF6MHpVcnNPS3g3d3U4LzdEWml4ZHU2STJ3ZmRrMTJ3NzZYWFA4YzVEUWU2UHdScm9PVnU1a0thZU4rRUxQaXBTYWs1anZRZGtqVFVNd2hDTzZTaC9rSU5PZ25yclREMFN3OFhSeXJwdjVYRUZTc3Uxa29pNVVYaHVocHBFRHpmeGhWeW9RVEVtVWJscWJEVXFsTWUyYW9zV1BGaDFBK0JhNHYrSjZSZWVEZ0tDYmNxTGF4Y1ZpWVhyamh6NVAxdktwUTl5dmZLZVdVMzMxKzR0ZmE5TTdVL2ZnTS8zMWNPSzlYa05qcDJyN3BmSkpuNlhiTFV1WEU4VmJucjNTNmNodkk4R0FVNUxQSDJDaE9GNTdaRlZpMEcvdFpTUEhweElEeG5ZTjB2dWxsU09mQ0c1c3lqTE9zQzlGRkJRUk9nM0J4NU56ek1SSVBYQnVZb3dBZlNaNEwwR1NpVE1qS3ZtTXdqWlZzVWJwNHlWWGtjR1BTbGZ1SzJTNzNGTFJjSGlxV1hwcWorZTlnVEU2bXN5MVYzQkl6Rk05bVBzbzVKT0I0NXMyaWduSmtOUTBYY0lENHZjbTR2cVNiYmQwZk84WG43bFFLbEhmOHAveVlRY3ZkSWw0aVhIeFZaQldNVXdoZ1lCOUtoUE5VMndJdWVpbXpjV0FiY1lGb1dCUUp5YUlBbVdPckN0OGxYNU52ZGthMlZvRThFK01PMTZ5UHY4b1ZzRHZQZytSb3FmMXFwY2xRcnFGNFpnU21ETElkQXk1ekxzSXRzcWlsUndEeTJXYTU1d29iYW1lS2cya0ZDeFhoeHpZdmpMdzFmd3A2OVgvbEZNRkI2YmNPcHFxWllnKzRCU2F4UlBTQkJ5UWprU3FXMEJOb2xqYTh3TWxVVnpQMzhuVW9QRWxaKzBWUk92OWdibFNCUzk1TnlVV3l2eGhWZ3pVeExoQjFMTkVNeHFFQzRhY292L0lIb21Hd2FNQ2FRRUtlT1NZNWpFRFZFNkJZaE9LWVFIZE9UUlZYRXJHbGtoOUlkVm1ISEltbmI5SDhNNUZnODdvSXdIZWhLQXhwdExCNW5RTCtLL3pMSG9NUmN4c1JySk1XazQxT2tZK21GQzhJRnNsWHBTOW9yYnlQOHRVcTErRkZkRWNEdjRkQXZBNkF4OE5CbFFpSFJ3dVJGOGRpbC9IZG5jWVRraVFmNEJkSlorSDRtZmgvOVNaYjZLQXh2NFV5eDhBc3BkSGhKWHVWYk02VU5QUlQwTVF5cHF4RkZNY0NsQUNkOGpIa2hXVmcxUTZ3SkpSQm1lNFNGSm9rSlpvb3F5aGxoWFVBSFI4N29Rb21aN2ZjSG5RYVZQU0kxRzAzQXYxMjI3WUkrSVRHRHVlQUU5SjlJYnJpdlI3NHVKN0RnQTQwd2UxUm5OUHBPZ0xmYnZBVWFqTTR3RDF3SGd0eHl5TjgvM0xUdXR5dldiR285TkRUK3oxTW1yRjE0YnFROFpVUFpvOHMrV0wzMnhkK1N3azNobGxrdkxPMHhxMlhMS1JNT1JxYVZiNzl6ellRaGt6YytQYlRsRkNxZlpKam5LZWtFNXdDZFpwQ3FFMWlqNFJUMHZBVXpOSENSUVNtTllFQ1A2VGdPbUJmdjlQdGxCMU4wMEk2bWlvNkRDbWZxck9hQ0dhRHJoSXgyb1NpcXA3Wmpma1gwZStTNWVCWmxvck8wRUxsOC9TOTNMMzEyNkUzOUZtNS8rQjlyTlozSHp1KysvdGpKTmQzbmo1Vk9SS1orNXhzMHUycmtNMGZuOS9qeklYNU1lTTJvV3o3ZjgvcFh0NHdCR3B0WWQwYnNJQlp4eVdoRGV4QjRHKzVGQk42SWJ0R1VxRnhGU0xtZzBRWTJ0SmJUT1p5cW1oRG5NR2ZPbDBJUFJ2WmJrWWtMTHE1ODRXQ2Y0YmV2R2I3eGs5TXZ2YkpzVlA4UFhsaDVjUUZ2WGFhc0hONS9iUGZlNTdkdC9kdjZJY1BHZ0FuSGM1TUJseHNvTHJNUWwwYkVKVFVYUEkzZ1VvZTRaSEU2SjRnR0o4dW8wYVlDelJnTUxGaG5kQ0l1TFI0Vmx4NTArR3ROVVJjdHVvdFFYYVZFSVZDaVFOc2FxV0p5djBYYmgxeGNVMTYrNFdlSzBZMG4xd0lXTzMremV2MXgzajdqVC9ON25PWm5YbXgyN0N5aTlKRWRnTVIxQTRKbnZxRDBnTGpzRDdqMGNPbGNMeTdrUlBBdEdoV2JxVkpOT05Ib1JIOXpvaGh6VGhpcFp3V21DL1BpakRBdjVxb3dvc1ppdFJXaEt5VVdaNlNPWmZTaVo2SDhaM2dHbFN5TDRuN2k3SnJGcS83eUdGOWJiZnZUNG4wTGgvYjd3OElsNXhldDU3ZFlYbHRlc28rM3Jvb3NXMVc3TGoycFl1L3kvZytQbU1mVm5TNTcveUNzL3dBQS9LVDBCV2kxOXpPSXFjZ05CQk9rR3BuNFVhQm9OY0RMckxJZVBUNEdEZE53blRRcURYUXNXL3doaDVPR0IyMTZqSm1IbkRSQzZFVGg3MUdGZjZDZ2JTRnVTUmZnTjQwd1ZXREFpd043THhuZWZjak4xYVNYRWxvbnJKbzNNRHl3ZC9MOGxOUDlTbXBIQ2FzUW41T1ZzTGdCOEpuS05lUEdjU0Vkb0pHUlFoNkFaUEVGSFFCamtpK1lpVUExcDF3MkRhZ2hqZWxXN2h5Z0Jzd1V5Q2NZcTR6aUUxUXN5ZUpJeXN5amRKSGtVTzhIOHdEaklhTDFVQXF4STRWa2VncW85Wm1WbVZmSW1BYmxJQTVLTEdwd2MzTGZGMEtEdWJyMTVTVUxsWXZLVDhmdWVPT3pxZzlmL3NlUVVPbmRINjk4SkRqeDIzVnIva1NPZi9ubU05Mk92Vm03L0c4bEM1ZE5mLzdBamhsZjNQNE04YTA5L01EdlJxODcrQTZUV3pMb1dUMkIvbTNjM2FwYzE3T3N0S0FGTjRDbG5vY3dsY2hHWTRnWW9rWkJqUE5FcmNoZ284S0FDMXFpNFNLVmNTQUh0R0dNeFdXVHk1ODV1K2RrK1JybGJCWHdocVZIdnQwWG1jaVBXZjVLOWJKSUJkTzd3d0RRS0ttYSt0YWJxOUZtQklWNjJmVk1wSW5IWlM0V3lZeHFlUUdYQU1PRncxdktKY08yYlJkL0ViMlhUbkY4M2E5S2lEN1BETE1EeTFtRGp6TDZncnhFVnpFQm4yaW5ZUVNMUDZpREoxcHA1Z1dLcEtoYWh3bEJlZmg4WFpObU4zVXVMNW5lcnNYdThBSE43YmVMZ3k1dGVINmVRZE56MjdaNlBBNlVXSDVEekJlQUd6RG1DRERVT3dMRVJod0JSQXNZNHR1L3JYUWhoM1lyeFNla0U1ZCs1ZnNxUlpGS2N1NFQ1U3lPc1JmZWNBd0JLSk9PRVhPRndETGdxOTRWc3JkY09uR3hHWU5MOHd2UWNqWTNTdFY1Yk1rQnNHV1FwakdnQW1wYzBDM1V5T24rcUpUSVppdWNiVVduWURBWlBpV3o4QUVzUFJVWEtkazB4VkpPcHNMUGJwZk5zUEJ1T2lXak9pVlhSd0haY3owQklKZW1GOW1VRXRMYTl4bmJlZm9ycmVhZGZmMlA1WXRuejlpOGRvbXlXZlNHV25TK0pYUHlrS05mdngyWnhJOVovYks4S2xMT1QxejI4cDRsa2Nvb3JjSmNiRkZmSXRJcWllMU9pMUR6VDFDcDY2cFVLbnAzWGs2a2pOZnVCUmdTUU11STVuRTRvcElyU2NNQ011amlNMU1YSCtaaDZxSUpBcGlNWnFJK0ZMci9vL3dWRFY2YXV5Zldhd3BzbTA5Y3lOV3RYYU1zV0ZUSHJWMFRlV0hqbnpmOTdyTy9iUHJkSjd4MWVXVGxpc2dLa0dqdy9zcjVjNjl1dmZBRDIwTXk2RnVuQUQ3VURmcHg5V3BCUFpwQW5zR0cray9vQkE2R3RKaE9ZTHRoblVDcGxzWWVpMU1LSXQ4TG9UaXRnUEhlYXNwN1VSNzM0K3BGc2E0Qi9FYmZmMTRPRjZEajZwK1J3NGN1THVmVHJwVERsRDU1UlN3QTJtZ1Q5ZFFnMUZxcTFHQk9ralVXMVFCT1FIMlB4Z2I4c3JDZHh4OXdlZGtlNlRCcGRMSEJZTnB4VHZRcTM4M3YzWU5zcWZ0R0dZRGo5Szg3SzVUQU9HMjVYN2lRbi9vRHBacVFCNGRKd3dCN0FRcktZS2F4UnM2MDBxdzVIOHVaeEx5TGMvZTlOUVB6TGl5eXhTb2I5Z1diR1A4aE45c0hINnFNRm9NanY4cEUzODM0TGpleFZ1VTJhUVlmOCtoN1Uzd1B3WjNNK1puenZSb1FYRVZ5WHBIY3RDZ0VYOGNQcGlMMGNuUTJtUElNUnJPbFNXN1RadldadTZUeDJ6UzlJOVBKM0JBYVc1WGdTZk9qRThKbkR5YW40RTVKQXhzc3pCRm5pZzl2ZTJ4eWNsemFSeXNocjVXR3BUSEdIQkdpSjEzREVqbjc5OXErNitHbjBsdmMzZG5mc3JCMzIxdXlQSWZLaHh6cWZjZjZzb2NldGJmTTdkbXlkZk9iNzI1N1U1YjcrRzhmKzY1a1VzbWduaGtCYjdiTFlyWmxwUHZhM3RHc1pIUEhkbE5IOU8rVzJNeWJtR1pKTURrek0zMEYzWm90M2RJSDFxQnYzVG4rbURTVWMzTDkxVjFtVkhjWkdNUmd2b1B1QWh6VjVaTWRMSkhPd0NJTWptZ2luV3dHQllibTBqbFFaWEZUWXJBeWh4aW41dUlVQk5UTU9pZW9YUzRhY2JUMVhWb09pb3NjdXVldSs4WTgvMXRoVlNucHBPd3ZqU3lYbTVTMGZIRTFQeFBwWXdQb3RPMUZMMmRIUG1tT1dRZWFLSURvNEhCRUJRYzZPRUFvWWRxaENmYU9FK1BEYVBkYTBkR3FvUUJkNXV1ZzJtdnVoblZscGZPMnIxa3p1MmJQeDJRSi8ySmsrZkl0TzVmeWd5NmRxajd5TFpPSmQ5VDlLbzRCT09MOEhPUTZmbzQ3dHBIaFpPVHZsTFl2aU43YUpjTEVTOGZnVC9yVi9hcFpJT1p4Sm01bW5KOERNK2VKb05IbWVHS09hMklCNVpHUnZKWTVycEhrRDdRNG0wSlRqVGlyYk5wbmdXL0kvTDVkdC95SjNiWElHcXNzN1pOUTE5VHRFemhRRHpEL2lKZDBwbWpHT1hXZzBJQm5BK2RKdjgzRVRkTG1rQXppcmxSZW1LLzhSVGxkQ2xCdkUvclZiaEY2WHpvbWRLbmR3L3c5SUxmdW9Ia004YjRUY21PK2sxNWtnL0pvbU53TSswT1pTQ3BlVjNZcU8vZ1VYcWVNSUdXUjJzaHBJaXU5WUl4dVNraWNCR05ZTWQ2aG9oblRFY3dva213K0ZPQmMwTXdDdDBCZ1FkNFljd1lSVk9pWnJsblliUnVaUmZwdVZycDArZTFUajQ4djZEN3dqbUd0WUU0TGhNbVhkbFhNSzVpUjEzOGlXOXZKTUNjZGpCZm5TNUZVS1NoSU4rWkxtY3p2alF3UVprUTY4L3VHQ3pjWFAxTDdickg2Yk9VTFlUem9iUUd1QnlmbitUQVpJRWRrV3FCWUl5ZjR3aFkxWmJ5dFQyNTVYSmI4bE5jNS9jRUNTbEs1Z01lMGxrVTBweTBacmZPZ3psUEU5aE1WVWdWdE93cGd4WUQ0b3I1WEtucUJjUWhnVFlyQVRGQU1UQzRvSHMrN2JoNjJibnpTdUdlNk9QaHhvOGVQNGswNXR6OTJmOUw0ZGNOdWR2SGppM25MOUdrejdOTVR1ajR5cE52TnpsR3BOL1h1MzhNNTBUMjlPQ3RuOW5UM284NWI3cjdUNzNPUGR0N2NiY2lJcmduVDdUT2VwSFA3U2JsSXBsRi9UaG9YeXkwMWNxMHd0NVQraUthcXdrYjdxVGlhUUFyMk11QUVkZGsyaUpNMnZqREhjSkxyQzNvQkoyNWYyS1BpeEIvVmFGc0FUdEw4d1FEaUpCZHBTOWVpQ0RNZ1VHbHoyNE9XTk1TSnA2TkFNZEt1a09hRFk1ZzNyekJkcEJoeHR5Y3VabDNUSk1xSjQyT1ljTnc2YzN6eStQSmhSVzUrN0hNRkJjK041WE1HaDU2dlRpMUVIRHdheGNGRVo0Lyt2VzlLSFFVb0dFeFI4TXlUMDU5RWxOMzMxTmk3a21CT0s4alhRb0EvQzdLK2tFTm5wVVpUVTJYVm1IWG92d1FTY2xMa0dGZ1JqZ3VuWVRYVFpFWDRkWFEvVWpjQWpaNVRxeFR6UGxka1BORGR0ejg3cjBYaW9JeitkN1o1S3pNdlA1SG5wZ3p2MjZKOUNuMXZyTTRvbHRtS3JpNmFZSFI1blpHdVlaMFJKNnIwVEsyUEFrZkE0YXJlODRidmdUYmlnUk1uTG5XWUlpeXFuVFFGeHBsYTk1UFlWZG9FcTkyRW1Ga2RrSndVQ0dsNGFpR0UzZFpralpuV2xiZzFhSkdIUlMrOWtVMnJnV2o2Wmk1bGJlbkFxZE5wWG5BNGlkSUoxdjRBb3d0ckdkWGtNVjdYOGE4L2RZNVc4a2pKR2tmK3JvNS8rSEVuM0RGaW1ZMHVDYXQ2elBndVZWbm9oMFI4ci84U0xkYUJQNnZLd25lcEtodC9oT0JXbk16UEFvR2ZwTVVyWFJGWHBUT25aRkVCLzdxa00xc1NVN0t5RzhoMkRVYk9yRzRVNVY1TWlqUndScnNqNXNOcFR3b0RXbHE5SXNSY09IbGFieUZHZk53ZUJ5em4xSVdYVmlSbkZEZFovTXlJa1VQWFdkSkNTNGZkZjZTMGliMUpjY3VONzI1NGRuU1pmc01uL0FsUWhEZFY1eFdQSFpOUmU0b3ZIemhzSEwvNzVNMGtOZnpzNGRaQzB0OVUzNjhvUzl0Z0hhYXAvQ29GeENGTFdXTjFLbGpnRTdScmE4S2l4QmxoQ1ZoQmxwd0VTNUR1ay9uanNzWlBhekhjL2xBS2o0STdKUTBUQlZLUzlQa2hQZ1Z2OENESk1jNmRnUVNTUWxqVTBpNnB5VmJJK2dwQmVLcGVDZFY1cGRVd3owU1dhOTdXclZ0blRUKzQ4c043WjNSWk5QcXBlL3J6N1NOdjh5Y0c1Wk9qQ3o3L2J0YjB4MGNQN2R1dngzM0J6eGNvZ1VXTVQ5YWRrZnBMSWJBNFozR2g1amduTDh6SnhET1RCTFNtNWlhWVIxb0FIYTV5aGorczA5SWJpWUdnRG5rR3ExY1NhWVZKS0VXa1U4cUFHWGo4SVpIT1I4VDVhUDIwN0NZRmcrVDZscmlPbkJjdWMvT0tpb0lPblpyeVRMY0JzSkZDbUY0N3J0NHpoNzVkWUNBZStFRmpSMnlGdWJ6Sm15VDlsbjIza0ZZSHQveDF3UFRlcnp3OTk2UFd2Q1Z5UWlmeUxTUG5XbjIrWXZMdmVrMFpkS2JpaFBKK0lmbDZWck9PWGRyT1BFWHNMODd0UDNuY3Z2S1pMZTVxY3V1c2w5OStZa3J2aGV1STV3eW54ZzY2d1g1MmM0OHpxeUVhT3doYmJSYk9qS1ppMEFxek52ckRUaGU5QVdxYVUyUnFtc2NuVzQ3TGRyRE9ZWmZwL0tqUHd2VE5SajNtS29Zc1p2eGtzY0lua0RHSnFDQlpvdkVIVndQMUJhWkovL01XWkxIL0N2ZVRnK1NEblpHZnlSUmxJS2xVQnE1aFA4aGpVbG1rQzc4bm9wa1pubm51SEx3aFQxcFIxNTM0cE83VS80SFNJWm8zQ1haMURWSWYvSWg2NzBFNm9NdGp4ZXJWcTNmd25BTFNBTjlwbmNGWmNSSFFlU3V1STFKRkpsSkZycVJXRlZsUU1uZWkrZlUyYzAyVnp5WUJyK1dNTkU0Qk5nTGF5K2ozVG9QZkZhWTFnOTk1WU1UT2FQb0RFWWVFbkphWWt0TE05cnBGNTh6TWJkSDJGbFRKMCt3aGx5bVpGaHRaUVBLK0xobE5hZDRjK3J0WUdtNjhndTcyc0RvMStrNHpWVlY3TjQvYXZwN29KL3oyekJlZlh2bmhLNlUvUERCeTR4OUhqWG54amUvZVhEcjk5bnZwblJFYmpvNGN0M3puWC9ldG1yVnh4ckNoTTJadmZPN0JvVFA0MHc4KzVicDc3dlRsSXg4Y1ZuNVg1L2IzdGJ4cHpyZ0JUN204NDd2Z3ZhSHJlblM2K2Y3OG01NTdzbDIvdk15K0hkcmRsNWZWbDluTjU4VURnbFVxcHJndm9GVXlZZ0NERDVtMElsUzlpZ1p5QkF0Vm0wVTFlYXJlRFlXWnJPZXI1V3J4d0Z2d0QvUGV4dGVkMFJUQ0hyV0JEbHpFdmNCb00reW02WTBzQ3pLZFhvY0xXMXNrTS95Z3pDamNKSjkrYXFJSzladXBLTFN6L0VjN0RhMkhXN0treDVaTUtPaFowbU43ZE5tMHhGUnBVWEpiMHBzMGJWdElEZUQ4MW5oUGIrZVNtMlkzQzdTdGo3Vm54dks4c25QVU1EdkxaUEJtaTd3VVhUblZ4eDRWcytNZmY0YzRpWjg0ZmovNThYZVVzNnMvVUY1NXE4dHJwR0QzSGxJb3Y2WWMycjFIT1NpVGxxY3FoNVIwN2pIMkwyWHJKblY1cEtqN2J4WThYUEVwZjNnNXNiMDM5WWwzbGIrdFhLNzg3ZURVOThoOWIxY3JoN1pYazV0MlZaT0M3ZFhLZTFzcXZ1NTBTKytSVzZaTjNSSm9lMGVYcnQ4QUhxZnl2ZmhTYVFOY1lYU25sQXZaRVhkbWxpYksrVlFtTGlmN3dobnNYaE5mV0V1dmFKUkhRcmRoT0pXaExKV2xYdW16L2Y2d20rR05obnNrbFp1Qm1WbWxOZHRaTVdGR010ejFZTENuaVMwa1NvbTRCYlEwaW0vR05BWVdaT2JpUXorcVF3bXRwTHk0c005VTNobTVVRHJwM2o1OWUvUWNtakY1eEJQUERlOCsvWUhFdTI3cVB2cWV1MjhaeFBjYU1vVDBDdzkzRzdyMWFOa3Y4T1FUU25uUEFidGJ0K3ZWcVkybmtOSG9VSzZ2Y0U0NEF2YVVtV1lwZS9SRXEvNFlTbnBNVTc0anJta3pTSStwZURHVk45aEl1S3N5VDVuYmpleUlYVks1c1FPV0czT1lKYTUxTklNNVdna202bGxPRWRiMkdFR2ZGNkp5UU0wcHdtb3ZyMjJISUs4V0pxK09YQ1RqdWY5VURaYllZSCswaGgyeS9lbzd4TmVHN2drZkU5ZStOZ2lhTHh1NGNndC8yRnRFZitlOXhuNXB6UmEvalY5dWJVVkxJZHlVM1doNnhRWXFnTTJ5Zys2ZlZ2bkk0cHJhNUpaRmNySmRiZ0gwME1ZSFdveWVTODZuR2NKRk5ybnBEVzBsRXN0R2RYZ0ZieEtKMWdMZDJGYWFTZm91NmRWeDdJQ3pMM3l4OStTOXd4NjY5NHNiMlVlUnIvaGZlN1VmK01Ba2wvSWh5VkJPa3puZGI3M2xkbVpqN1JZUEMxMmxmdlZycHFuQlYveWFhUnVzMlc3K2VmSHd2SGxJaDB1RmdPQUJuUlkwWmU1ZWp1YWloKzFzLytsOHVDZnBHcWpxTzBPeXdZcGxSMkdKZnFLUjFnU0R6VjRsYUhVODNXVjJNNFpVb3c1UldvcExTMUVwbHJJMVN3OG9CK0QvcVZPMlRvSC94WWt6ZHUxKzl1azM5anpWKzZtbjc0TVh3TFNJU3hNWGlmMW9yY0JnamhyVlFzME5GVHRhWThXT2hzdUtIVEhJVkYvdmlCVlV0aXRLSGpISmZ4R1J5MGxJNlZtdTlCVis1Y2NzSS8yVnpjdVV6YVIvcEdyUkl0aGxIQkk2dFRVMGdETVRRRGhBclpiUU1scG1oVnNxM3FpVE1Dd3kyaFd0Nk1WQTB4Q0pFM082TEppVkkybDFCcE9aWXM0QW12aDJqYWczV2hJb1YyK0QzUlgweEpHbGwyd2lWenVjREZZMjNzcnZVQ3FWVFdRQUdhaDhRUVpqbHVUYnZJN1hYVnJFRy9uZlIzN2hEWkd5eUsraTlkOEtWa0ltaXdmNGs5RmNBZTdhdVFJT2o1Wk1mcXZ5akhpQU5PdHhTbzNaS05WaWY5RUxWTnpRVDZhSitjbW9vOXdaZFpSalNNSFJ3RnRHclZKQ3E5UHNSWTM2eWZKc2N2bW1PZk4zbHBkUHI5azBGQjNna2VXbDFYdGZwSTZ5RDBxVjM3QzZTS0UvemEwcFZQMWtBaDhMSElWRlZoWU0yTVVFZU9UTjFqREg3bkhSS2xsSDI1ejJtUDJDNlloRFNmNkZrNVh1eWpwdWxYRHF3NzlkSE1HblBYS1l6cmVjMUpJQi9GSEFWNnNvdnNEVXZZRkNWd2N0ZENXMXREQ0hrSUJ5Z0IvRk9lTnpOTXdOOEc2Si9hWGtDQWdrc1BQcE5iOFNrL0xhdnhWOUNkeFEwRGwyUzVXVXB5UmpkZ0RsZEVtTTA1bWluRTdXKzhJT0ZWNmF0WUJWU1ZiRzlsZ0VLS3hobnl4K0dtS2hjU0M5RUlzRE5leFBnRG94clI2S3hvR3lOVU8zelhyMkZYeHArSjVLeW9UZWZjWk0yRFJhblB4TVZXZ212SlNCUTRidzNuN1RwdmEvLzhtcFZFK1l4dlVWeGFpZVVLZ25oY1JGbXJBZjA0aFRPVHVWM0tWc0ovY1FsL0xkTk5KRENhOGlUNUpwM1pRZU5xVjcxL3BManZaNCtQOTUxLy9yc0lMZVdYZE9OQUdzV0ljMlNxM3V4TW9kN093UlRsUzVSMm9zLzloa1JTTTVXcEttb1NWcFdpYjRNUXlxU2FSUldGbHJDeWF3MmpOYXk4QUZFeE5vOVpuTkhuVVA4WjFJd0tHMWtMajhubHdDckdnb0ZwNDVSbVhSd3JPUEtrWU4vbnJOa1ZxeVlqY3BlV2dGMXA0cGdMYzFjeWV0M2pmOHNlbGZDK2RQWU1TYzFqaHBiNlUxVHBaclZqa2wrSUxXcTFRNTZUSGw3UEpLSitVa3BxREZsVHZ4Q1ppTzlsODFKaEZBZEYwK1p2dTNLcitOSHhJVVNDclZvbU5tMERGdDF4elQ3cVBaRG8zUDB4RndlUE91R0ZiNTZ1UUxKMHZLeWhvTW5VL015by96NThmR05zRFlLVnc2ZCtmbFk2ZEd4NVlUZlJndHE3SVlnVFNDTGczTlNtSUpTQ1FWZ0VuSGhEczVwVWkycUsyY29vQTE0dTBWR3BTZWZaVXhvSHViL1psNUxSS0h4SzRHeEplamFiSW1EKytkWDVROGVmaTkrVVcxR3F4TkV4bmNtay9WZGJKSGQySWpXSk9OV0tHSVJham9GN0Q2YVJ6TmVEeG9zZEN1TlZoWmI3ZXdJRm9DSnZidzJNQ2o2Q280VnYwRlZ5RDVRclZjM1hCeHFUTkJ4YS9tUEVEb0FzbjdnQXFsSllEeEhRZm1jTlNidkZsb3dxbkdyZXltcVJ6UnVraE15MDl4dzFiVG1sMkVzb3Qwa0VMYlJZT1p1RmlGV29EVU40ZkIzSFNWRGxWdEhMRGVpNThTNlBqc2ZmMW1kZ3p3VStvaG45RmpSSSs3MmhaMGx5YWxETDY1ejVOUDNYZlRReWtYRjhXbWNYT2dlNCtDUVBlN3FJenljcHoyTkszUGNXQ09QWTNxY1lFR3hXR3kzUisyV0UySWVvdUFwV0ttV0trWXFHU200N0xOSDZ2Y01sMVpMZVppeVRDa3Zsb01YZ0lCcGQwcmRCZkgxTzdpL3hweEM3MXF6Wkc5WDVBMjVMdy9Wa0dtUXF6UTJpN2xBSzMxeThKcXVsaXRYenBOVFlvVi9HWEhDdjY4VnkvNEU2OG8rTE1RclpCWG1CdXQrZHRCaENjbU5DejZlMXg1cGFTc3ZFcjVlcjFhOWpmNTBhbnhaWCtqbjVpcFZUNjc3UnZQSWRJNVZyc2duZ2FlZ3pyTGRTdnVyTmVydUxOZFVYR0hIREN1NnE3MlBESy9LT0kwdjFETzl5K0JBN2hpSEJ5Um1RZUFJOGJnU0ZLVi9DZ2NUUUFPKy9YaGNGd1BEbWNqY0ZCT0dZK1NneWRMVDVhc0xvdUh4cVQ4aEtZenE0TVZUd092TVZMS0gzOXRpTkFDc0FiQ1pzWnViUDZvTFhKMUNMRjJ5a1M1VHcyV3pWcHBGVXBOZEMvRXc2MXluM2pBVCt3RXhsTVBOWE5oQWc1RnJNT0R0VVRmYUY0MEw0OWFLRFFoajhiYXNVWkNpekVDZ1ZkYkZqbTg2S0VXSzk5NnhsRkJDZU1mWjJoNUhvOTFmWHl2K3VmRlZmYnBZcFY5ZXJYWkUyQ0VQZzlUSVZBU25xeDRrYTcweFJIUlJlWkJlK0w0N3JER0d1RGZ6ZFRLQVZicFo0eFYraUZTVUMwQ2xpekZtdmpoeXFISlptSmlyWHRGZEtsVVVLbTNrZVBidzNvaHJFYXVTOXpzMGJtZ2kvbUk5ZjVvb2wrOGM5aU1LYXkwUTQ3UlVoTnJtQlJ3NGFENE02VmFVNkdyUmxTekVmR0s3WitKb0h6L0JQd1Ird1dOVkN0VWJNQjVhT0YvR2xBSjRSSUVjNzZjeWR3Ym1MNEhYQ2lCT2pLd2VVYWFQMlJMUVBLd1plcnpRd2sydkV4QUw0Wk5kWDVHbVJVdHB0TkhBK1R4aGI5Wk5rZDk2UytTemNUVjVFSmMvYStsZ3ZTS0ZRRExaSnZTbXk5WnhzK3Nyd1BtUzVTRWFDa3dFRldzdHFvRWRBUTlsOFpOdnFJS1VFNm1mcHNxcXprWm93K29HYVEzVmhhWVVWOFdLQXUyb01HSk5WYVhGUWRpc2xBYWRkc1ppb0ptSysyREZsOHcySmcyRVMwaW5OU0lIaEZmV05oQWphRDdtdFlaQWsxam5XRXVjcHBHS2czekdxczBiS3BXR2xaWkpTOHJML2lQRkJzaU83Nnhna1BDVng2WWVVTlZoMEt4cXIvK1Q4MEp0dmtOemtrQlhuQkRjK0kzVTJZUm5WTVRPcWRtVjVsVDg4Ym1sQjgzcDl4L1lrNlUyZHpndEZ3b1FjcFczK2pNbUhTSnpzMUE1OWFPRzlISTNPU0FMNWdMKzZ0WmJnRDJWMnZjWDRXTlRmYW11TW0yYkRqWllHdnNPTmdPNDRDeTkwYW0zdGcrdXpFOC9DVmpnSnEvTVNSMmRXTTRrUjhmaHR2ejhXRnNlNElFbzdnQlBzNW91VG4zVkdQWThmcmt2RUE0aDNIMHB2NW9jeDRWT1poV21ndVh1VmJNdGdnMmg4dm05U2pEbGoyNUdCbFB6QVRlazJlamxjTnljM3N3SStrL1drRWNsYzAzU0MzZWFubm5EWktLS3RKQnI2M2c5b3ZUeExVZzB6Z0htTFY2R2tYU2t3b3lSNWt4aXN3aGMwWXJNK2diL01qSHoyT1ZKOG56WS9IekdGS3NURWYrTUIxdzJsdnRZZGtDNlkxS2Nsck1rNnRselo5a1V3QjdlOUNtVDVocFlLRzlMTEVpMkdaaGpaMHdzUURUdEpyYlh0Y2JMWjRra3A2RGdSVWIxbFFCMmpDa1RFU0xMY21ZMW9KcTA1N0NYQkJKaU1GTUR5YVBNQ1JtZ2lCM2VqRE9CZ1RuWm9HWHZPbUhCanhNVVVnMGI4emNBaDhvRmhWbDcwekxMTUc4OVAyTmdMMlRTdzl1QkdUT01weDZoSWhMS0JKWHpqdjFpRks3aEtKeFJRbC80dE5Lb2UrTTljb1BrWklaNjBsQzVhZVZ0RllCNjBlMWhXQmp1N0QzMFpVVnBPN0dLa2c5YWdWcEtNSHVaRnJJbFZXa3lOSXZxeVFsTi84V2VIY2o1YVRTM3J1b3d2M2ZDZyt3NDhzcld3M0lkeHVCUi95U05MdnI4M3A0TWdDZXhNYmhTV29NbnVSNmVGeFhoNGV5MHN0UlZQQUo0NW1OUWZVWDFVVUJORXZoMGh5amVFcmlCbDhKR1ZZUXVBTmhoNTV6aVpnTEUyMllva0tLaFJBcVA4RGMvaVFMYmNJY2hSOHJKdHpZTmtDVGNEWG8xYjE5T2ZoZGNSTTNDdnNCK01kMFFsb2ZDMnVzQTQyMzdlVVZzdVpZaGF4RnJaQU44WG9UOVQ1Y1dTV2JRanphK2twWnoxdVZaK0tyWllVVGJCVzV1UDREV0F0L1Y1eXVIaXVDQjFWVThOUzMvb2pWd3dmNUJIK3NJbDdMS3VMVlRqMWF0Zktpc1ZZRUZlU0p4bm9SL1AxUGs3WS8za0ZSeUFvWm14RVFUcTZyRldkS1h3TXZmNGg1Sk5GNzRCWnJRQXZHdEsyb1lwSnJvUHc2ZzhFUXl0Q2lIcHpoQWowNDFWK1ZwTTNRMFZaelZHSEp5STIxMmN6R05wdGFHeXRtYVd1UHRwR2tEUnZ6U1FIcnFseVFVNkRXdGNpMXgvWisyN3JQdzBVOW5oM1hRZm5pb21YbmgwZXFpVy9aazgrOUxQS2ZFUDNSamJkTmY3QnJvdTNtKzJmMWZPT1BNNlhTMlU4dWRFeVorT1dZdVcrc3VWVExVZjJSMXE1S1oybDJRejdtTU4xQTlXcUxxMWF2dHJ5c2V2VjFWcjNhdFBsL1JmMHFtbmJYcVdIMWdhNTV6VHBXa2FnNjVyL1J2SEhUWEdmZXRiQ1Ryamx2SVVmVlE5bThqOUI1dCtLZXZxRjUrNjQ2NzlhWHpSdWRBbXppS0RSbHAxM08vNitZUDJXODEwRkJBYk9scjRlRnFNN0s4QkNtZUdqUGJib2NEL21vbXQwRUdtdXIvSnRncnhab2FrSis3Q2ZlS0g1dXVTcCtPbHdOUDIwS1ZQejRBVDlOa0hOemlCL0JoaEVLUFcwcWxtRER3cFlDdTl5K1NHNFZUZmU0d1ozU2lPcDdIZlJwR3JFOHI0M0xGZzFOVWRCMUdVNkwxVDNsNDFiZUFIVmhrbFNMUUxnWjAzMWIrcVBkeDFWc0lvUE1CMW1YYjZXS3JnOHVmWUJqWXh5T3NSdDVDOER4RGtGdmlwWEtYd09sL3dFMHFqTHpPcWdERVZwOUhiS0w2cjhxampUOUtZNENYQ2R1NjQzZ3FJMFA4L013dTZ5REw1eXZ1dG83WDRhbmNGdm1kVzlyRGQ0TW4xcXhUNjB1bzhqZndJZWIyNEp5SytnQlZ3bHQ4cStIcm1DSFF2aGRxNlpGL3hIRXhjV1U0K3NLcjRQSW1lamF4MWUvSG9HMmQ2RkgvOXBvUFllK2ZuamRHM1B3NDc0K28yMHZGZ0Z2dTVuN0RiZVo1U2ZMT1FIcy9DK24rME1XRmIwaEoxNTBrbXJDS2UyYk84MW9Ed0RLaStnbDNkUzNVdlQ2REpUZ05DUmZMdlFIMjhPbkZIK3dDMUppYkZkcmJHRkJiMmxPeThmYTIwTzJ2QUtxL0tUNHNZdE5abGFlajI3MTlyWmdZaUZZc1VJUmkwTHFiVUVqMW1kYkd1R0ZOUG14MGVyM1BGcXJ5VE9jRnVibTVXWnFtckI2K0NFL3YvZkNxeHNXTGQzVSt0M1Fra041blk4L3UvTFBqL0cxTzIxSEYrOWJPS3pmSHhiTi9QejIva3JrMlR1ZW45aDF3K3JSejI3cDAwU3pWdmxyQlg5QkxabXZSL1dBS1krT214a3JuaDh5Y3RMd0I1L012M2QyM3lHVEJ3MGVNTDdwRXlHc3BHZTFJUWRvTDRWVXJBdXViNkdRRmxQRjB0VWtrVWFiSnRBWUJLKzJUUmgxNTRwaDJEWkJYanE4NzU1blM4bzJ2SFZSYlp3d3NVZGZiSnl3YnRCRG96SGs4TmRzNHNkMXByMEhRSDVqNzRIczYzY2Y4RjZsKzBET1A5ZDlBRldSYTNjZzhGVytOZk1xWFFqNDdhb084ajg3QjFRcnJqMkhHclMyR3A4RCtWalZKOWdjanRBNU5MbitISEt2TW9lOGYzWU9WRFc0OWpUeVZLL1dWV2ZDZEFKUm5VdXh1aDY1M0RQWG5nMjJ0UEFHd3BsTWRPWDRvN3IvRmJQRFZvUm9DV1NEOU1xTytYT29iUE5tMHdhTC94UU5xdExwMnBNdlFQdnVhak9uWW9tdnE2SDEvV2NieGxsSVhKekZjR1djUlZEakxCN1F1QjNsdEJQT3BRNnMvd0gyQytBRDljK0xWU1RINGl5R3E4ZFo5cFl2d213NWVGQTBZNDZ2T3dkditkS1JobkVXRWhkbk1jVEZXUWl2eGxrRVJ5ek9ZbWNVY0hjNVBKTXV0Z29xSjlTQkdjU25xZm4zY1hFV2NtTnhGa01qY1JZaExzNGlWaHZLZFRzeEs1K05pRmRjcko1L2cxUURsTllDdTZmUkNLOVhVeU0zcDUyYndLcU85aXRYRC9WQno1OWI3VW1lbDRGcE4wYWR6WjVDcFhkemRQKzVzVCtuaEcwN1piTTlyRGNreE9XeklQY2xVbDZUdklDbjBLTjEwSzdrUEJQYVNGalI3aDRUZXo0WEhEcDh6ZDNLajhyRk80bHA1SjZDUTNkOGRHVEFnTHRManp5MS9LZVM5VVBrc2VPM0R2enlwY3AzeWNXeE81KzUvZVoyWk5yc2gyY3M2alYweUJEbHlPeS96aDkzWUZuL3hUL09IYlp0M0JoNTlLcVBqMkpmQU5ybkk4elpnRHRNcmUrZTRPSlpmL3VxUkZlMmp2VzZTZVdqaGV2MVhSVnlyOUpWQWJGaHd6aU1IYnY2aFNWWEN0WDdVRy9CelpTQk5WQk5hRjllZTZQZEZvUkdGT1M0RGd3WmpTakRsM2RsRUE5ZHB2OHlYcmdYNkI1N05HU2dqNytSTGcyWmpYVnB5Rkt6ODZwTVltcDZmYU9XNnpkcW9ITG9LczBhQnFQdnJyR0dEZnhYY2ZMblh3c3YrdlN1QmkrNTQ4QnZ6elFPc0NhYU94dUYrUWlGT2ZzcU1Ic2JnemtuRHVhTS93ak1VUmx6RmJCSFJxVkw0NEJIN1UwR2Q1akM3Y1A0ZXd6dUROd0tMV0FyWkdlMGdLM1FETFpDTG02Rit2bTBibXcrYmVMbWs5dHdQc0ZtNk52MkZjblpOdGdPMTZHZ1JuYkMxYWJhcnJHNFNLUHp0bHdSQjJIekwxWnB6ZHNBQTlHWllpNWZaaUNjeGpodWxqL1d0cGpOSENNZTZua0ZtU2c2NGRKYmp3L3NZSnlaZ2Zod0pJbi9vVDBVbGFOWG1mV1U2bUQxVlZaWHpZL2F3WjBXUjRudnFqS2tMU2VMdnJDa3ArYVgycWRmNXd2cjZRMHFSTVRqc3M2UEZWeXl3VjkvbWhGTmpVRGhzVU1JUlE3dDJMR0RuN2RxbGRMLzZGSEJjZlFvcGYxZWdFUHNzZUttcDhNOXBrcFdCNkl4QzZoR3kzTEgyZkVPZWZUa0tJK0Jka1ROb1hVUFRPUHdDSGkrazVzZThiWmQ3M0JwaytsWklRbjJvTUdNZGtzV3NsVVhkb0RlVHN3SlFoTHR6VWtMajJnTXBJQmkwbE1ZMEdqZERKdXhDSWpHd1pDYTE2dGlEdUx5emZrRE55endGQ00rZHk0ZW1ObVRiekoyenU4K0t4LysvSlpUdlF6YlZoOEZsRTRZdmp4bEZWYlJqaC9FSjgrZHpIZnA5NE9pNjN2KzFkS0pLQ05wUHducEs4NE9NNzdycWgwbFBGZnBLSkdvZHBRSVdSMHVsZ3gzamE0U3lFampPMHZzUlVmaTVkMGx4SGZ2b3YzKy9vVndJY05zMFBGaUZucjZMZ2NNUkNWem5FZGhPd0t3SlYwRHR1U3J3SlpTRDV2N3VyQ3BqREVldkYwblN6OTVmblhabFFCZWlLVWlBUjB6R0lzcC9wTHhETHBHb2NTc0tFOGc3R1RjSU5FZjdjMm5RdTFneDk1Z2tpRkdrNUl0dEY5VTNGeVFYWGpRb1c3VlhIZjFWUllRUDVYM2RzclZqY3lEZVhKNDF2Y0NhTURLT1J2cmZPSHlzZFlxMSs5OGdVcHZvOTB2cUJyY29BT0d1S00rUGtMN0xhbTlHUHR5VjdaaFJPMlYvQ2U3TGRuKzJXNUwyb3dHUFJpdmFMY0VOTUR3VjB6eGw0anhzSVlZbEcwKzJSVUkyOW5pWThsNGtrKzJIUTg2TGJUdEVycTBFaTBzYnVmRVk4ck1PdXBmRGZMc0hLenJZMTFkOGNZd2Z4Sk1wc3N4LzJaMDNVczVUcmRFS2dPb3N6QVRsdUk5V2NEbTF5eWNuNmJGMHU2dzNtVEYzdnY2K2l4Tk5YaEhkNWlaVlh1blJLdTlXVWFVSG51ZGM2NzZVSDFjQmlrTDFzTUN3S2RzQzEvNjZEc2tmWlBFMTc3QjEwUTh3ajBYZjlxay9QbWRSemRqU2hSSlViN0c5Q2orOEFxaTJ6ZFJUYXViOENiUnIzemlvN0lIeE1uM3IvNG9wa3ZwT05xanpjZTE0K2F5VTZma2pFRFFBUXVRNncvcDJaSUUyMG8xY2t0L3VMVTFDYzlTYWkzR3NqZnc0Q1IyK0VuUUNydXl0VDlrYllaenNwcGhUcGpMMGN5TDlkc2lQVkxBYWd0cVVuRjFyRUIwSVpjN0ZXKzJ0bFdaT1c4emxERnQxYjRXZUhqUzFkeGZyTlZtVkhwVE0xaFMrMEV1aXBEV1A5L2E0ZXZGSzcrcXQ0WDdmclJnMlUrL3VmWFgxU3N1THR4NCtxWE5KMGVFeDIwK0tXeUt0WWtFMGJQcTJWa3I0N3hkcTU5N2R0MXloY3I0Ui9jKytzTjQ2dXdTV0F4VWM0ekdRSzNZSVN3K0NvcHRnczJCc0lIRmJpMSs3SHdqNjQ4SFRaYjRodlo0cUtnWlVRV0VhNzkyTitFb2VkYkhTdmNDVVRhSWxYNGFqYzhTMEQ0T0NCblVQczZuRmVRQ3RWcXRJanN1ajlWV1lTRnN3LzY1S3ZzK3plSW1VY3NZYUp6a2kzdjVZNXIrb010NHNPdUwzaGRPWU41bmx5OHNxTjVuR20vRmMzNVF5ekhSK0RTV0cyR2lON1lndDV0aXRVYXVoRml0RWJtS1g1amtYK0g1bFJaYzd0d2xvRmZKUWkvUW9SMUFyU3doMFFwcXMwYXdndG9NUENOa29MbVhWMjNmMG5qYkZya3hXKzlLMis1L2MvN3NOOVdONWM4U2JtamRSNW9od0tzeTBaT0Y1NE93cEFPckJ0VnAyWTROVG1OSHRMQUc1MkZ0c2hubm9OV3lzM0F5amdmVEdjenB0Qk50T3JZN3owaW53V3hNNmt4bndoZnprREM5MzVNT08xdHJUcUNxUTNJR1poNUpSVVhSZnVpdzlodzlYSTd5NEdqZk95MlErMUJ4VXVUVGp5K2RJRHJsMTJQalJqYTVkV0Q3aVEvZkhGNCs5OWlJU2ttemJKbWlxVlRxdmoyci9OS3NOQ1B2bmdVRFY3L1I3OEhJS2ttajVna00wdDdLU1p3K1duVVNXNUhvMlE2MFhUc1hiZGZlNEhRVmRJSWVFcFpHRWpheVBPNkxGMk01M094OGxiVTBCeC8yZXpySHV2QXpObytGQVRabk92SjRXejJQUitsazg0ZWNkQ3luSThyWW5SNGJheXNuMjJ4NDVxRUY4R0tNeThoSzU1bHZuTU8ySlc3dWlrTjVCbTJZTzZyOWlFZU96ZnRZT1p6TWZ4UnA2U0h0UHBuL3dhU3BUeW5ucStQTzVzbnVldmRORTRlTVZFNTlzZXpQeXA5R2podjc5TE40T0EvM2Y3VlgvejkvVHN2L1ZINzF2K0o4R0w3dWw3cnpPcXh4YWNLMXdqN0NOTFNZSzJCLzQ1Q1hZMDNuTVRtRms5U21QY25BdkN5dHZDYXo2blh6MGRxaUZBUE5tVU56SlplZDdwSExNdWljWmhiNFR6RUNaYVFCRWJUaTFDUm50ckZGZTRFTldCV1FOUzQyTWkwbmI4SERBV05IWVJteVd0K1Q2dXZjcG0yMlczaUJqSG5pbmJMN2xkTS9SejZOaEpLYS9lYTJCL3UwYlRGQmFrdG12dmJ1b1IzS0MvYm5YS1kyZmN1UGsyN3ZFekZ5ck0yd2w4WWYvVVhTckQycWJQdCsyNmdPTHZlQ2Rjdm5MVkp6aG5SZndMeGRZQjgvek00Sm9kazVLcE9tcHdVNTdZVDFKaEswckFjUDYwdnRZbWNHdWFnZ3c5WTNicFRYZnJRdVVNZTBSTS9VY3FKQllVbU9kdENsOWZoK2RxQnFGaFk3MXVjVENVV1ZaTW45cStZOFZLQmMrR3ZremRwM2hWTmszcmJxUFVGbEpzanhiWHp2eUxiMHpvTksrcno3SFIrSzlGeTY5SVZaSmVwWnRaUm51ekd2a2VZWEdRTU5PYlRWRmVQUVlHSzZXQ3RTNE5CT0YrVTZ5S0ZkdEVPMUN6bTBrOGtWVlBoeEpiRkVpS2FyVzEzUk52cFIzaXpHT3VZeWxqd3hjdXJUWHo4bTJvcnd5dUlUb3l1UUQwZk9iL3JzQThWRWpzN2IvTURnU0JoUDRZem0xaTlTYTI0YU81SElHbjhpa2UwYUp4TFI0cG9HcHhJUis0SGZucm44YUtJWWk0YXh1d09QTHRWNk9Rdll1dzh3clF5UFM0MXBab20rb0YxaXA0OGxISThyajNhQ3Z1Sml4YUdva2p2Ums4WmJhT1VVRnpScDJYa3BhRDhZNnUwSFBvdUpya0toVUkxaFp1ZDJyK2F0NUtBY09WaWhuSjB4cGZNOUk3ZE5PanFoMllLRnpTWTQxbjlURHBEM0Z6WmZXcXJzdW1WVy9nbHB0MmZ4WXMvRUJRdndUQ0psdjFSQWErL3ZpR0VNTjJhSUUrcTdSZFFmY3hHWENVaDk0R1phbHFEeW9zc090OEwyRUhqNlVvWGlSWWIzRDBsN2NZU3luM1NpK1BydlAzT1AwVU1CemQxelk1K09oaWZ1VVUzSnpUUWxvU2JxSmtsZ05KeEFKV2NDYWtZSkxPZFJKVnd1NkdabjdjVzBJWlc5Tk1uS3RORU5KNHExNWVUbEtRZVc5MVgrOHBOeUI5bEtudnJnZGVVaDFJdnU4QS8vN2VnanA1YVNyT2ZtL2w4N0U1RHFQL0ZuZE1WcFA1ckd0Qjl0blBaRE5SK3E5VkRhY0FKTmZrM3g0dUtHcS81WndBcHdIajlPUEd5aFo2ZGowM3RKN1ZsSDAzc3R4NE5tSXozVkQra1IrMVU0bUFhcmlrbEtzRWFXOUN1YU1VUm5TbUFodXNKQU83c05tNW9JWGx1VzRDVW9LNnk4Yzltb1NjS1dYWWtsbHg1UG5VKzZDL21SWlNPWHZzd25rUHN2WHZ5SDBnb2J6NUkvaXBOM0tWOUhmb3lkdWZjL2NkWmZHNUEzeFRDdUE4OEtvdU1hRXdMc2RKcWdwTU9UY0p5b1ZhRTRTYURpaEprajJIQzFTdFNhV1h5T21YejFQTkJyMDVNMmZNL0lpWVA4ZHhYODJmY2lKL2llQnhXajhuV0Y4aGZGSkFUNGtiVWhvU2UrSXF0ckQvTzdsSGVWbVdRV0tZcDBVOC80T1NPdWxXU3VHWGNmRjhxaitvV0dWY3lqVlE4R1cxNFM0TUlrc1hJVFVEZHk4RXhBcEdUUS9iRFloQXNhUld4YVRYS0s2RUd0Y2xhUjdJamE2M0VLWG00K0thZy9BeHNOSzVFbHF4SjJ1bml2SVJQUHI1NzM5cDllS3k5Zis5YnJDMzZzR3ZUb1Q1WEhTRUtMdS9zWHpLdFV6cHphb1p3Kzh1am9ZYXVuRjg4cFh2TE14Q1VWa3g1KzZPT1hiNXQ4Ynp0SE03bmsxZThlaTUzZE51ZzZaN2VwakZFYmQzWWJocFpoL3pFYlc3emk3RFliT3owT3VHVC8xUnRxdDBobGx3YUlteTZPRURkZEdxRHlyMEZhN0RIcjVCNjVzbGJNNFF1YUplcmphOGlWdzBZbVhZeXM1MUM5cklrQ2hxR0tCRkNhZ25aSDBkVkFjdFNMbGloMEwwNW90bkJCczRrZ1Q5YkhBNm8xUmFYSnYvQk1RTlF0Nlhxa2NqMVlEcnVjR0tEZFJhbFdtV0NWT2FRbEVsVXRxWEdVUnZWSk96QUdPNnRWVjNPRGduWWpWUnk1aHBxanQxNWpqRmNVTjFSRXltUHFZUU9sOE9LSWVIWHdmOGQ1Zy8rNjh5ci8zYzhhSkRGOVFjdjVHbW9rV0I4UlRScFJoUW1LR0xWT2wvRnBoaHR4VEVYdEoyaHBTUm9VWnYrYnppLzgzM3h1NzMvUGVYZGdLVnk4U0kwRHd2UnpxbE8wdkZJN3IyOUFjajJOdXhFMXU2RnVqWHJkcExwRG10M1NRYzRHZWwwYU41NkRwMk1kR0t3NDVtTWxVUHNvd1FMU0h0WThqV3JiMkdaVmNOUHpTMmtIUWxiMDY3QlFGUWI1Z2VEeSs5RmZINVFTUVFjeU0vODkxakRUWHJ1MDVFYlB0b3lWeXdMRFA1UERjaHVYdHlDVHMxdkZMRnNteWN5eDVtUk5Jak5KdjQya0g1bXB6RlordDFINW5USjdNOGttUnVVWDhnb3hrbXpsbFBJTGY1U2trTHNYTGxTcWxLOUIxQWZYclNQM2tJaHk4d1ZoYTIzZkMrU2RuLzVsNStHaGJWSWJiNXRRVkduOTE3ZE54Q3Uxdm9hTUREVTlZR1NCaWwxSkphcHRRbFU2T3JjVlFJdHZVMzNxVGpVbXFOWkdoVzBhNnBhMGFhUHR1YU1EUnVOOVp1b3JaU2NJMklDWmFXeVhSL3NLS1J2RlBaTzdZdU5MeTBkOE83eWlZbkFkTitUNHI4SU1QaTJpekY5L3p5MzhCbUNydzl2ZGZ6SW1RM1M2ZUQ0ZXhRUGRJcEkrY0kzcDYxVGI1WExUTEFEVDU3ZHU1TGRHVFROcW5xbmpLZnQxQjZodjZQNzY4WUphb3orR2VZdUtlWFZ3NjdVSFI1R0NSQXphZWF5VFJUMGNiQ2tZTEcvVXIwWnNSWGc4SzB0alV1MmtlOW1LMUZ0SkhDM0Fvc3NpcUFlU21wa2R4L3REWnRvQ3dNd3hPODdCTE5hNFNpdzljenpFT1lrY1VhWTZnRStKOHdoVlJMMUF3RlRxZlQrWFZKY1BzK1UwZzFRK244VDFVZmVFTzREbC9JeDhQQ0J6WFZ3TXp2cGp5SG02b1czMTVqUXRyRE9yaDVLN3pDcWNBZWJqVWExTkZVcENGeklHcURJakNxZDREeXhzRk5LbENHYkV5N3lPVEs4VUc4cWtHSmdOWUhRM0RtT2NUTG9xWUkwQ2RSbEVTR3M5Z0M4UGpQcTJNNkorU0RmUFFBcnJkUm51dVBpbDlqaW1xcVJZYWtKYUdyVFU2cUsrN1ppVEVtdDdVakQza0dheFJnMEZyaEJzM0Z3T25VcDVlRFlUYS9LQWdxdkgxRW1INW45QzJua2lMZm1Qa3BYREh6OS83SkdSN1VmTjNUQm9EYkh1R2I5VDJYNm9Xdm5ocTdIalJwSVdmMTcyQmZHT0hETHhwcnU3WmoveG5uSis1WWZLcTI4L3kzeFBkV2UwbjlLemdYTXd5c0hGb2h3cGFtU0RkYURPeG9JS1Y0SXVxbmsxb1JoMk13eTdxVHNJTlMrUG1lYkxvRzVxQWlhZml6RU5KeFl2Z2NJdXA5dUNDVG9hMGVKb2xUQjJnUENrd3kreW80NEpXSTkyZGxTYzdGYWVKdXJuWmRtSTArN09iSWVLVTI2bWhvZmx5YllHU1l1ZDc1TEN6VnVVZDk5ZDhPT3JZNHpLNStTZE9XZEo3bmV6bi90ZStlU3ZzMkM5WnIxQldyNzJlMFZXaGlxdnZqTWkvUGRGa1duODRaZVU4K3NBT3krL1JLenIxaWpuY2Y3OWdLWjQycThqTVhabXNDbEFRMkY0ZmxFNHdja1pZTklKbUpTUVJMTjU3V2FxaHlQbmRQbGoxYTkya1o2OUlwdEJlY2NhMHFBemdmbjlQVGF3bjJLOW1RckIwS01xRjdGYjNUUVkzWS9zRHgyL3FhRHJ4M1A1NFJYS0kwby85MGViU0xWeWg4eDN5dnhzMjMwcjJuYnRDVXkxU2VSVDBBM092c1FQK0gvb3ZNeDVZSXZ2bDNiVGVhNWswZlZnQmtpUUpyNmdUUUtPNDR0TmpJVmRRR1JXT1EwdUM1Q3JtUmFVdWxnTVJtNlhMT2NtazZEZTBPb2dGelRvV3gzRUl4Y3NyKzdmemc2UzBlTUpNckxCS2h2M3dZWTB0bXBGNkRzOUI0SGl4bXhCS3JVRmJiUWxRSk1NdE85ZGx1aWhWRkpoRTQ5a0lkcG95SjIyeW84UHo4NlQ3Sm50ZXo5MU45OHpJM0pnZmFtcHcyZmx6LzkxZnVtbDFUOHFuMVI4dHI3aUdMNzQ5dmM5dFhyQzFONjMyVXVMRnpTdEtoODVjOEdQaTE2OHVKejg1ck5OTldjMnc0dnlhOHdIN2lwNk9UUHMySXlZNzgwaXNiU2ZZSVpVRS9Zdzc2QkhqS1dmV2pDTmpSYjFva3ZRQU1oSlFTdFRNckJVMUJTTDZ0UjJXMWplQjlDc3Rrak9xRmZkM1M2bjJ2ajlTdGViekhQbHUrWFJzLzc0bWxKS2hqdzIrL2xubFRDNWJlaVVDY09WSGFKMzhaTmJ1cWM5TzdwNGJjbmdQbmZmUC9PQmU3djJqcDY1SmN5RWVjVDUzUWh6dHNUOGJvYXIrdDFrL2tqa2lPZ3RyUjJsK3QxK0ZUZFJuRGk1Q2V3c1VLdzVDSElhV3NtTWNXUWpQUW1FWlVyYVdJSVJpRnVNdjdkaThYZUJtdE14QzF0am9Pa0dlbU4rV01jTzZrRGhKcGlvYjVLZEIyNWhIcmdySEhCTzNqbDVBWDloUTlLYzJzMnBzMGtLWDZSMDdWcEtCUExaenRwUnluaU0wWktsZ25uWlBrWCtOejBEdEJub0RKdG8vOTJHZmp2U2lOL09jRU4rTzRJaGt6elNqSVNVNFcveUtldjRsTDNLSXlSVXJhdy9zZTZFc3A0ZlJONk9yT1pINGt0cEg2a2c1ODRxQ3VIUEt2YW9qU1JVQWc1emNEK3dDQjFnTUJIQnNXdkFXalY0RTlGYUZabmNBbnNzMDR4SHJMRk5nQm9YV0ZFcFppcXVnRDBJMUh1WGlkNDdvdzE3R3RydFFWY0tSYXZzamp2RUxONkJwMUc3eHp0WlZxYzN1M3V2amZ2SHJ5NmR1WER4Nk5temh2ZmRldXZkVzcrWGp3eSs2KzF2OWw0b25qSnZlUDk3SDVvMXJNOGQvUW9LSmhTdm16RndXc1p0YnhhL0VUdVBrcDdQRk8rdkl3MzlkWVovMGw4bmwvTlRWcGRINW92ZTJsMUN0MHVuaEc2MXU5UWFnNEhTSWRvWC9KRXJSc1dHazJheDNuQXdOT0t2dzc2bUNleFRRajFnS0dnczZLK3oyYS9scjh0azdyb29jSW5qbXhGM3MvR09kWDllRncrbkZLYnV1dExTK25NN2g5Q3p1ZUw5ZGFTaHY4NXdiWDhkTzdxenl3R2xHM2xubDFMeWhlaU5sUE5EbFlMSVp2TDExM1YwbkRxbDdyd1lnSEhTWW4weExZRlFhcFRHS1BGVFoxMk1zYVF6WjEwOUs3R29mYS9xblhWZTFWblhnYWpPT292V204M2JmV2taTFFweWNseG0vdnQxeW0xR1I2YTNUZXVPUlUwNmxGZ01lZDJlZ1dGZTdnK29XSlgwL09sWDV6MThXL05FWFJRUFAxRTg5R2lFWHVyeFlLeGZGc3loTXFwTnVBQURBbTNCSlY3Rlk2Y25ObmtGS1NXbHF6WW8wNVFaZ0tLamZFc0FJeTl5aGsrcVBWbC9GaTJGb2RObGF4SG5yOVBVTkZ5V2VIK2RvVEYvSFN6TjBQTHlTTG5vVlFySndVdW55QkdsRGZkdmNKWW53MGMzd0VkRGZ4eGhMY3BqL2poRHZUL09jTGsvVGhaV2xFYzJZY1dUc0FxRjNMLzcrYUQvVzg0Tkoxd0I2QjJINk5yRS9IVUlBeDc4R09ldk05eVl2NjVBV0tFVWJ4QldsWmF5STZqLzVlZjVDZHhVcFZxRE1iUjBrTXB0dVJLTzhpYlpIZ2htdzR4YStFTmFOT0VFd2pvNjRUbllRQktKUG5yV0tCYkhtV2s1Q0dZMmFQRDhhdzlRamE0NWZBV01PRHc5Q29RakhrQWFUTVJjTkNHMXFDam93MXdzRStYbjJhbFlOcGZFdW1aeENWajhiZzlxOU15Ymg4MVg4TFFqWERlN3pVbXI1ZklBWlRoSFZuOWRhS09waTdHZHBwMzYvZjQrVDNiWTBPSEpQbStkKzl2K0RpT0w4amQwbkhidi91OHJsNjRxR1RLa1pPa3FQdlRJYzZ1V3JscjYzQ084azZzanVlMEx5VkdsWldGNzVXT2xUbEZPWk9mbEtFTkplZHNpMHZ3ZnZ6ODZpaDg1NnBSaUdmV25kL2QvT29yN2w1M25LSU11ZW9xT2NWZlVCNlc1d3ZkSEd2citESmNYUkJyWXVTYW9kbDdwL2dPKzJIdmRoc1E1UUE2amtEdWdTc25tdHdnSTRoelZ5MkwrUDlMUS82ZTVYSXczUEJQaCt2NC9xajh1S24vMGtiNDdmMU5lM3ZuUS9SdjM4a3ZJaTByeG9QRTN0U1NuZ1V1SGMyNVJ6M3pXTEkyWENWRTgwTzNXd1BkbmFMUWUxTkNZN3cvbUxzTC82Nk56RjFaZGlwMEo4YXNXNVhTc0h6dU9kNlh2ajF6dSs3dmE0Rkd0eHN5V29YSDNYeFNjdU5Xb1h4RWU5V1R4QUlVcEVmMS9GalY1Tk1aeHdrS2loY3BHaVRrWExNZHBHamp2RDFtczlPZ3k5UCt4WEJ0YW81dU01Smxvalo2aHlQeC9BdXFiY2Y2L1p1UVVTZWsyZlV5UC9FOTJLQVhsSk9QSnVmT21LMmVBU1NtVFBmNDd4LzZtZkJmQStPUElvUThPVnUxSmFZUnFUeWJIL0grZUFEVkNLUGtrZ2d4bkZpV0ZNeVZtVWZMMUZpVjhNcWgxSkFhVmc2dTJaTXpOSmpTd0hnbGRUSkpNQVQyNVF6a0tjQllEbk44SzAwSHJpMEZhaW1CR0xxaDEwU2hYRFNxc1VmOWZGTXdHTUhvYWgxRk5oTGttWUkwQ2RUbEVRRys5UVo1NVFaNmxvelJPamVZSjBLWVl3T3JEZWwwcWRzTFFTOHhxWS82L1JITk5TSnNZOC85bFh1SC9TN3pDLzljTy9YL3NTTDY4ZVA5Q2J1OVJ0NWNOWG5uS3BxU1Iwd2tubHo2eXJ0dkFYa2NXcmZ6N3ZJV1hWaXo1SUR5c1ovOURLNHNYSGV4ejE4Z0hIMW10ckZoYXUySWtxM3VwTzZQcFFXdmdzcmd4cXVWdFU0c3dtREtoVjVXSnNPQ3k2YU1ZWmZtNWJrUFUzNWZHeWpCb0xYNmFHNVFJdmMxVEZQUHRwVkxmbmhudW9CTWhUY1YxQUIyWU1RZEpIaWovbExGWVVRekk1ZCtaK2p5M2E5eWFINTZaK2RQYWo1VWExM2VrOUwyTkwrMC9XRkc1RDlBZkdQYmFjM2V2dkxSeSthWFZ4SE5VOGZIVzE4NStSNGFjUFl0ejZnMkVYQ3Q2cVovOXdmb2FhWHArdHd1VE51eWNOcHEwa1VoOWVHaVdKbEErS3p2b0FVSTA2VDVCWk9jNEcyeEJRdnVKWVJZKyt2QmNEWHg0eklISGFSMU81c0hUOUNaZFo1UWYyMFV1bEN1ZktyVlowb0pKNUhZbC9NUWNVcGEyNmVubDI0RXB6bEsyNVBOSEIwOGdMNDc1UDlvbndYZmRQZ21FTTlGNW4rQzgzSFF1bEkyVVo0OGVFMi9FYWFmWG4vd2s0c2xQc3VDakphelp0RHR5RnF5U3FBTitucFdOV3loTEMvdzhPd3N2czVGUFpyRk1VeXpUeEZMVzVDeXEyZEx1aU1GMG1IM0lxWGNWcWQyU1lUWnEwcVk3amFDNXpyU3VEb1JWdDN0dHBzcHlFbFo2ekQ2Mzk3TlAzM3gwU0hxWFB0UFdyMWZPN2l3WGw4NTgrKzJaeXB0SHYzdno3SnMxemVabUJSZVhMMzF0NzR1UlhlSlN0ci9RcnlXZGJaaFBIL05zR1JyemJGMmVUMCs5VzMxcCtScm9sYkdEanpBSG5lblFHY2h6V0J4Y1U2OURoeTIyRktRWWVsZ2s4L3RoUTJtTEgvWTNiU2h0aGJHeWtPZlkwQ1h2U2NUdU9UU2YvdityN1Zwam83aXU4TnlaZmUvYTN2V3VQWDZ3MkJ2WGI5WnJabTJNQTRGZ1Vtd2dPSzRKeUhHTVF5Z0JhaDdoSVl3U0owS1VOSWFraVdPb2dMUjRtN1kwb2E2RWR0YUw1YVFvb2lYNVlVaFVWWmJzOE1OWXBFcXArNGhRSzlFRTdISHZPWGRtZDlhUFFGWEYwcTUzWmxaMzU1eDc3OXh6dm52TytleXBzdGxTUGNQTU5pZXlmNWJ4dTQvOTUzVFhIeHRhVnZVOGQvSjZDdmxjbWVlNmNmcVp0MnQzYlBpa2U5L1ZyaWQ1eHlubDdlZWUzcjUyL1dEWGowNTkwbFQvL1czYm4vckpWYnozcHFsL0NKMkdTbXFqM3VFaUVzZm9waU1pM0xzWGJwamFvNTVoNUlQT1pVVGdBVHVhbm9EVWZybmhEeTh6cERiWkdiWmRsdlB0WDRlTEw5T0RQanV5M2p2d1BRbmV3L25PdmdKa3ZTL0U5eUo0ajlBek9oN2N3dXB3VVRWd2hjS0JnNHBmemMxT2NrOW1QNDI0Y0s2SFBScE1yajVCOUdMeG9nQkxVdUJrTDdXaW9oenhaQWZndEFoczFuSFlxRXdvTERNbFVtdk9ONGp6VFN5cnA2bmg0Z2ZQdmpoL3dicEhKWDlWWThWU24zZ3R0UGxhWTkzUGY3cHBiNnEvb041Zlh2THd1b3JGdnZUaFgrMy9lK2UrenRiNm5HRGVRMm5KU2E2YytZR0t1dUxPODhzV0hkcld0Q3FqT0MvRG01emk4T1RtQmlwWEZaL3NYUSsxUFdsSEFCYzF4T3lYSkZicWtJbDFYQzFYRXViUUkwZG10VmhnUHBRcWlVWjdRMGJiaFF0MzcrQjZMRXdCY1duT3QxYjdneCt3aEd5ejFmNlkra3FKb0J4SmpDbkZCRDlvRDhpOGtZNzJnSnhpUlpJVWxVM2JRbi9HS1NGalN2bENzNWEyaW5NZWZzU1NYN3o0MFZCbng2SUZsNkpYVExXMWh0Wjc3eHc3YmpQVlg3akFma3VadW0yNlRkZVdRcTRjT0hReTFaajRJaE9tQXhSb1FCRGlQOWt3Q2NzTEhOb2tYSWhRMER3N2JrN0FBbE5rd3lpWklsYU1MWTArcWlSd3llM0luY0xKNVVXWU9wNElFTVZOUEJVb2lwa3FDWWhSM09aYnBNZU9oSDlyQnFBT1JkSVpnbkV3NldmTUlsU2ZZV2JnaVBkd1hzZ0RjS2t5cDJrV0lhQTZiaGZrQWN3THFtYTlGdnJoWVJhQ0IvZGNBZHRKUXdBWXdxWkFBVWsyTmZMRERaRWZTWm5UOGdCNFZWQ1h6aHpqdDRUSXZLWVRCMWFNUkpYZ1pFamdpTy9RSzhkZVZQNUNyWUkyY2twcHkxLzkwdmQ2THZLR3lZblh0ejc3MUNaWVo3Qm15Z2lYQ1hsbXNERVdUZ215RmNZejJ3cVRGUWhuNEFvamFpdU1pRWFhQ0N0TWhnZ2ZNMkNGRVZsVWJvcWE1KzBVY1RPQWt6MFpzUjE1L2NvU3I1WVNXMDlpQlZLMGRlUUtsRVE1eW0vRWtpajl1SVNvZHU1bXVvWk16d2NnaWZrQXRtL09CeUJtdHByb0VjNFByNXo3NnpTVU03YSthRG5aMXpnbjlRUTJ6Y2dvemd3QTd6STZBQzdrNlBReGprN3FOd0poRFdRQ0FOQ1VDcDZqQld5bVB0NlprWWt3MHdQa0U4ZGc0Tm1RajZFRVNGZ1BnaGpETVZTWStkNXIwT2ZVNXdTWXh1L3ZlNnQxY1dJNUFiYlpjZ0tvSmx0RFN1ZFo1dXJkRzFXK1FzZGJqU0UzWGFkUHdTcDlwQndXSnpiRkNTc1Q0dkJndjhsZzErTitRYmZQZFkzLzU0K3pJS1NjTEZmOGQrOXErMlRHVW9aWHhhMEo1RHFjMmJaTmF4czR4OEJ2VFd3K3pBZVBac0xPR2JFb3V3RlgxSFBBY2drTXIvL2Z0VXdoeXZmVGE2TEdVd3N2NUNqVmtja0tBVDZ6cDRkOTM5UjcvKytiOHRYdm54U0d5QnZJNzFkTTF4d0kvdUF3c2w1alhyUXpLa1FyRzVSYWRsa0YyakZlRWt3N3VhczlvMjdGNDhMUVFNZlI3THFzZFV1Y3lJL0k3UkFHeVZhTVZ3clFWUVhhdGNmYk5RNUhMZGh1Mk9JRURqY1kvVUtNeDNFWmVZVGswY252TVpsMzFLNWNjMm5YSVlNemUrM2l0SkgzTzM2WWpYRm5VeWJTekkzUXR2MGNYYXlpcGdkc1dkUzEzRnBiczVxMkhNbGFXKzBaZ1h0SFR0Y2hvUkIxZ1RGR29JMndNd2lGdlJ4QnFKbmloclJqU2NzM1R0QU11QXVRMnlRbWoydXBQUENNZHNDT2pjSEk2bURydEJhY3FjSFJuZTJaZFN0VzZ4V1pvRko2ZjFTblBJdUZFeUVxQzdRYVRnMUNlUmUzeXNTVk1aY0c2QUZHN3JDYUJiSDlwUURlcFFzbzdCMGl1MHVkanZKbjlnUTVRdlgyd2M1MlhZL1VVaFZxZmNORDMvRC93cjRSQVQweWNxaEQ2Q0s0eDlRSHVNZW9oMTM2eHRzVTU3aE50VnZoTnRmOGJsZDd2SHZyNGgyTjQ3T0QzT0kvUlYzbWMzR3FVZHV3YnFUVHB4akViS2hjUHBXaUVCU3EwZ3JkZWU2T0NmZmgxQW5Gc2NkaHlOenJKRDVsekxuWE9ma2hYOE53US80bTV2M2xNazlVemFkTUQ0VDVZUkFJc3RKRmRScUpndHNjYTFkdHZFdHhPSlNKMU1QdUNTVXBTWUZmSXM1OVR0SkNXcHl4MzFMT0tlZWMrMXpLR1BHQkxLUGtZLzZPTUVvbmJoa0g1WDBFSzZUWXEvOVVSeWxxeEx4NzlaL3FKOFZwaGtmZitld1hvUnM5L05EdW50RGVQV2Q3RUE4UGNaelJ6dzJwTnFtR3dSb3NRYlJHUVJDakZUQkJZR3pVbFJTYVFRNC8wemJGdFYxOWhmcEpaVDlaTkRDRWY5UmM0dHFtYmxzZk0vWlMyd1BZRm91b243T0NXOGNOTXZzRDdjVHc4bUIwQVdNZS9hNkVHU1VzQnovZE1CNlZjZ3VBRktpYWxWbGRLMFdkTmpnUmRhbzhrdlVNMExLUGE0WFpUWGFNVDRBRnQ1aCtMR1p3Zlo0ZDYwbFUwbzgxOUdPTlU2NmpINWZTWmVZSlRJaDNwZmJaaEF3b2VpY0hpdWxCWm00QmtLWExkVFYwMEN4SFYxbWl4a3pmdkx6S3BYQWVkOHNTYVU0UkdraU43NDhKWUdzd3QzRm1YUUxqWEJmYUJ0NTY0MkxENldlNkxyNjJwNkh4QjN1ZldML0o0TzIrOXdWZlNFKysyWGVSWHUxOHZtSDlkcmpJdnd6bm92MzAzTEU5N053T3c1TFRuNDJjMmZMdXRtRWlESGQzNzJ3N2NYY1FvZ1JKNjViM3RvMmNPVDB5ZkdabjkxdTdkbmFmYUp0K0FuTkVuK1FMa1dmVngya2xIdWdZczhHTWxyRFhqUnpiUm9jQm44alRycU5ueHpuNUFtMXJTV0piMUNwVG00dTNSVEJZWkRxWDZ4azlheXVaT2poVkpYeHFBZ1piemt6Tm85ZUZTMmNuVmc2YXJuOWR5T2IvZ2FsYnhpWmpoSzRnUjFoZFhqbFBVUE5FM01JNDlUaExIQ3czbHdQUVNJcGF6SGdpSXloYjZBa29BbFBHMkR5U3hpUFpCakFlc25QQXJwVWlobXlOTDU3YThqaVVnTjVEdHZxUmhnREtJeFlVVmxmTGJuaWFwVGhWRktXZ3NxS0tQc0lXY1ltUUFmVmt4VVRrZ0NzODhLN1IybnQ1S1NrYjdQMWJjMGZqYjE5NjlVL2xmUExraU1YQSt5ZS9MTHR4NnNCdkdnNjIzdnJsaUhLMWlueHhwSGpaeW9yRG95VDF4S3ROQjNaZERoMWVzRGEvNXNoN0g3Y2ZiSHl6aDRpMzRKbGRLZVFaQXhoMzcrSGFPV1p3V1IxMGxuT3MxSVlRNHcwM1dXay9KRXNTeHZ5WWhvSEwzQU1NOWJQdDc0V05PT3VqSGxhWHc4TXlrWkxaRXhEVGp3QTZzVG5VeDZzdkxROWlHRnpCYk53ckYvSUVWeVc1ZmEyWmhEZC9QdGJhZEROcHpQall4bzJUWTd5UHZnNHB2eVpQVHg0bmYxWjZ5VWJGUy9zVENydmxHSEpvZjFlcUhMTDBFV1dtOTZiN3JLTjNOaHVtMGJzRFBTdzBjTzhtMnd0c3B1MDFHY2N3a3Rlcm9ZcmhMS1RHb1A1YmlwR2FWZG1TQkR0ZFp2RGFuR0V4ZDlnVnRnYmxkT3U0YkZPakZ6em9DMEVhWXJJVWNXTW10TnRseGJSRmp4dFRwRUZSYm9UYjZLQ1N2UWhESXZDWUJWdnFaazA3MUdDb2drakJORHJqdlVTalhXZFlRdk9KbHNidXJXczJQenhBR3BSSUR6OFFQWDlXT0hPOEpkclNtUFZhOXMyTm5XQmlrLzB4c0FGdENaRHZjVlcrRjFUcDBuWFNVWTljSjVzVm9udFFxS3ovUVNpTVlWWTl2UFNZT0xMWnFrSm1jd28yaTFBZnpSUnBZb2R4NUc0eEhhTlVGbk1keXJLQStuZ1YzRWNxQmx5eU1BZ1NSYmowb21BUXBlb2pZb0gwSFJGRUN6OFVST204VWt6QW5ETDZMU3BsT0ZlUy9WWU5TSHRBWVVzSkZBYVRTK2czODZWSVNTbGNLeW1pMTNLa1NHa0pISldtMDZNU0oxUkxEUHNsdVFMS2VVdTRKVnlxS1VkZVdNTHFHTXlsR2wvQ1dkUDloc0xtN3VZTlhkdHJOeTFwYlNiMVN1UXMvMzdrZk04TVJSNXY2VytHdytmM3p6WldjQzZZSDRucDkvZWFkdjNUdFJzQjdVcXpLeGRLT1RIVklwYnpMYWdWZUMvS1ZSZ29ybEMvcWxBMjZzb0NjNCs2dVZUN0lHcTljbitscXFPVit5K205cjNFQUhqYVkyQmtZR0JnWkhEYS9DSlNJWjdmNWl1RFBBY0RDSnk3c2ZzeGpQNWYrbThUcHd1N0U1REx3Y0FFRWdVQWkvTU9hd0I0Mm1OZ1pHQmd2ZjV2QjBNbjU0Yi9wZjhYY3Jvd0FFV1FBYU1QQUxuQ0I0VUFBQUI0Mm0xVVcyZ1RRUlE5MloyWjNaWWdJcUdJUW40RUg1UWlJa1ZFaXZpV1ZqRlZrUkpDa1NBeHFERnFFQzAraWtnK1FpaWhGQ29xdG1vUkZQeFlwSlFnSWlwU2lpbEZpaUlpL1JBUkZhd1AxS0swTnA2WkpCakVqOFBadlh0bmR1NDU5NDcxRVJ0ZEFCcFdqS2hIM2s0akxTOGlJdXVRVXJkeFFIWWo0dnVCdEgwU1dTSmxIMEdYRE9JU1krMzJCcVRKZldKdThibk1vOU9hd0dyeEJGSHhEakhaampieEZnblpnRFBpTWJLeWxuczE0SnhWaTV0RW5IdjBFSG1pSUZyUTVMeEFRclVpSklkUmtPK1FWZXZJRVdJdENtb1Qzd01vV0x2d1VoekNXdm1BYTc0eC9wVm9KVWE1ZjF1WlI3Z215UDh1eHo0MUQ0TUtDTG12V004bzJ1VmRySkpaWk96emVNZ3pmeWQzQ0NBdFJvc3pBcjRsNGhyMnloM3dSRGVTNUpTNGg2VDFHV0h6UEFuUFdvQkJhMEh4cCtneXovZWR5OHhsWE5hYmZFL24yVTN3N0dtMDJXdXdtOSt1aWp2WXF0NWdqN2lBa0xpTHplSVljeWFRc2c3aE96bHBqNkMzb3IyNGdSTnlNVEx5RVZMeU5GYjVodEVyNTZDVFoveWlCcEN3Z3pnaFlvaXl2aUd0dlk3eDJ6MzdsdEV5eDJlVTRFdEpsMmNMSUdyOGdXK2xqbk45bE9zNy91WVJMWWhxM2Y4SE40SkYyZ3ZqUXhYb2c5QmVFSDVpb1RxTFpNV0hmOEZ6WFNlZk1sNVV3WGdScFk4L2VFN3Evajg0L1dSNm9YMm9CajM0b1BVbmZ5Sm01RnpHS3o3OEMycEZEaGt2cWtFdmpOZmtHait5N2o3bThrelU1RFgxcWlkN3VsWm5EalViWXQwZlRDMkpjdDBMZFIvV05CV25hdGFVY25SUHltZG9acjhWVEIvZjRqdDdXYTlWTGdKNkwzY0lLemhYSWJXVU1VS3ZVVXVMVTZhUEEyWDl1Rjczc3RHZFBhejNkQnB3VlBldjRxeklISHJkY2U3MWx2bHhoQjI5ejE1enZtMXVqRHpLWHROOTNJQ004TmlMZzZ4eERBR3RteHJETWpFZnpkTFAyZ2lSSWQ0VVorVUErWGRKUCsxSFpRYW9RYVBXUjAyejc5aS9VakYrQlRsbkF6d253anlGWmFxT3NlMG1mNmZLazI5anAvRnBFbjd6NzI3MkxlZWhQRHV6ZW42Y2xjVlpwOFhNanQrY1FjL0ZMeksxMG12c2E0Q3pudjFhWnVzZzRIdEtOSmFBOStRVWVUOXpPQWNWaU5WSU84dk5uZFJEeE0wZGxVTVBFU2ZhN1MwNHhmc3JaNDlqZ3ZkRW45Nmp4c01CcXg5Um9zTStYRHl1LzJQbUw4M2FnM3oyYy80Slp4cGhoUDhBYnpsUWVRQUFBSGphWTJCZzBJSENPSVlKakFWTVRFd0xtTldZdlpnTG1HY3dYMk9SWUhGaFNXTHBZSm5COG9WVmlyV0k5UUFiRTFzTzJ5TjJOdlkrRGlZT0k0NE1qaHFPZVJ5Yk9DVTRuM0ZKY05WeG5lRVc0UTdnYnVQK3hXUEVFOERUeExPTjV3NnZGRzhJN3hiZVgzeDVmTWY0RGZnVCtPZnhIK0wvSWFBbEVDWFFJYkJGNEpEQU8wRVJRUjFCTDhGOVFncENLVUxIaEJXRTg0U2ZpR2lKQklsMGlPd1N1U0pxSlZvamVrWk1SNnhMYko5NGcvZzVDU0VKTTRscEVpY2tHU1QxSk9kSTdwQlNra29Bd2luU0VkS0haRHhrVnNtY2tjMlFuU0puSWJkTDdwNDhtN3lLL0FQNWZ3b2VDdE1VM2lnNktTWXBMbE84cGZoUFNVYXBTT21jMGhkbEwrVUZ5dDlVSWxRbXFaeFI1VkpOVTkybHBxQldvblpHWFVBOVJIMk8ramNOT1EwM2pSS05EWm95bWgyYW43Uml0RTVwUjJnLzBHSFNhZEE1b1N1Z0c2TzdTL2VMbm9QZUNuMFYvUVVHS2dibkRCT01CSXlPR2JNWXB4bWZNTkV6V1dWeXllU1hxWVpwaXVrTk16K3paZVlNNWpIbWR5eThMT29zdmxrNldVNndmR1RsWXRWaTljVGF3WHFaalkxTmw4MG1tMysyTnJiVDdEanN6T3ptMkxQWnE5Z24yRTl5NEhNb2NEamx5T0dZNHJqQThaS1RrbE9IMHpwbkxtYzM1d25PUDF5TVhIcGNEcmlLdUFhNWRybStjaE54aTNKYjRYYkRuYys5d1gyVCt6c1BNNDg4ajIyZUhKNXhua3U4T0x3NnZCNTVoM2svOEhIeHlmSTU0YXZrbStWN3dZL0xMOFZ2aHQ4TGZ5My9KUDlOL25jQ2JBSWFBallFdkFpc0M5d1ErQzdJSkNnbmFGc3dSM0JjOEpJUWhwQ3NrRU9oZHFFYlF1K0YyWVQ5QzFjTFR3cWZFU0VVVVJSeEtaSXZNaTl5VmVTTktBNGNVQ3hLSmNvb3lpc3FLYW92YWsvVWkyaUw2SzdvZXpGY01TNHhCVEZyWXRiRU5zV3VpRDBYZXkvMlhseEszTEc0ZC9GeDhVY1NTaEpsQURmRTJ6OEFBUUFBQVUwQVVnQUhBQUFBQUFBQ0FBRUFBZ0FXQUFBQkFBRlBBQUFBQUhqYW5aQkJTOE5BRUlYZnBySG9SU3lJQi9Xd0oxSFEwaWdJOWxBUXhhcW5Vc1JlVGRxMEZkSkd0bWtocC93NUQzcjFGM2p3NE0vdzdXUXRQWGd5UzJhK2VXOW1keE1BTlh4QXdUNnIwWk5jY2tXb1pCKzdTNjR5NzlGVi9nYXJWK3c3VnV6NmRPelIrWEpjV1dHZjY1Zlh1T2UzNHlvODVUbGVSMVA1anJld3JWcU9hOWhVWGNkdjJGRlBqdC9SVUl1aW5XYmpjS0k3SnRYZGVEUlBRcU43Y1RSTXAxbUJLNlI0UVE2RFo0d3dSZ2FOUS9SeHhIeUtoaXlOQnpveDh5MjdZd3lSTUJyUmMwNWI1NGJPSEZNTXFPYzRwbkxIcW8rNjhBQVJ3ai9tRDJUU1NCWGpCUGYwcDZRWjV6UXUyWmN3ZDVkM20wbGxmVHV4WUJ5d3M0NUMza2RSWit5MnUyZ0VWTzM5QTNyLy80STI5WXpUSVNiVU9uUlR1Y09JM1FsVmd4NnJpSHZhVTdQbHVmYkVPYXRydW4xUkx5UTIwT1I3emhod2xYODV3TmtQWm5sVjJnQjQybTJUVld3Y1Z4aEd6NWNZWW9lWm1Ya0hkaUJzMnFERHpFNU1temkyWTJlVE9GQm1VcXRLZld0VmVtbXJNcW9vbFJsVVVGdXBmUzZyRDIxZjIwMTIvTzlMUnhwOTM4enFudlBmcXgzNmNQbjZ0NVE1L00rbCt2emRSMzNwU3dtbGxGRk9QeXFvcEQ4REdNZ2dCak9Fb1F4ak9DTVl5U2hHTTRheGpHTThFNWpJSkNZemhhbE1Zem96bU1rc1p1YzljNW5IZkJhd2tFVXNKb1dEaTRkUG1vQ1FpSmdsTEdVWnkxbkJTbFpSUlRVMTFGSkhodFdzWVMzcldNOEc2dG5JSmphemhhMXNZenM3Mk1rdWRyT0h2ZXhqUHdjNHlDRU8wNkFTSHVJNnJ1YzE3dUVuYnVBT2J1VmVIdUZobFhJTDMzTXRkNnRNNWR5dWZ0ekVXL3lvQ3U3alVmN21MLzdoUVI3bkE5N2pDWTV3bER0cDVDT2FlSjhQK1l5UCtZUlArWmxtdnVSenZ1QkpXdmlUdS9pR3IvaWFWbjdsZDI3bUdGbU9jNEkyMnJtZkRrN1NTUmZkNURqRmFjN3dDMmM1UncvbnVjZ0ZYdUlCcnVRS3J1SnFmdU1QWHVZcG51WVZ2dVVIdmxPbCttdUFCbXFRQm11SWhtcVlobXVFUm1xVVJtdU14bXFjeG11Q0ptcVNKbXVLcG1xYXBtdUdabXFXWm11TzVtcWU1bXVCRm1xUkZpc2xSNjQ4K1VvclVLaElzWlpvcVpacHVWWm9wVmFwU3RXcVVhM3FsTkZxcmRGYXJkTjZiVkM5Tm1xVE5tdUx0bXFidG11SGRtcVhkbXVQOW1xZjl1dUFEdXFRRHF0QlIzUlVqV3BTczFyVXFxeU82YmphZEVMdDZsQ25UcXBMM1RxbEhNL3dMQy93SW0vekhNL3pEdGZ3SmpmeW1FN3pMcS96QnEvcWpNNXltM3AwVHVkMVFSZkxXdHA2T2x1ZDhseDdOcFZLMVJheUtwVms4bHp0SnVrbG1VNHlybWhvem1hZFZNcjFlbHZhc2VaYUsvN3FXMHRiQzZ5RjFpSnI1Z2hTMXN3UjlEb2MzM2lPVVJ5ak9NVkpqZUlheGJWSlhadlBOWjVyODdsR2RvM3NHdGt6c21ka3o4aWVuWUZuRHM4Y25qazhjM2ptOE16aG04TTNoMjhPM3h5K09Zcm40cHZETjRkdkRyOTR6cllpc0JXQnJRaHNSV0FyUXBzcXRGbENteVcwV1VJamgwWU9qUndhT1RSeVpPVEk5aHVaSXpKSFpJN0lISkU1SW5ORTVvak1FWnNqTmtkc2p0Z2NzVGxpYzhUbWlJdjdLRko2SGZsdXpiRm0vOTJVWjgyM2xyWVdXQXV0UmRiTTRaaWpPSE82dUxmbzBqZnI1ai95SkowazNTUzlKUDBrMDBrR1NZWko5bkxpSktzSzZTUmN4NmxzenJia3Vwb2FHN3BiQzYvY1RDSFRtWks2WEZmSDVZZDBwdVpTWnFvTGMrVFRUZEpMMHY4UEs1MnovQUI0MnR2QitMOTFBMk12Zy9jR2pvQ0lqWXlNZlpFYjNkaTBJeFEzQ0VSNmJ4QUpBaklhSW1VM3NHbkhSREJzWUZadzNjQ3M3YktCVGNGMUUvTitKbTB3aHhYSVlZdUJjbGlBSEZZSEtJY2RwT3dGbE1NQjVMQWJRam1jUUE2SFBvVER1SUVMYWl3M1VKU3JnMGw3STdOYkdaRExvK0M2aTRHci9qOERYSVFYSk1MRHFJd1E0UU5xNGMyRGNTTTNpR2dEQUo5N1BCVUFBQUFCVXJNTFl3QUEpIGZvcm1hdCgid29mZiIpO2ZvbnQtd2VpZ2h0OjQwMDtmb250LXN0eWxlOm5vcm1hbH1AZm9udC1mYWNle2ZvbnQtZmFtaWx5OkdvdGhhbVBybztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24vZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBSUVVQUJNQUFBQUJBYUFBQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkdSbFJOQUFBQnFBQUFBQndBQUFBY1hweEVEVWRFUlVZQUFBSEVBQUFBT1FBQUFENEZiZ1BwUjFCUFV3QUFBZ0FBQUE3d0FBQWhCcjBwc0hkSFUxVkNBQUFROEFBQUFOVUFBQUh1Zm5pTXJrOVRMeklBQUJISUFBQUFXQUFBQUdCUTdFNGZZMjFoY0FBQUVpQUFBQUlsQUFBREpqUWNFWnhqZG5RZ0FBQVVTQUFBQURvQUFBQTZENmNKQm1ad1oyMEFBQlNFQUFBQnNRQUFBbVZUdEMrbloyRnpjQUFBRmpnQUFBQUlBQUFBQ0FBQUFCQm5iSGxtQUFBV1FBQUFYd01BQU1OSTh5VzdzbWhsWVdRQUFIVkVBQUFBTXdBQUFEWUZoTUxtYUdobFlRQUFkWGdBQUFBaEFBQUFKQThEQ1VCb2JYUjRBQUIxbkFBQUF5SUFBQVV1UW9hbWJteHZZMkVBQUhqQUFBQUNsUUFBQXBvaFMvREtiV0Y0Y0FBQWUxZ0FBQUFnQUFBQUlBSnJBYWx1WVcxbEFBQjdlQUFBQVVrQUFBSjZadEQ3Z0hCdmMzUUFBSHpFQUFBRGFRQUFCMDJjZ0lNQ2NISmxjQUFBZ0RBQUFBRGNBQUFCZGtnN1haWjNaV0ptQUFDQkRBQUFBQVlBQUFBR0MyUlNzd0FBQUFFQUFBQUF6RDJpendBQUFBRERoZVZhQUFBQUFNN1l1K040Mm1OZ1pHQmc0QU5pTXdZUVlHSmdZMkJrWUFkaURpQmtZdUJrdEdkZ1pIUmdkR0JnWW5Sa2RBZXlQUmk5Z2VJc1lMVU1BRG5qQWw4QUFBQjQycldaYTJ3YzEzWEh6K1diSzVITE42bmxLNUlKTlJRaUY5SFFza1NMa2l6SjlFcXhZNXVXcWRmS2RSS1lUUnZKOE5yNVVJZEM0S0poV2FRcDJCWUZraTRDMUI4V1pWRVVnNkl3aWtWUUJKWUdhQUtoYTZGMTVZa1JBZkhFYmFRWWd4Z3RMTWVTRlc1Lzk3RVBVbFRjb2pJSGY5N1ptWHZQUFkvL1BmZmNYVkVpa3BBZGNsenF2dlRTQzJlay9jd1h2dnFjcEtTQjUxSXFpWDVmdnEvalU1M1VmK241RjUrWEh2TS85WlZuWDNoT1BzVnJaWHBxaU8wbExkSWhBKzVwdVQzSkc5MStGeVNrVVhwa25DY0pHWk1wbmovTGxaTGY1aHFVMzVkdnk1RDhwZnlWZUhLZWExSUNyZ2ZrQi9LKzdGSDNxSHZrZDlWRDZpSDV5dDJVTkhMRjJQcG42ak5xaDBxclAxU3YxVTNXL1ZIZFNuMmgvczM2Sy9YdjFuL1kwTjd3cVliSmhwY2J2dG53ZDF6ZmI4dzBmcjN4MzV1Mk5xV2JYbTk2djdtOStUc3RJeTFmYm5tOTVWcHJxdlY0WWx2aWtRM2JOclpzL051MmI3VDlvbjEvK3pmYjgrMC9TMDRrbjB0ZVNmNDBlUXY4dEdPMlBaKzgwdkZLeDgzT1Bja3JuYzkxL2tmWHlhNS82dDdSbmVuMnUxL3QvbDczYTkwM2U5Sk5XM3R5eVltbXJjbUpuci9wK2NmZWlkNUpycU85WCt6OVZ0KzlmV2Y2L3J6djFmN0ovdjM5WCt2L1J2LzMrOThmdUhkZ3o4Q2JtNzY3Nlh1NjM2YlhOdjFpMDRlcGtkU3UxRnpxVE9wcnFWZFNmNTM2bDlTL3BXNE5iaGs4UHBnYmZIWHduN2wrbERvenVETFVNTFJ0YUJ2dC9xR25oLzVpcUdHNGkrdjQ4RDhNWCtQL3RaSFBhMjFHL243a1RieWVLc1g0ZlNmLzd5K2xaWGRwUVNaTE9kbFR5a3BTdHBZQzJRYTJseUxaUVRzQnBzSERJQTJPbEVKNWxFak5jSDhVek5MdlBPMEYwQzVqSlkrUkdUbUU3R2w2UHN6Yk5PMFIyaG5hbzdTenZEdEcxQmZwdTh6OUJaNlBTRGYvZTlBaVJidTE1S09Eei93KzgvdG82Y2t1UnU0dUpkRFVrejBySHpqcHNaRittSGRIdUg5VVJ0MHN6RkFxeW9uU2pKekVxa3dwajQ2K25rbnRMUGxxTjBpWElxWEhkVE5ySUgyTVNORmp6TXltZmVJelUwRWVNSDdKeUJSOVR0RDdKUDFPY1ovaC9qVDNMNEpGK2w0dHBWVXpmWWZ2aWgzcjI3QndSeHZ1bGE2VlBETVg4R3FQOURKYTI5TmZtcElCN2pmeFhFZDhrSjVEZkI1ajlySm0yOUdnck4xTzdKcmkvYUhTUEZwbDBDcUxWaG0wS3FKVlZoN0hxaWZBRE0rZXBEM0tzNmRvWjlId0dPT09jMzhDbkFTblFBYWNSbXZyb3dTeG5uY1daTkM4cUxUY1pra3lzaE4wb1dVdlBXMGtBa1pGb3RSQnlaS1Ardm1jd3RhRE1zK25MdE9qeUtjcFdOeGwvQjJhNkEyVll2TzB3VHp0dFpKNE1pNU5abFNQOHd5akszMDcwY0NURG1ib3BPMWFpV3dFalI4amVvZk1Qb01maS9neHhJY3hJeU50ay9LUVBhSGxsMGJKWHlramI0YmNtYVJQSitoaVROV2lvaGx6RUlZMndJTWNIQWpoUUFTN2ZQa05hVE02K0xJRmY2MWx6VTU2YVU3dVFzWnUrazF5djRjNTkrSFRhWjQ5RFBBbmNkTHJyRWg4aXNTbVNFd0NZaElUa3dWaWtpY2V2cHlsajQxQkVmMTk5UGZWZmNSako5Z0Zkb01IWWRoMHlTTkdvZEl5VzVnOXJPajdBTzBlc3hwaXN4b3lvQmZkWS9RTzBUdEU3eEM5UTNyRzlOUjVJSFlNangyN1k4UHVzb1JUVHNwNXhsd3dmbzNSaTJqSlJ1WkpvbTBuNkRMZTBlek5rMkY4bDcyVzBDdnZWdW9TczgzRDREeWU4V1UvZmJYa1oyZ1hTM20xbDJjdHEzU1pxZEVoWS9KUUxKdWwxY3pwV1RiQThDM29NUWJqeTladHgvTmxDNmNZY1FoUFQrTVhLN1c4ZmlOajRheVpJWEl6Nkl3UnlUbXdpTHhseGxtTEk3VlR4dFZ1c0JldkgrQjlLNWJHYTd3ZUc2L3Y0LzRRR2kyREp2U00wRE5DdnlKNmFUdUx5SWpRdVpYK0hiQnNLOWdHZG9BSllMMFd1eXdVSURzd0RMVDVPbkJjQ21xNEZEZ3VGZUZTNkxoazE3Ym0wcktKVzA1bmYrS1dJMjQ1dzU4eWR6WWJUZHF3OTA3c3RqbFJXOXBUeVltVzJUWktXc3FNeVlXMXM1ZHpZVnpEWXQva3hWMHVOMDZUa2N0YWROMkJTZVEvbmxzVzFlYjdCU0xyVjFoa0dlUWJCbTNDbnJDR0h3dEl5U0xGUTBMTTZNQXdma3BIU2V2T2FqOEdUaEN0a3lBRHpwcWRMNnM5dHlydUQwcVBTc3VvMG1PYTBEYzJPdGJxcHRtOTBVU3ZtanVLVlQ4aGQ4YnRyTm92YWVUcFowbkRwVEY2MjlpWDQxNUUyNkxobEdieFB1UGQ4djRXR2JZdWdnbnN6Ym9NbVhZMnAyVVlMNDJBTWU2M291RTJZTmZGRWpGZE1obkw3Q1Fyc0dwRnJ6aVI5SXFPWlE1V2lYeU9kNDlnMWFQZ01mbytqdHdud0F4OW5xUTlTcCtuYUdmaHhESEdIT2YrQkRnSlRvRU1PTTE4WjVuL0hQb3QwaTZ2YUNZdXlZVVZ6WWswbkVoYnY5SWVLR1hoUWs3cCtWc3FxNmFyWnVVOFlQWW91M3J1eCtZbGVpVU1aenRwdThDd3JsSU1hN3pxN3NuemFwWXVHZzVNR2g3b0hGbk9EMWxpbE1VSDg4UXA2M2JUZWV5bmpnS1AwZWR4eGo4Qlpuai9KTzFSM2o5Rk93dS83TTdxWTcrUC9RVzNzL3JZdjRUOUM5anZ1MG9xNjlaRXRySW05cFlTMkwrQS9YNWx4OVhXNVYxRUN5NmlIdFpGV0JlNWlCYXdyb0IxNDFoWHdMb0Mxb1UxMWtWcnJKdkh1Z1dzbThjNlhTRXVZRjJFZFpHenJvQjFCYXlieDdvQzFpMWdYY0ZacC9OS0Flc0t6am9mNndyT3VoeldGV3gwalhVRnJKdkh1Z0xXRlZ4MGMxaFh3THBBNmJrL1hjbDhXNWk5blAyMjg2eWFBUVB5VGUwYUNsMzJ5Mk9GanhWNWwvMThyS0NtQkkrWm5KNUhjOS9GSTNTVmp1OTJWYTFwYlRiTTEyUkRyV0UxSSs2MEs0b3MxMEZXN0tUdGdzbkRTQmt4OWVjb1dpK2c5WUtyelJiUWVnR3RDMDdqMExETCt0NUQ2MUcwSGtmclViVDIwWHA4RGJQbThQMGMyby9pK3prc0dNZjNjL2plYy9YQm5NdXFTL2plVnBtbjBlc3M3OC94YnBGeHk5eWY1L21GMGloV1piQXFvL2F1ZklCbGVyZWF3ekpmNmJsVFdCYVpTdXIyQ2lZMkd0dHFKWFRWU216T0VyWmEwZjRNMGNKbW50VlZpcTJ5N0s0U3E4T21NcWp1eG5GbE42NmVPVUpUVGR0VFNtaWs2MU9LblNHczFCdkxsWnBEN3hDMzcwdnAxYlc2OFhCc3BCNHo5VThXYVF2bHZhaWlXeE83SFRzdzhkcG5mR3ZueklBT3N3dnB0K1VLMGZiS21sM21CSDZ3MnVuVFJkSFVDczlRRzl5SFhQZ0syMlBPS2h1TjdNanNUWGVxT3JSOVo4RTVzeE1nZ1oxZ0p6dkxMdHJkdEE4aTdRRHYycDArWVkwK2V0ZkwxT2hUWEtPUDFXT1FmV2hLMmtDU1ZkRUp1c0FXU2NzK251Mm4zajVFN3p2VmZmcmM5QXo5enRKbkdlamQ2ajZaUXNjME9rNmhvODdjZWZTTTFEVDF2MEtuWE1XdlFZMWZMVnY2NEZ4b1BIS293akZiRWErdWhtTlhEWmNqWW5sMnpqSEJjaTJFYTZIaDJnRmR3ZGQ0eUo1U3RxQkoxVU9CODFBQmFRRjI2VnBCVjNqWWd3U3FHdXl3a3ZydzFqaFM5QjZheGx0elNBbGM3YmkrdnFkZEZIV2RxSFc3anpyQmVtamNlU2l0STJsWUZWYjR0cjk4dnE1WUdxRmZzWEplZmNaS3JiQktTOWhZdzZiSXNTbHliSXFNRHJaRzFlenBNU09Hc1dRR3IrdDlkTVpXeWFhR3lCbS9XS3VxdFdSdEhUbGJxVE1pdHc0anAxTmdLbU5ycmE0bEl5SVJZZVVNTXdhbUt0YXpaczFKbzVOVzExNnJadzFYNVpmYTNHSlhmN1RxdEdGbkxjYy9kUEUzSnc5bXpWWTRNR0F5bWwxemVxYlljYnZndmhFcE1GUEFUQVgzYlVpNDZreGhaOGs3MnpUWEN6VVpMVit4Ni8vcnpiVjJmYnczRTh5US96VlJqMHpVV1lOM3lMYXJSK3E4bUs2TW5sM25kSGU2a20wNTEzT210djlEODIxVVJDNjZIN3VyVmJpdW4rWXF0ZTFNelRtcVhKM3EwOXBWMWxJM2UyWjQyM2RadG83M1RDVisySjNFN0pvSVhKYk5WOWJzNHJvN1M5bk8rNUZvOTRHeTVOaDhVNlpQWVllTlZNMnR2S2xlZE9XaVQyYm5heVRXRzArVXZWQXYxOHc1WlVGcGVhUFVBVVVpbjZBT0tGSURaS2tCc2tRdUxaZDU5aFk5M2didmxGNlM2N3ovSmJnQmJvS1B3QzN3cTVXaUVxQkFIYWdIamFBRkpNQUcwQUdRcjdwQkQ1Z0VCNWhETVV0QVhyM0tuTmU0ZXhmRVJyc3MybVVydXViNGxKT0VxYXF1NEpGM3dNL0F6K2wvRXpiVmd5YlFERnBNRGFhdHNoYlpjOEpsSXZFV3NiM0NXMnVSajRTY2tmQSt1TTZ6RDhBdndZZmdCcmdKUGdLM3dLOUFDWjhKVUtBTzFJTUcwQWlhUUROb0JRbXdBV3dFYmFBZGtDdFVOK2dCV00rWjZJZms4SXRvOGErMGIyQ0x0VXRyWmI3THczSnJYMndrKzlqbHE4M21aSm5tZEg2Sk4zclVaZkJqOERhZnJ6SlNqM29Ydk1mbkZucUZhM3FGOUFwTXIvZXdmdk1kbzMvSitLek1nSXpSck1xQXBYVVlzUFIvWXNEd0toYTh4VjdjYnFKN0VlMnNKd0k4RWR3cHdxb1hESUROdksrcjJMZFdodisvbHRGR1BIeDVuYnRMSmlZK2Z2T1I2K09CQU5tK2tmaTJpVTFPc3hJdis4eW56Mmo2ZkhZSlA3MUJ6OHY0ejQ2d1BMdktLTXRzRzVNYlJIQ1MvdldHK2VpczlIY0NXMWVkYjh1YzFYRzRhTFJJRzVudjhNeHlOZ2RmUGJqcVlaY0hOejI0NmNGTkQyNTYyT25CU1E5YlBleE13RWNQSG5ydzBHTzJoT3FnWlI0NDZjRkpEMDU2K01MREY1NGFCcHZwTTJrcTY3Ujg5cmFWZEJHOHptZHQ4ZDFZVlN0M2NXWDFnbjR3QUliQm1GdHR6VzY5Qk1icmRxM2tYRng4K0tjOXU4RXdRUGV6MFE5cm9oL1VSRjZ2cjV6VTRka1FUNFdzeFJ2OC80aFBBaXkzUWpRTjhIV0FGclpYRTI5ajNvYUdlUW5hWVQ1cjVtMHdOVmtIdk5GMTJYWG11V0g0cXVWWnp2YWEzb0dhTkd2bEJtdWxudmtDSXkxaE5MaE9YbWNFUGcwWkVlS3pFSCtGK0NZMG93Zk1MbmVEZlVIM0RUKytyMzVEdm5XV21iN3JXeGRYZkJBWW5XeXYwUFV5N0s3NG9NMVZUemxUUFZrOTdJanl5bXl0Nm1CR1RlcitabFI1eEEwN3lta1UzR1pCenlvSmdaSFF0RWFycXQ0TnpuTVZQMHVENFZwQ2Z6Tm1kc2lzc2UyTkdpL0VxN3hRbHFUTXZ0TzZUaXpEVmJIVU1XeDArVHh3ODlpOXJ2blhSY2I1cnVxRmFyelg5MEpzTFArNDNWM3pPdmVKN2U2ZGQrVjNyVDd6alZEMUY3MzFxMFg3aTk2b0dmbHk1UnNiYzI1Z1RhZGREdFY3V2Rwa0dySURQclcvRlhxdWNxOSsrM0xFZkJObXYyMlpSU2Y3N1phdUhQT3k2UlA5YmJEOGU5ckFKL2JMWFhtR1ZyTEJ2UFR5djA5bXFJUG5tSE5jVW1TWFFkb2g4Q0w2S3ZmYitHL0N6MllSUnJYeWJBTlhIZjVySXhNbFpZUjFOQ2JiNkxtZGZvT3lnelA0Q05YcHRIeUdpdnh6UFBzOGx5ZVB5OU15WVg1ZFAyaCtYVDhrdjhQMWtKemxtcFp6WEEvTHkxeHBXZVE2TEs5d0hhR2FYVWJHZWJrZ2o4Z1A1U0tTTHNrYjhvUmNwbXFZbFIvTEZUa2xQK0U2TGU5d1BTMy9LZS9LYjhsN1hNL0tmOGwveTV4Y2wxdnlaU2x4UGEvNGs2eXFWL1h5Z21wVWpmS2lhbFlKK2FwS3FxVDhudXBVWGZLUzZsWDlNcStHMVdiNXVycEhqY2tmS0k4ekx6dUptcFEvVm52Vlh2bVdlbEFkbEQ4eHYvei82ZjhBWGJqSnZuamF0VTg3Q3NKUUVKeE5uaUlwVWlUQlFrU0NoVmlJaGFTeXNqUXFlQVdERUJHQ1JiRHhEcDdJZzNpZE9HOFRKWVdWWVBGbVB6TTd1dzhDd0VPQ0hNN3hWaGJ3aSt4NndSQ0dmVlFWSEFhblZRbGNtTHpNamhnb3hzWDVsR0dpT0tQSThoWWRSVkVFdXZEUnh3aFRMTEJVTitIT09oN0kyaDEzUEpyc0thYm1KRzVpUXQyY3I4ZmFRNEFCWXRseVU0cTliRFR1Sk9Ya1h0YkVuVzVPZjVxeDF4dmVPc1NZMTliWEcrVkN4YUNWaDZwMkVWbnZSdHY1b3YySHA5RFAvazFnWkVXM2dMM3d3MFZ2anVncXA4d0xkYmtmRndBQUFIamFZMkJpL3M0NGdZR1ZnWVYxRnFzeEF3T2pQSVJtdnNpUXhzVEF3TURFd01yTURLSllHaGk0MWdjd0tIZ3hRSUdMSTVCd1lPRDl6Y0o2L2Q4T2hrNTJmY1paQ2d3TTlpQTVGaEhXV1VCS2dZRUZBSWc0RFo1NDJwMlMxMCtVUVJURmYzZjVYQkVSVVZGWFdIQkF3QzRvZFpjaXZZaUtnRjBFYTR5OUpZclJHSHN2S0paZ1Nld1ZTeXpZRTZsL2hQcXdYNHd2K3V5VGk1L2pyaUVhSDB5Y1pHN3V1Wmx6N3N5WkN3VGczMDVFUjhTcGtmaXc0U3Rrb2pBMGdqNXM1d21XVkVtZHJkUDJ6dmJCQ0RiS2pXcWoxamloZ2xTWUNsZFJLa2JGcTBUbFZnV3FWalZGeDhSNXZ4bVc5Vk5Hc3hXWGFKYkticllZSVVhRlVXUFVLMVNvY2lpblVwcWRvRnkvc1VXenhmcHFmYlJhclJacnJWWFc5YjNyUzlkbmI2ZTN3OXZ1YmZNMm1IR21NaU5OcHhsaE9zeFFNOUJqZVQ1NUdqMng3OHZzeGY0WC9mZXkyNEo4anZDWGptRDdsZG4rb2VGbkJtZ0hlMkNuSjRIMElvamVCR3MvUXVoTEtQM296d0RDR01nZ0J1TmdDT0ZFYUw4amlXS285aXlhR0lZUlN4enhER2NFSXhuRmFNWXdsbkVra01oNEpwQkVNaW1ra2tZNkx0eGs2Ri9MSXB1SjVKQkxIdmtVVUVnUnhaUlF5aVRLbU13VXBsTE9OQ3FvcElycHpHQW1zNWpOSE9ZeWoycm1VME10QzFpbzc3K1hmUnpnRUNjNXkwV3VjSm1yWE9jYU43akZIVzV6bHlidWM0OEhQT1NSbnBISFBPVVp6YnppSmE5NUl4bHNZQWxMV1M1WmJOWlRzSTZWVXNRbVZtanQvVFRxdU5IbjA3SS92RnZGVmgxdjhvSWRMR1pOZDMwMTJ5U2JSZXhrRDJkb29WV1NKRm5TeFNVcGtzcHpmZUl0YlpJdmhaSXJlVklpcFpKSm5hU0pXM0xZeldGMmNZU0RIT000OVJ6bEZLYzFvNEh6WE9DY3p0cnBaTDJ2VHdkYi9BMS9BUDQ5ajM4QUFBQUFBQVFVQlpvQVlBQ0pBRndBWFFCZUFGOEFZUUJpQUdNQWJ3QmFBR1FBYndCa0FHVUFaZ0JuQUdvQWF3QnNBRzBBYmdCakFIUUFSQVVSQUFCNDJsMVJ1MDViUVJEZERROERnY1RZSURuYUZMT1prTVo3b1FVSnhOV05ZbVE3aGVVSWFUZHlrWXR4QVI5QWdVUU4ycThab0tHa1NKc0dJUmRJZkVJK0lSSXphNGlpTkRzN3MzUE9tVE5MeXBHcWQrbHJ6MVBuSkpEQzNRYk5OdjFPU0xXekFQZWs2K3VOakxTREIxcHNadlRLZGZ2K0N3YWIwWlE3YWdEbFBXOHBEeGxOTzRGYXRLZiswZndLaHZ2OEgvTTdHTFEwMC9UVU9nbnBJUVRtbTNGTGcrOFp6YnJMRC9xQzFlRmlNRENrbUtiaUxqK21VdjYzTk9kcXk3QzFrZEc4Z3pNUitjazBRRk5yYlFTYS90UWgxZk54RkV1UXk2YXhOcGlZc3Y0a0U4R0Z5WFJWVTdYTStOckJYYkt6NkdDREtzMkJCOWpEVm5rTUhnNFBKaFRTdHlUS0xBMFI5bUtyeEFnUmt4d0tPZVhjeWY2a1FQbElFc2E4U1VvNzQ0YTFCc2FSMThDZ05rK3ovenliVFcxdkhjTDRXUnpCZDc4WlN6cjR5SWJhR0JGaU8ySXBnQWxFUWtaVitZWWF6NzBzQnVSUys4OUFsSURsOFk5L25RaTA3dGhFUEplMWRRNHhWZ2g2ZnR2YzhzdUt1MWE1em90Q2QyK3FhcWpTS2MzN1hzNit4d09lSGd2RFFXUEJtOC83L2txQitqd3NyalJvRGdSRGVqZDYvNksxNm9pcnZCYytzaWZUdjdGYUFBQUFBQUVBQWYvL0FBOTQydXg5Q1hnVVZiWnczYXJxUGIxVXIrbnNld2lCTkhRVFl0Z0ZSTVRJeElnSU1iS0VFSkN3eUNZaUlDSWlJaUtDRUJZUkVSQVJrZW5xTklzTUlvcURJakl1RENEaU9pN1lNN2doZ3hqU3hYL09yZXBPaDRSbFp0NmJOKzk5dnpQZFhWMXA2cDU3N3JsblArY3lMTk9iWWRncTFlME14MmlZQXBFd25pNEJEWi80dlZkVXF6N3BFdUJZdUdSRURtK3I4SFpBbzA1cTZCSWdlTjhucEF2WjZVSjZielpOeWlJcnBkR3EyK3RmNnMwZlp1Q1J6RjZHSVgxVXErRzVPdVkySmdEMzhvT0VaK0w1L0lDS1pmS0pYKy94TThmOHZEZkltWmtVUGwvNThLdTlkVnFPMGVZSGRXNG1GYjdyUEVFdHZSSU5KSjhSVlVTdytyWEY3ZHI3Q24wT0RsK1pleCtkZlc5S3AyM2JWUG9ubjJ3WWgyTXY1SmF3QjJGc0hzYnV3UUN3RER6WEY0VHZXbmlpeWtzSEo4ZUNySm54d0EzV0lxcEpmbEJEditFd29wb1ZyS0pLVjF6TXRHdWZTR0NRZEJ1OExldzdid2twN0R0dktUeGVaNUJZK29ialZUR015Z2ZqSlRLcDVIZE1JQUhtR25BNDNUNmZMNkNCc1FOYVF4eGVxd2lUWDZmVzZZMVpMcC9JYzZFNnpwS1NtdVh5QmhtU29ETG0xN0ZDVWpMK2lZRS8yVjN4aWZBbjRrL3orQk9PaVc1M3lPKzJpQnFBVGVzT0JUUmFmWDVkRHcydnkvZHJMYUlUN2pyZ3JzT0pkeDAydU91dzBIbkV1VU5pT3NuM2QwelkzZDM4ZHhQanlOZnY3dTc4ZXhlODhDZFk2dGdFalMyL2pxUHZhbnlIUWVwMGJpMWNPQzExZXFmQmhvK3FNenJpNEFjVytpN1FkenUrNDI5YzlEZndyK0xwdjRKbkprYWVreFI1VGpMK3BpNGw4c3RVdk0vMXNMQWM0c0lpNEZTVGtsTlNDeTc1ejk4akFkQnZLMHkzcGNQTGgydkErUnpwWERxOE1tMzRLb0kvVlJIZEFPbnZKTEg3aUI1a2M0L0tIdWVrK2dGRUszM1hzL0o2YWREMWxkZFBKcHNIU0lQSTdHSGs2MkZrbXJRQVg4T2twR0hTSERJYlgzQWZhSk5qWmx3czRxZXJMVXdxazhNVU1FdVlnQUdweHVRVHM5UWh2OTBiTUdRaGNnMXhnTndVano4UkZsQVQ4dWZDQW5rOGZ1MHhNYzBlOHFkWlJKN2tCd3pKbVY2dlY4eUZGVEhhRStIU24yc1JXOE5xeE50RFlqdjRUTk1DRFpOaXNYVXVmRnFML2ZHQ1h5aG1SRDRGdnFZVys3T0VuUXlCbjhSbkZtUzVpdjBHcTk4TTlONmRwQkNYVUVBS08zUXNBcktITDVxY1hDR0ZPT3hxalNPek1JdXpPMTJDaVpCdThJc0NranVqMTRoRDk1MDY5TXNmUmt6YVBiVDNpdTJoRDgrK01VTDZ0Y3ZDdlUvdElCdFc3aTZxbmZkcDZWM1ZlcmFQYi92VHE0L3c5OTZ2Szd1bDlCRkgrUFgydTFZKzk3NzI0Q0VYYjYrWjUyRTkzTk1YWHVXZnVlK21FV1VwUU9iTXhJcy9xWE5WVzVnNHhnWDBuc3Q0bVdWTUlCNHBQaHZleEh4aktPQkdtdWZoVFhRWVE4RjJxZG04TVY5c0I1Y1dQYjIwR0VQRTc4UHRMeG9CYlVhTGFBT3NhT0JTWXhHVDRMS1ZJK1J2WlJFTDRETERFUkk3d0tmTktGanI5RHh1aW1LeG9CVjhjYWRtSjhBWFJtd1hENXMxS2FPNFdIUlk0RXJERkFPNmJCMjZFWi9YQ2RqSnpNZ3BzanQ5M280ZGNqSXoxRGJpMDVFT0hWdjYwOFQrVDFVczhBY1dMdkNQbVRHb2ZPck1POHFuNXZQSjR5OTh6WGF1ZzV2NHFvRS9USmw1eCtDcGZPZmhMNHc2VWJ2OHhQRVY5NjE5OW9kMTZ5K1VxbGJYVjVNaHl6K092UXQwVlhYeEsxVi9WUUJ3bGNWNG1Hb200RVkwcGFwQ0FSMWlxQzNpb2gzRlJSTE1Pb215SWpFYkxyTmxvb2tEb21rUG42MnpCZXQySGVkT3pUQWhWY1FKL25TWWU2b2JhTVpSN0c4cjdHRFVjWFpYUml2NEk4NitZeEVsRlRwUEZlbFk1RkpyaUlaVHB5c3pMaUltWWdPS3lTcWtVNi9hVnpldzM2RTFDL2RLNjhqMDRZT0hqeHROdEFQT0g1RitlSzIrWnUvU3oxNlhCbS9jZU9UR29hVHdvZUZqSHllem52aHp6NkhMQmkvY3ZmUGgzKzZYWnMwL21udG1vZlJUSDhMOCtvWDRzUGdsMlZIOEN2dGc3d2RHanZqVDBJY2VBVEdBL0pnTW92dzRRK2JHQ2lzbWZsVU1IOGFaUi9ndHNscUZ5OEsvWHlKOXpwNVY3V0wwakkwaGZnUEZsaG9JSTQ3K0E1dUZ5WFl4RnFMSllwYVFIR0xObDdUa2ZMNzBnL1F4VzBLc1pPK2FYdEk3RFFuU083M1hFQkJLQ004c2VON244RHdkZlI3SUF2WVlraCtWTU8zYTQ3T0tlTWJDcUdhUjg1STJINTZSTFoyVWZ2aVVkT1MrSlIxN3JaRjZoVCtXZXE2Um43V2E2ODRlVjYxbEJOZ0pWTElGelR5andibFpxWUJqdlVHRG1jb2RuWmZTdVlFQklpVjZLbHRzUmJsRkxzN0hGYmswTGsydUxkT21XZjN6ejIxUDJBWmFUN1E5YzZidENldEEyd211WWZLa2txY0lMelU4VlRKcGNza3k2UUpSTFpQSFhzZWM0bWZ6dXhrRFU4YjRHWTlmNDRNSGgwREFCUmlDM0lyUjYvSURoTUZMd3VrQXBEaVBYNDhnaVRwYkNFUnZRS2ZIditrMDhETzlEaS8xakM1Zk5NcG9MVXdYUU1JNzBvVk1ZUjNaTTRyc2tYcVBZdGRWa2wxUzMwcnBSdktLRE1PNGk5bkV3MndER05veXNEUkJOYzhZZUhrbzFiR2cxc3dVOENpa2dweWI2UXRYbkVkNXZLc2I2VW95Z1pNQi94clhyVVBSL1A0Vm0xTjcrNnpiVmd5OUp4T2V1NWpOWllNczZnOFpPRGVSeElYd1JmeThSMlFJVlJjQXFhQVBLTEE2RnJQWmJPN2t5UWpUWm5oRG1EaW1zS25tRVhPTkQ0TDF3ZWNVeU5wSFFmUnhxRnRzbnI5dEd6em00a21wbmxlcksrRlpERWQ4Skp0N3E2cWhXS3JYakQ2L2t1bzU4eTZlVXVYQi9oYVliT1pHSm1EQzNlM1NoU2dwaUdrY0FKeEQ2ZFZxRHZtdEZqRVJLRUJuRG9tNThKbG9CVGFtTXBwNHlzYlNYRUFYT29WNVdidVJ0QlJpZGRoWkUwa3JJR3lSUFlYMWRtT0J0Yk9aR1NadTN1MHJ2aUw2TDJzSHdLZDBEajRuM0REamxZOTJUZThOSDJQdldEMXBRR3YyOERKaVBEUjkyaUhwbDlwbDBpL3ZUci92RURIV3p2b3VPTGFtTHZUQXJGRGQyQnZ1WC84YTRLb3JUUEs0YWlPakJ2Z0RQUEp4UXRVempjZlBIeE01VzBqVUFxZ2NUMFVXb2pyYkJ3U2g2a3I2bG8yVy9xYktuMTVmb1NvY0l0TkNKY1B3aGFwdFRCTFRTOGE3bUdBSUJRVEVoRllEbUVoR21oRHRac0NPSGFsTmhkU1dnbXBkQWtPZjc5Y0tkU3BEbkoweU1WOGhGV2JJbnpTNTNUakt5a3lzaHFRN0tsbFhZT0hlZVhQM0R5bjFEcHUrb21Mbkw3bERabzZVYnVMeVM4bFg2NDlOZXZTbGh4NHRMQmt6SU8rckxmMGVtUDlRaFRTcG1zSTM0ZUlwSHZnMGs4ejBaQUtKQ0I4SEsyVkMrSXdHZ0E4RXUvcVk2SUxsU1lVNXU5U3dJR1lMYkZUUnlNRktNVVJ3SWVzMUNYNExGY2pPZEc5SGdDK2Y1QkxRVUJ3a2hRY0FTV1pHMW9TeUhVUmIrKzZ2Yi9WUEpEK0VMZHdjS2JGazRTTWp1angwZE9abTZWeW85emZCUlU4OTM1a3RIbGtTUHFwS3U3NzgwYkxwYjR4NmpLSDBoRGo4SE5aRHp4aVpma3hBRzFtUm9ONmdKVWJZUUQ1UnJ3cFJKZGFFbW9jL3ppdHFZRGZEcGphakZKVjFDMFkwNk9HQ0tmWVR3VzlFa2lJK3dlZkloS1ZMTDBvWEtya093MEtoVVEzbks5aXRaQnQzcnNGWklhMG5ReXE0VW9xbnFZQ25JVlNmbmFiSUs4U1RFZkZrTVlTQ05wM2JDR0xjaHNTZFJGSG1qQStKeVlxZStlbUZQMVAxMGxoZzhzZnRVOEcvK00za0YvWXhZcHhRVUVEcTRrRGpVN1E3SWpvUnhTWXpvbGdubzlqZ3BHc1B5UFZSNUdabUFGOUVqUTlFR2FDWEFleE9MVGx5Y3ZPSlQxOWUrM3haSHBjZExzNTg1cmtQaVZ2NjVzUmpVdjE3SlVjK2VIcjVhK1dGN001UjRlOXVPYnZ2SFNrOGgrSjFMc3hwRGV6VFpDYWZHYVhNS2gxbVJmVVVBeGNLQ3JsdVZFNEVKTlEyS0paRU0waGhzMFhNUXZVYWFLSXRmR2FaQld0UXl3dnVGS1FFaCtEWEFPaTU2WUkxd0RoZ0dzV2lRWUJyb3RFVzR6NjJXcXhaUUxZdVRRRlFCU000ck9sZVZOaVFSbkp5RmRXRHp0SEV6bjJDeEcyYnVuOWtyenRlckR3aVNXdEp4a05mTG56NDI4Zkh2dFp6U0xmdlh0NXk5Sk1YQjY0WTFabDhTUHhrMlBzRHlzcEtTcVJwMHB1WnhERHUzUWZtZlhSLy81NURUcTcrMC9Gbmw3L1pyZW9oS25PQmpuckNHcXBSNXFvaVZDUXlTT2NhRDI1cUJxdzlvQkd1V09hZkpKTXM1SGFHSjAxbEgxZjVSdld2RDZwOHFCZFB2SGlhWHcxNzJnMzZTd0Z6SHhOd0llYVN1VkJBVC9VWHdGeXJUSmNlTU5jS1ZSa1BwWWZzK0pDZlNUc21pQW54VkpGSlF3ME9HR0JydkdlTWw5VmcxR2gyNnZRV1YzSkdKa2RaWUdZeWtBTmpLeTcydHhKRUN3ZWZiYTJpMmxnY285RjBJMTVaNTQwZ01pdUt4alExYURScDh0VkUvNko3YXgvN3BQN2t3dHA3bi9BdittWDUxOUw3NDArOXR1L2J2MHRyLzk3K0JMbnV4SEhwemVOazd2US9GTFI3Y2ZyWWJYZmQ1UjgvN1lWMkJYdG1UbjFsNU5jdnpmWUg1ano4ZXovYmZzNm1GeDZldm5ZZDBNOThvSjkxUUQ5dUpvOFpEZFlCWWtFQSt1RVFDOW1BQlZleWdRTXN1SkIrV2xPV253QXpUckNJZHR5V29LM2t3eWZ5T1Vyd2ZydXduZVVNZ2l1RHp0d2xLUGZGYk1CQlFNTTRpdVZaTTJrdUo0b0JIa21tQ0diS0NJVnN1akpyRkFpVWV1YVRKTEpyeWFDS2xkTGZuNS81M3NqZU8zWjlRUFNycFUrT1M2Y21uTnd5ZU9YSTRsUCtnVXVHZGVRK2VJZTRsZ3lTL3Y3K1o5SXpCNGJjWHJhUlBFVGF0WmRPaDE5ZDhjZnVveCsrWWZXUjdqVUw2WDRCL2syS2VUdjFDM1MreEg0SE96YklLMUpVRzJQR0YxRDdQU0pMZFZGWmluWjZZUDU4a0toY05VcFZmUDQwMEJ2dytRYkdqRkxhaU0rTVU1NXBRVGtCakMyaVBwaThUVFVJb1prR1lZT1BhYklXa1RtL1VZL2dyNGZoQ0ZQTDdPWkwrRk93RnhoYklYSG9pS09XMjlGd2dPdkViaTRqMzQrWHlxV0JFNmpQZ3V6Z2gzR242WndUWkszREVFS0ZRNFc3UnV0UnBrUjNDN3oyY3VzYmhuRHJ5WTY3N3lhSDc3NWJsb0ZIWUt3RjhsaEZoVG9Dd3gzaGlodmU0bmJzbmtBMmtTM2pKVnNablg4ZjJGd25WVnVaZUpDV2syVitGRXlROFV0WmtsTVJtS1pqUWFQc0NUR0M2V3hNTXVVSDNUSlczSjVna253VnNhQ2NJWlNtb3NtdENDNHhDYXltQUIvbkxFWU82MHhBRHFzeHhzc21RamMySWxHNVRLNUlrYlFhQW9qczAyMk9lUGVCYzczdmUvcE9hODlFd3p0Zi9HSFZseStSelBuOHJsdEc5Zmp1cFlvVkk3c2JMaktrUk0rTEt4NnFPM0poWG1STngwbEJ6UmpZSTMyWjJ4bFIwWWE5UnVyVzZla0pkcEd2SEI2LzJTZVdJTjh3TXRmQmpkczhZckllSmp1UTZtTkZicVlEM0N5eWlQRXdsWnZBS0x6SklwYUN3cGN0L3dHNENURGlvSjUrRSsrQTM1VGVKRmgzV0IzSjNpNDlWY2lWc3dVeFBZM3lqanB6UnZjZWRIODV1Z0JLdXZjQWxOeFdBbHhIejhTblpiY3RzdUxQaytIbkdZclcxUkhZTlkvN3pjVGlmcU9NR25nT1lzb0ZpcnJhRWRsMWJFNVdaZ2F2WmgxMnE1TUg5Z1AyVlhwR0FaOU4vNjRvTGVNZS81SGM4c291Y3N2cGhUM0hQOWg3ek5MRXZwdnVXZm5oN2ZOZkdqaXBOaSs1c3NRNmJOQjExUU45RDN3a3ZmUFNOdW5ReDdNZitJUjAyYkg4cHhtcFllbXpPVCsvdldsU2Q5WmVlLytRcmFOV1RYM3lLN2I5ZHRMdnpKUHpQcFdPcjN2Z2o1TTdqeHc4ZU9TNzY4YThQcS8vcU4rdGlwTkt4N2E2NHk3dmlNMDFqeFBUK3c4Ky9JVjArTVV0MG51ZlBkVDdSdC9xNjZjOC8rYTNaUTh1bTdoenhQMGJ2cGZYcWh5TStmT2daMmhBMDJnajcyL1FMV1JWUTYxbFFOVVExYm9RV2x2VXpCTFJJK0hYbzFvR1duQW1sODdaMGtrNXU2YWFYVE4xUjBOZ3gxZnNXV20rYW1OOUJWa2lUU0JudUs0b080N0NHT2dETkFPVnB6TlZpazVvMFlka1daUU91b1E3bmc3bFJnTElvRnpUQWt2dTl2b3RGdFFvUkpVclZHZFhKV3ZCRUhhRnhFeTRrMnloZ0RCaVBGN0VGZnZkQW56MXAxdjlLb1JPU0Zlb21oZnNmR2EycktKbGduNm1YQnhsUzQ5SXJmdVZ0aU85cFZPaDhBVlc5OHBIWHg2UkVzakhtOTU1OVVVcFNiWDZqUTE5cHR6YTBYYTdkS0h1ejVYUFBqWnZhZVdheGZjOWlYdTdGblQ5bFVEZjZZeVBDYVJFTkgyNlhZMWNkQUxXZUFvb2FJMmcwUWQxakQ0aFVUSEtVUnRJWVdWMXdBUzBrOExLcEFQTVBZdXQzVWx1ZnVldXRZL2MzZldHMGQvV3p2NWkzVjFEbnZ2eWdlWGZUdTQ3U3pwWGQxRGF0Wk05ZkpEY2RqQ2o5eTNYOVIwNXZ1cWxIK2MvOHVQV3F2RVQrOHlZL1VkeUc2NHA0bnNyNERzT3BOUjFDcmFORVd5N2tZY2xOUE82Z0dLVGlNQzZnVldBTmlOamtPNEJWazN4cDFnZDZVZkpwNXRJeW9GNzdqa2cvV1dUdEloTVh2cnJwb3FLVGI4dWxSYXBWbzkvVGZwMVJhMTBmdCtFeW1FdmZEVm45bDllcUFSOEFUejhTWURIZ0pZUmhVWVhnWWFIdFZmSlpLYkN0WStqZ09uc3NsbEtUVllkbUt4K3ZWZTJUeFdyVVRaSTVkZFJycUZoUE5leDRSMXVqV3IxaVBEaHl2QytTcGtINDdodndialUrOHRFZFI4Y1U2dWlZMm9SR2ZxV3gxUUdORnd5NEZIdVRNTjlYSDdEVVJ4cys0andOSGtzcEluVlFCTlp6RDFNSUEzbjZOQXExbDhjOExpRXhEUVZqSmVBYzh5VzZSdFVJb3ZNM1pKdG9VQjhNbzRibndBajVxQ1BFSWc2b0ZNQi8wTE81TmNDblNjNFlHV1NpLzJKb0JPQmVlaVBzNHBhWFF6RFV2UkxQa3BRQWxDN1FJa3FoNjJ0M2s2TWExNzRaZElOdzQ2dDJDTDl1UHoyTmQ4dGV1anNiVkk2MjJlTTlQSEdUZElQMjBld2g1ZVF1TU16N2hwYWV0dGd2M1JpMjhMdlg2NnN1SkdzcVF3Zkh6Sjk2anZFSk9OVTFaMnVaWGVGVzJoa2J1RlgrWUtjbm1LVmExeEpneDFORXIvQmdwb200SmY2VnlKcmlJRUR0Q0lCcVdPNDJqRmpHc2FvVm9kSHN5dnJxOWwxNFdFeVhyK0N0LzQwZnBBZXM0YUsxUzV5b0UvaFN4Vjk0bGMxNklDVC8yM0p4ZFBjSnNwMzhoV0xuQWQ5VlV2L1BlZ1dtbU9pSHY0dGFoRWk2UEtnY3BKaXhjT0ttaVE4eks1Ulo2YVZETHJodWZzWGJLdVpPNmxPK3VwODBkVHhCM2R3N3pVVW41azdTYUV4MVN5S2ozYVg0SVAzTlVVQ25UYlZ0Y0dNS2k2V3dVVTNaS2FPSUFLV0xnay93UzVhR0E1SVQ2dFdONVJ4MjhMekd6NW5qMG9ycGFjVVdsNEE0NmdpWEJxeHJPQkNMZVBDRGxvb3BWNU9CVlNrYVVTeUE1N2VEOUR5ZHVPK1VDZFQvbENpd0t5T2dkbElueFpuRGZuajVFZ0R1dGhNNklKRU00RXQ5bXNFTUJiOGFxdWZMNDdNUjZ2TVIwZHdQY0dFRUk1V3NUM1k3aU5yd2dlMTRiZGhQbjZ1dEw2YS94UTBvT0lMbVRGNDA0R1cwQndHWlVzQ0REcUx5Q0VNVnVxV0UzVXlES0thbzJ6cTB2RUowaE1Pem4xV1hkcGdVcTIra01aL0FlUFdYMUFEWDRROXFpNkNQV3BqTXBuZVRNQ01XSXh2NHFQSm91UGFZV3ZhWlIrTkhwaDROdnBvN0toTHFWQi9Ta00vczU2NVZGVmdsWjFXWkxmeWFWbFcyVVhEczdWM3YwS3NhNThsbGwyajc5NHQvYkQyV2Vtbm5hUEhQME1TU0RseFAzM1hjOTg4OUxMMDNkUHM0YVhFK083OTB3OUp2eXhiS3YxeStQN3A3eExqTXR5REw1T2N3TndmWGg3MXN2UXhvL0IyL2d4ZE93ZDZMeHE1bWdPNG1zRkk5NThCOTU5VFhrWms4VjVjU1FHbEtLeWtDNm5RZ1Z3K0lpZDVxdWVrdTBtamJOVCtSTExMbjM1N2tqU1RQSGJ3NzZjUFNMQXpUNzgzM2oraGN6akVUbjlqL2FZZ1EvRjVWTjBYOE9sa1dqTURtWUFWOFprWXdXY3U0ak9mQXVFQ2ZMb3NZb2FDenpib3ozZWh6OHRpTmFMcXBSZjhaa0FzK3NIOHBtSi9ybENuTnpLV2lMQnN4REE2UjBHL1VwRHM4eFpsRjZrNkNzMFJQZnpPd3lVSDkwdG5vN2grK1pQbnBMK1dFT3VhbHZDOVdLb2Z1YlZzeDhZb3l1ZC9QK0MzbmN6RkNOWmxlVnFsNkM5M0t0UnFrS2xWakFlMG15d1U3U2Fjc1p2TzJBeG90M2pSYTJDWFF4cGlBbnphelVBNVJuMHgzVUp4TUdPTGllb3dHUG1KaUZ5bkN5TVNHdGhDVFJha2ZNNEhQY2QrdTVlY21DOFZTZm5rNjFkQ0g3OGhPVldyUzNxT1hiL3R3NFR3R3JZc3ZJME5pRTh2ZlVIZTQ5UEJYcThGZXowWE5EdzVKSU84ai9yZzRoSE9WbWhTaUltT2tEOVIzdVVZWWNsRFNqZkpMamlOc0oyUEV4eHAyYmhDR1ZhL0hWVXQ0SkxiR1dLeU96SVU5NHpNS2pIU2xBVWFjcU1VQWhVNWhialFPTWRkTWYyRyszOTRldDA3MTljOUo0Vy9KT3EzVnY1bFlxOFI3OTIvNW8zclgzbmh0OCtscysrL0tQM3RnOUo3UnE2ZlhUcG1ZSHJocTg4Lzk5RnRkdzRZV1BMTXZiZlczSm5oMjdOdTY4bDcwRzhIdFA4NnJJT0c2Y1FFMUxHK0REL25wU2FvK2hqU2VFQ2xwbTVGRU9JQnRRb3YxZWhoYkxUYTBKYzlnUytUNG1wVVJTTkcxQjlVRlZHYzdiMFlVZzJFNTl1WUlvVTdnT29yTXlVOU1DVjdST1Q0T1FzK2pNWmtITWlVa0JtWnFWY1VoUVlEMWpsS0R3c0R0Z0M3dDRhUXJ6OW5MbzZSOWtsbjUzeTA1ZzUyQU5lbjRjMEc2VHNTSjhIVkFlbERhV2ZaNnIvQitPVVh6NmsyVVY5TnVqSS9ocVhxZUtPcmhsRlQvZ2NqSWE4bG1lWFQyUGFzYjJKNHdSRGc3eWRVdWZVVjhKenFpK2UwWTFScmdVZTBaZ0p4U0sxYUgzMlV5S2w5bE1NalA0ZUh4WUdTd2FyMHNvOEJIMGlmQ1JLcGVoclpUemFXa1Exay8vancrWUZTaFhRWElPWUNyMkl1TUh4RGZRWC9LVEJ4aXJQUnNEZUdVUG1Ybyt3TUdJdVY5UUdVZjdMVVk1Rkw4M3JLcGVWaHFOZ2J6WFlKbjVoTlF1UzdXZUdUYlBGc2laVjQ5aVQ3V25nQk95M2NLNXpKMW9iSHdCZzlZWXpwTUlZV1pheW1DVjUwVkl5cllTSDBLQ1UwRkRzd00wMFROTUZ5OTV6SHhyT0pzOE9yZ0pNMVNCemI4R3o0TGJaSW5nUDZ5TTVUV1ZTZ3lGWU5wK2p6bkk0cWlITFNnVWIyVHNOT2drKzE3SnFtSHQ5MHgwTHVhRU4vdmw5RFBuZTBNeThONzNLQlZmU1hnOUk1OWp5bDJTSWw1c1VibVg1Z3dES2VvSXBlS2I0VFVlVUd3cVh5V3dWNko0M095QVNycUo0SFdZL2tJUjlJNTlRYisvOTJ2ajlETHRaTDlYeTJFcE9BZFZOWGNXOVZxU3N4SUFIN0g4YmRIQmtYcHhMazVIRTFuaURUT0M0QjVNRzRoRzRZZ3VOeWtYRmQ2VlNCVEo4T1kzcFlUL2lEUFdwdC85K1F2aFp6WjdpSnFuVkFwNW1OY1R3OSttUzhsemdWVmJMTEdkZDZNZWxkVG5xUGt3Qm83Z3paSnBXUmdkSVdpcU9MRGRJdS9vT0xWcGlIaTBHL0RtTU00WXZHZUdUTlRnTW80UG1qRi9KL0tHY0k2Y252WnllcmpzRHYwL0QzNkk4eU4wWnlXRE5qaW9ad1NKRXRrL1NjdVgyZ3FyYXI5Qk9RemVpTHA3Z2YrR3dtaVdtRm1yb2RxUW5EMW1JYXFPc21ncmFKSmhUa2N1Sk5xTWdpRUhsMGRaSmgyeWZMN0Z5VjZmV0tObmVJeG1XVEdkbjZ0QXZiT1lNcFBpMkgraGs0MUJGVUR1RDBPc0Z2S1BhYjhEZlVlK256dWhSM05sNDZIVUptSWJvWENsalpmOW1Wb010ZzlJVS8xYjJ3ZmNQNjU3UDMvLzc0NUpvUjNkNWVjUE1UVTI2c0VSL1k4RjF3MjRidHhMY3UyTGJ0bW8wREJwVlBydGtUbnJwdDRNVDgwamxsNCtkc2YzeWE1eEU1NytiaUtmNnc2amhqaFRVYW91Z0o1bWhRQ3VlWkNqU3VTcVgwUmpBb0tPcytWaUVrc2phdkY0TlVLTFAwTGxrQlNxQkJLck1ybGM0dkZjUjNRQzl3eFJFOUZsM2FMTlVqMG5JZG5EMGlGakJLeGU0ZCtTSlJEZDMrNUtCQlQyNGZLcDNicUo3eHhqaC9xT2M5eTh0dVhUMnRyK3A0ZUFCaFN4NzljTmFNRHhmY1V2OGxxNTN6d2ZnejcxZTlOUG42WGxPMjBqMDBEZVpTeUxkbEV0RGVwbjVuQVJhTHgwbm8wVDJXU0NFM09VT1lOY0NJZWdIc2JUV2pzZGtWRlFKVEFCUnJHd1NTRlJRSEY4VTVtZmI0MzU4NnU3VlA2WE0xazk2WVZCLzh3N3FiN2pqMDZMSy9MMlQxeXk0czIzOWpXZm4wRDJhOEt2MFc2RGxpN0ZNWFpIL0pESUJsUVNOZTBmOHJteGJ4RWJ5bUkxN1RLVjYxalhpMU9VTittNXlObzBrRyt0R2JaTHdhYkloWFUzdzZ4V3Q2UElZUU5IR0sxN2NiNjB0em9VcUx2dDRDR3YyVC9VNVV4TTVBZkJMOXhxcXFGNlVMaU4reHZSU2NJb0wveXVvcFF0bU45WGtoU1VJRUEwNTc5Snl5dFhMT0J4TitrWDJ2cC9nK2dGYzNrOEdVTWdFSFRzT3NWYWFScGdLck5jNUJyVmJjQnBsUmZUTEJDMElGNXNmRTZVQ3FaaUhLNDFDekVheEE3d2xDTkhpSi9qTFVBRFRwU0E0S3p0bWk5QUlPZ0o5Vzh0QXJveGQvT29WdGVNYjQvYm8vcmV3ejZOQ2k2ajg4ZnRzWTRKWWR5aGZkc2ZvRUczZlB3YVVEbDV4ZjdiYnMrWHhEMTZIVnBZdmUyM3pyNHNtOXZrT2FxSUlKdktmNkZIVFB3VExrQVFKUSt5MCtrVkdGL0ZZdmloNk5DbE5KL0RxTU51aTFNQWVYeCsrZ2NXKzdLZVEzZXdOMkJ5NlQzYXJEcUh6QVFZT1JEbFFWNGhWVndWZllvUWozcVFOM1pUS1JOWWVxbFJWbEMyNi9jWEN2bXRGa25QUlVGYmVyWWxTd29peCthT0pEajR5c2FPakw3VUk2a1lMOEFzQnRDc2lVc1V4QUI4REplRzNEd2RBZTBhNEJSSHJFVEU0T2xnQnFVNEZDVWkyb240dmFWa0FoQnBNY0gwbGxJcmgxQ2R0VlpudENaajZsbFFTN2NsOXNZMGFxMGNZM1VnMm9ZWVdLK1VxakJjQlgxQW9Ga1FnRndXYVlNWEJSY09qU2ovdFd6VnY0ay9UYlI1MWYvMmIzRjV1bHMwT0Rpd2FPdmVlVm1sdlhUTy8zd0p1ZjdKekFkaDMzNmdOOUh4cjFmc01UbjgxYnVLNXMyWWR2cnZqNXhsbXZqcCs4cTZwVDlhcEJVM1lQRzZya0Fld0ZXZHFWN285YkZIMUFKMmU4aVNZVlVKYXBrZC9ZSXZ3R0hRVEFiVkNBNjJET3lHTDFWaW84R05FVUNVMGhrNkZwTExBQTFLM3FFUGFPbk5Yd3h1ZFYvalZQdndkTVpNYkpIL2FGNTdEak5yeCtaSDE0STkycnJ3TkFYVlhicUIrL1RVeFVXMlI0bWNpcENPU1ArUm12cURHRllrUXVCaXRnd05kbjNsT2x5bDZ3b1A0a2I3OXdHcDk1VVpJQzlKbEdSa0J0d1l5UE04SGoxRWg5Qm8vSTRsNngwc0NGeVN0cVRXZ0hvSWNOaFpnejRsWlFaMmJrNGhoc1RwdmkzbFhUUnVmbjdaLzVnL3JtRy9sN0x6eDUzLzFhZGMyQ0JiRzR4SnlLcUcrQnAzQXJqZ1doMGJIQXQrQllJSnhqNzBoMi9qeXBpQnlmTFkyUVZNY3ZyR09ma2J6aDNVUzZ5RWc0eG1GNGF3OWpjQ0FSNlJoUjF3b3NCYjRhWFN1SHExVEg2L05rdU5RaG9PME1qSUJSZlVsSThQbm9CcVFCSEZBQlJTZnN2UlJ2aEcxa3lLdWNJUnZWQ1NZYUVMUENwUUFqWUdBMU1ZUG1jd0w3UUhGcHRmcU5HS21nVXpJb1UzTFEyTC9yRWlMQWl6UktETW1kYnB2UTYwSFJNL2ZjS3g5VmJWenkyTDZxNTZYdjN1RHR1d3Q2ZDgrWVZmWGxEd2ZDODlseG0vZTgvV0o0SFR0NS9aNFRhOE9iWW1nVzVtT04rQ2VSWmtsMHh3TGgvaFBVNnJnOHRmTDJOeTRoVnBrWGJ3WVlCQ1lWZlJQR3FBY1JJVWhDS1pjbVErQ2srU051SE41RnN6cEZ0eFhOU3VxYlNITEVKSTlFK0c5RXY3REtNUW1VeVdSYTJlUHZURnJ4NjRMSGZsczU4ZTNIYngzNzIvWkpiMDVwQ0V4NWN4S3JIL2YyOHNITEx6eTF0SDdGb0dVSHg0UDhtLzcrakQxRU4vMERxbGVBcm5hWTRpb1RiZjZvU3RHSUx0QXJRTG45Ri9RSk1LSWNzZnFFOEEvcEU5SXVWVVVvUnFFSUgrZEttMmdVeUp0M1VkNnN6Q0VxdnJYUk9ZQU1oODM4cjh2dVFuU0gvZk95Kzh2NmpXejdsbVEzcFZuMkRPaXhBdE0rNGdWQzZEVUl2U0V1cEtTZGlZTE1JWkFCMFl5elJsNWExTkhsOVRsb0FBSm9zOGZNS1kvcmRZYUs5Yk51NHUzU1IwOE9LaU1UYm5qdzRFeHBBTXJhaTZlNTZYd2VVMGdNVE1CSGZZK2FVTUJORnhzcHM2UEg3NFE5YmczaEJzZTh4WGEya0ZnazU0RjhmL3FOcHpFUHhPUTNXL3o2ZldLTzhKcy9meDk4cVRPWTliYjh1amo2YnFUdkpuejM1MWpxY25QeTRXc3IrcDVIMzF2amV3RHVwejJXOWxpbTJnUnl6OStxMko5WDdHOWRISUIvaDkrTnhhaUlHNHFaSG5GeGVYcUQwV1RPeVczVk9qODJsNWhjL2s4MEVTWERLVHMvMUVJZDUwNzFvZXVqblZWTVNzYTlsY3BSNTRjektibGRrOXlVQWk2M1FDdm5XTG8wT2JMcmczZWxxT1RFMHFvdWRXK09YWnpXdHJSWGgxYVpKVm5kVTF2YnpmdFczblhnZDRYcm5odnpzTDJnVFdsaE8yK2ZPem9WSnJ5M2V1S3B1YVVMeGxka2RXNlY3VFRINmQxQ1NtSmVmbEhxQXh1NkZRNjQrKzZ5cEhZNVNjbUN5ZVRLYmxOY1VyQmc4MjFJQjBNdS9zQWVWRlV5ZG1ZUUU3RGcyaGcwOG00RUE1enFRaHJnd2c2UDN5WW4vSm5rS0ljdGt2RG5OM29ETnByelowUEZ4MGtKeFNJNzRoZ2xaNmpRcDJRQTJrR05jK0NzQ29VaEs2dklCR25KQnpmZFdqTGtvUTJnQXBIK1VxQWlQUFJROXRDc0o1OWd0eUpzVzRDbjVmRjJtYThpUjVNQlZLc1ZBTkdwWW9zSUczU3FnQ0REOU1nNGhhOWl1cFhmZ2s1ZU5RVkk4YTlFeEdobUlZS3lCVm5xKzFWVndGMi9JTFhzQStGbEcxNy9jRDFiY2VIMC9rOStsUG43Z0l2bitRRUFSNHhmaFZ6RnJ6SmdLbGxJRmsrVThnZnk5b2E3dUEwWHZxYjc0THg2TnUrK3hLOUMvZ0cvU3RWRTBwbDBLWVczenVPa09RT2xnOUlCSEtDR1c5MVF6UzIvOERVM3UyR09ESE1GeUNRZnpZdUk5YXVRYS9PclZKQ3Qwc2laWkRnWk5sMnFJbHRuU1U5S2kxazd5MGg5eUc2SkM0ZlFvb2N4U3FVQVB3VEdzR0I4UkVFSnBqY1ljVk1MSGhUUWpHaVVBNzVBRENKcmlFNklvRkNSVmN1aTBxa2tRS2FQbDdyMDJqUmxkSFhHNzZwdW05b0pKblVuOS95RnQ5WXRhRHNvZDhKOGVVN1RHSWFUWUx3WVA0dFJzZU9vcFgwTmZwWnA3TS9oZks0bWJHTFBGSE56eW9zYlpwY3IvazdwYzY1U3RRczBwZDh4b0hRRU0rUXNBOFlUSkxMZkk4NkQ3dkVVOUJNVWVQeDV4L3dxcjVnSVpHZnppaDY2YUtDQmlBbDV4VFJWemtYRGEycDdzVXorcUQ4RFF3Y1RScFZNYU5JUmZNQW0xeFR3OEllY3pPbUZDOGFsbDIrYmIvcmRoUDV0M2RxeGQ0OGZwWFczN1QvaGQ2WnhxNGNXMmNZdFlMUDd6NTJ6L281cFkyOU91TjZlNjIzZnIxL3hxam1QcEdYTmVXaDE4VTAzdC9QbTJuczZPdmNaWG5YRCtqbHo1Zm1jbCtwSkdmWHR1SmlvU3VZTzBaZVM3QXBiNEh4NU5BVVY4L1VBQjBNaU9HaEwvVHlJQThCR21vd0RweWZvYXNTQmhxcW91WUNESkFVSG1VaE8ybHpBUVJyVnc1eFcwWlNFT0hCMVU4RkVNZlVLUGdyNDNLSVVEakRnN0V3YzFDNnltempOMUdaem43K3RQSDNjZ2tMQWphMW82T3B4bjhQRTI5MThVL0ZxZWVLcml2djFhdzhUdno3aDVySFQ3b0I1STRadXFCcmVwN09ENXU2U256ZzFlNFQ2WW5GanFlTkNkUmExVVF1a2d0S04rbUtEZWpPbVdLTVBsaEV0UnByb0NGdFJTVkN3MGN4L0dsbW5DUnlZUDdvNXFiUkhxejBaV1cxY055aFhyZU5adG1iQWdQek9WdnJlckdhcE5NWnVRRGNYSnVhb3lSVUtsN1RlT2cwdFhGTEw2VHBxVDFEVFdMaWsyQmFGTnAvTnNmZlIyU21kVXZqVDI3WmRzQy9tbGpXTVhReGp6NzU0Rm5UK1RXQTM1akJuNWV4VWY0SXZvR2FwOWkrNkVpMXArengrdHc4VEZNR0VGWGsxM2hCVldwOVB6SUpibVY3UmhLWnVybXhUdXFoTlNaVnVHMVc2VVR4cnJDR3hsU3lldTUzODVXZWFwcGxvcVZNbHF1WFNIUzB0QkRMUmR6TjlkK1A3N203di8vSUsvTmlBUDA3Q0g5ZGw0THVxTGhNL0FuQXJSanBub0RxYUFTSjNwMHByTXJ1VE1qS2JTRnAxQWxxdkxoU3NXWWxZMDhFWWJGRjNUV2RTNU5QUVNFSXU1NHk0RG5JMW1VVVkrWEc2YkprWjdPekh6eTFOVGEvT1h2SFlqWjBuM2JDbFZkcnJ6OXh3eDZGSGMxdmxqbXI3N0IvSDFkNi8yUmI0aFQyKzVNS0tyYnV6bjdpcDYrK0Voc2Mxdis4MllxejZ3T2ZYa1NULzRtKzhYSTFVVC9mTll1QzFtOENtUzJhbUszd3BrUXNwcVc1MHU5QWlJTkhLaFlLOGlqRVk4LzFZdUtYSC9CU2FMTXdlODZ1Qm1kaERmcWMza01paU1FMU14Z1NDUkxjdVA4QW00ZzBXcEN2R3YxT1JWaE9KSE1XMHFwUjBQMlJ4UlNEUUZIK0RFa1RSS0M2SGRNZGl2OS8veUxROXk5LzVYVm5mWjZjOU9haWFyUXl2WlNWZkh1dW9QSFA2a1dtVFJuVXZIektvK3VEWnl2Q1B3NVQ0enlsYWI5S09tY01FMnVLY2NzQ2FpRk5TeW9JTWFSc0g4MGdERlFIbWtlRU5halgwUnFKUDFDb1RhMDh6djFOc29VQUtqek5JeVlBWkpIZ0RmQXArNDNFK0dxL29CWHBLd2VDNXJoMnVKWk1EbDNtdGk0dEZwMVp4VDFDU3o0R0p3ZlE2TWtybUM0dTdFZVlHeXBJTFBxaCtMeTh6a3p0OWkxcS9iVjh4YWYzR0hiWFRLdHFVZFI1Zk8zVGw2UTdzRGVITmVqVmJFZDdacnVIRkIvYmUybi9JTjJzL2xBNFZrbk9WMTNYdGMzM2xGeVNwOWEwanJpKzZmVlNYcjNkWGRydXBjNmZLL2QvUG4rMTdjajFKLzRIaUJPTUluV0ZmTzVrcHN0WWZpU01FTFlLSk1hTFpKMXBBWXpKNGczWUh2UUVxbEYxUm9Wd1lNUE5id2RxR2phVDFCb3pVbFdFMDZERFhNV0F5NGplVEJiN1p2VFNwdzJpS3hDSWNUVlFMbUsxRDlpT0JTTVAvOVp4REpKYTVQM3lDTEpWS1NGQXFHU1Yva01XcTFXR2ViV2c0VlhHdzRpS3FCQWNyWkIvazFvdjlTS0txSC9WckpET051WmNpWnc0aEpjSkh4SWNQTWdJZEdWc25USml3QStRL01EQjhwL1VLcC9rRlFQTWU1bnBtaHBLeGttdVFzeU5FTTZiRjlLUWNwSjBqNUc5blFaRVRLVjJnWG04ejlZWVhLOVZzdmZDdlNNdFpCU0E3V2dzOTlGb3o1MGhNeTIzYnNUdk5yYk9Lempna0QzT3VZTjJwTXNRbFoyYlJ2OGdKdlRrUjdWbUpIRHBkY202dlVwc0Ywa1kyLzNKeUN3aDZzRnpPU05BUm1mcThqUXY5QnpiTU8zdkhMVGNmdm5mcWZadmYrL29WdVBQSERmUCtma2YvbTkrOWQrcDB1TE83cHNPU21iTkhUVm5XWWVuTVdhT25MR05QbDg4VStpK2F2T2p1d2YxS0tnYmYxS3ZLV3pSM0ZMMDM1WEY2cjd3dnZWZlRxbnZ2bFBUaHZmQWpiUmpERWl1L24vMUJWYTNrdzJLMURlL0RBRVFDclNoVnJwUWxRWkdRakdFUldoQ0loYVhKMFh4WVRMREVuRmhpZldMZkUveitEZkFmclQ4Y3ArUW9DS0NyZG1MbXluUWFkTXBzaUdaU3B0RHI0SFh0VGVpYnZjNFlDbWJuMDh0czFLRTYwNEd0c3V5eHlrSDNBbmZJWDBETmI2V2FWdXlDQXFGQXNQYlE4U3FuS1NXN1ZlRjExSWJOYjQvM2RGWW1vVlZHWG9mQ3hoQjhXa3lPZ3hKOXh4d0hGdE1mV1ZVVDR5ZEc1STZiY29EWWlaZlkzcHc4NVlCMGV0Vzcwa3R2ZFBXVDYvYStSanFKZnVudHZhOUpCMFRTK2VObktoNit2dHY0YWRQWHYzRHZqVFdkaW52TnYrdVpqOWpEeTRudzlyUjczNUorWExGYyt2SGd0TGZKN1gvY0xSM2MrUXJwOG9mZHBHam5LOUtiTDYzOXBrZlg3bU1DYzJZRmZVWEYxL2Y4aXFFNG5NME9ZdWVxMWxHZlZpdm1VU1pnUmJ3WkkzRTNrUmhEL2tTcUZHSGVhUTRJYUhwRlF6MHE5QVlHaytVYzQyUTVQMHVYNmZVR1hYS21LYVYrbFpKWTY0OFg2alJHYTZKY3VBTmlUSXdIaWViUEVRSzh5bzJwV3hxclh3ZUdxVUJMTnpIeXpMUVlBVUovWUV6NFp6YkxTK3pqazByTDcvemRMYU1TSncrN3QyZW5rcHNldk5NN29HdnAxRnVHWHorS0hWUldSbTRQVkx2MHQ5emEvb2FPUFR1TmtkWU1HTGFuc052Z0c0cGNYV1FlTVpvWnlLM2w5b0xOWTZUWnppNGQwU2dmbzBuZkV1a1VjWmVVUnk1WTFrSzJ0cGRtU3pQYWs2M1JTOWszeGxwcExyUUtKSW1TQ1IycEt1TjFjdTRSMWdkWlFZL25JbkpCeVQzQ3lyRk1ZUyszdnBxYmU3ZVVReVl5LzFJOUY5OWtiN1JqaXBuZlgzNTNlT2p1Q0hyb21nYzg3UkUwRHdxd050NWdaakhkTHBtNFhUbzEzeTdCZG02bUFyNjE5eUxqSzhRNlZEZXRRNDNaUDUzaGJtRTd3YnFEYnA4Q2RNajdXd24rdHNYK0JLdS9EUkJEZXcvTitVeklwN25GeFlLLzFUWHRKQ0trZStVRUVGc21sK2xXMkY0K3ViYU50SkNVTGk3cE5INW8vZVF6Ui84NmFQeklPODVleXlZS2Y4ditVTkxwOWtIanJOS2JwRUQ2a015KzVjWnVOMUhmTUgrWTg2bUtyN1JXbWlacmRaaXQ1ZytQSFl2MHQ1SXI0VmpRWTNXTWc3bUJrY3NqYkxEdjBMdzBSdE9UOU5hUVgyOFJMUmhWdGRMY0pOR2lCMjJRMDJoWnVxbXczbGRVS1E3TmpyUmFOeU8yWWthOThnOW4vd0Qvcjc3dmprSFQ4TVhQbUJiY2ZqKzg3aDB3YS9aQWVBRXNUekZ0K1VWOExzekRqTkVpOUpIUjZlZ3hxZDl2OEdIcUtRYUFlSm9yd3B0MGNuNmdpYXAxUmxlc3VKZHpVU1BpWHRIcDVEcUVJcmtjSUZvcytSUlgzNkFtYjQwakI2Uk80OXBXVnJKdEswbU50THhTV2tiRzRoNVY0UnZQVUR0RERYaUtBK2o2Uit4aWc1SWZxMGRKYktHNDR0RjFZNkdaZUxEZGFENlhDZk54VkJxdFBzNUlzYVhYd0hjMXJ6T1l6SlIxdDhmT0REcGlTOWVwQko1cHFDSkRwZWQ2c2p1a2pkSW1VazRxcE0vSlVNeVcvQ09yWmJVWEZyTUc5czN3T1ZZZlhoMCt6MXYrNCtFalpCSEk0cjJSUEFEbXlua0FOcGVHTE5vKzh5Uy9uMWk2SGxGcVZrRll1R2p1U3BIaUYrTFlhSEFseUZQcXhpbXBnUVNRejFtQ2pIeVBpVlN2Mmpwa2RjYnNFZ3dtanlNNXAxZU9pM3Uyb1pZN2ZlQzcrbXEyYU1SQmVaek5ySjU0MkYwQVowRUVUakFqcjZFQTFVWUxVRms5TGF3Z3BFVDZnSzFnN0xGNUQ4WW04elZILzZYSzV1Tkl5YTVCNitxSlNYcjFQMzR0T1dZMHlPd2RxbzEwanlaZ2xoMTJ6QWk2bThoc295ZG9VMUpYRXBXNFhkQWlNMnNMYlgrQjVTRDRqZlhTL2dGTzdBTmcxS0RpNmJaaDBpWmZIQ2x5YTFiNkQ5d2tRejJhN1I4T2JKbjl3QXY0R2p4dGNQbmsrd0tUVWRxeXFUTkYveXg4M2ZYZzdDSHdvakoyRHNqWUhSRVpXNlFqUmNSQnN1V1BPY1F0blNvaE4wcXZrSUVrWHZxT1hzNkgyL1BhU3dNczBvRDJqWmYvbnhmODM0ZVBaY1pjL0lIQzU1S3JhZVZjQzQzY0pDTVlIK3RYU3BJVExWdzAvNW8ycEpHMUU0MmxMbFdUYUlKZnk5VmU4WjVnb3N3c3NFQkdqZEVubFJuckJjVkVqU0RYQmpDaW1xWUdvQm11QktXS2JENmJCdE5nb242VkhEUkZ4dlNlamxWZUNYcXM4dnJpcFg1RHYxaDk0RmV5SGlpV2xua1JSZ29xWlY3ZDdwMzFIZS9jaGxGMVdqdWs4ZERhSWRNVnE0Zk1IcFR4TFZZUDZUQkY2OUlLSXVuc3JPREEyRElpc2gvVHQvNnJ4aVM1SUE0dUhUTTlPT3RrN0pBL0tZSWlNcWFKamlsY2NVeXJSdzYxdFRobWtjK1ZtZHRzMkxPSHl3NFBYN0V5ZHVSdjZ1c2Zmend5cnZvbk9tNEthbEdYR1JlNG9XaUtDOVVKcGtRdEdPU29vYVY2c05nMkNnZ1lLcUlocGJncFFOa3RPRWliTGNTUnFKKzBqM0tWSDk4RVN6VzNEV2pUMlViZmNRdktNTzlYMXNmS0RMczgxQWFzQU1SaVR6Y3ljQytOQlJtT0JVMnkwV3l5WUNGNzBDb2J6UmdPTXBzd3JJSXRNNG92ZzJIRnByNTBFcWZCeEc0QzgwYjRMNHJmVHdGS0IwalV3UXFrSmgvR1Btd0FZQXExREttN1BCM2xUZEFwMXg0NnFVYzFVbnVJRm5haUU1UldqZEZCS090SUFXR3puZGNiaVVPdXNmU1J4aVlzbU5xdFFHdDNScFRZY25aT3h4dW1sOTU2M3cwZDJUbU5jTThxcVM2NXVVTmhQOVdZK09GZGJwazQ4ZGJpb2M3NnB5S3pPTzNyVjFMbzYzZXpiTy9sTVl6bUpNMVJ0NkgwcE5FcHh0ZWswTXB2OVFaTmxqaWFxcTdEc3F1NGFObVYzZU9QTytZWHZORXFxTGptbFZjT09SR0VORlpld1lzam9Pcm1jVlY4NzRaRm5Lc2h4TTFxY0lkWC9VenkyYllkbzlWWUNzUTMwam9wNlFOYU81ZUJsV2xKTk10QkZ3cWtNcEZXUVFZdW1tdG1pUS9KMldVR0J4aFRHa1liNzQ0cG9PT2IxYytaaUliTExjcFJTdWpxbUlzemJyNmtnbTdheFJjWFRGenppblRpZWJtR2JzckUvazBxNk81OVFDMzl0ZkFyNFJEcEU2bTFPQW04Qm11VHIxcTVacmxhNVpyUXJISU5PVjlNOVZyWWdVd3ZnalQxR2NyeC9pMXdBRGVNaFdNdGNzSW9IS2tLSDR6QTRRWTRyRmVIdzNZMU9Pd3Q0SU55eUJoUUd1b1Y3dGdJVFgzOXdvVnlUU2wvRXZpTWdWTDg1Q3REZ3hxOXhSYzB5cXhHOEVaeStTOFBIZFlkeGNFZU44dk15RXh0MUtCTlprYU81cEFybkNjV2kreWkxeGZGd0UxNURnczhrU0g5WVMzUmY1aXJ4SmJrUm5nMEZZMTJDTURhQWczNjFEbFdhUTlreTBRdnJnbm9RMTFEQ2VPM0wybVpHNHYxY1d4bTQvTmlLdVMwMFFvNWZCNUhJOFVhK2p3TTUzT3c1bC9WVk5DVnJxK09MRExMWk1PYkJkWllEZnc3VDhtMmx5dm1ETkdLdVRqTTQ5RlFacXdxVmlDa0s0Y2h5ZXpEWmU4T1c3R3lza1plS2dWUUtrZmJ3ck8xc0dZSXE0RzVLV2IyNkVmVlVqK3FtM1pJaXRoZ1RSeW9pQnRzRGFhRmxURElLMkdNbWtrNE5INjJYWlJYMDNZUm9sc2VHYTl3WHRPQjE0Y29mMHpEdmgrbVNBVXlkVXdrQWJVUXhzUVo4LzJwY3Ura1pDL2wrU2FhTkdIQmpsemVnSVc2QUN5cHV2eUF5UksxLzJYTFE5UUNzOHFJRnZocG5VcmNBOHVyRkhkUHVtQnJyS0pGdXBtK2luejJLYm5ydFhzT1NGOXRrakpxWWt0cHlVa3BtMTFYeWE3Y0krMCtSQXRxMlhYaE55STF0ZUZEbFpFNjMxbWdIK2lZWkdaQ3N5bzZUQzgxWXRUVW1BQmFnU3RPYm16VHZLd3V0YkdzenM4Sm90NWVUSXY3bWhUWCtWM3doMlJRTFkyWUdtSnZVbXpYVXB3MVVvRDNXa3ZhUTB4Um5qcTFpZm9BbEVGcjlJQ2VzVVl2RjdsTUMxVjZyVnFxMHN0VHF2VHF6S29zT1FuL0h5dlVRMlo4YmNWNnBBejI0VFZWN0hHVEZSNytQemt2Mk9qWFdJVFlFN2pCTmMyTFhSZlZqZVY1dWVtOFdsOW1Ydmt0emF0TnpMeHkvNm4xb2l6bkdwZHMzTHRsaDRldFhIR05zMU5rREowYjdDK2NXeEZUMmNMYy9PMDlZbXZZWXgxYXQ0Yzlsb3Q3N0xxV0psc2NNOW1DcHBNVjI5UEFXZEcxVHJ1RjNYYU5PUEJGdDJDZnBGc2p5US9YaHBEWVhjb3JlTm12MEhJKzgwQkxtTW55K0Z2NWd0a3lSOC96MG1aS2pZZ0J2UzZZS3pQM1hBc21Jd1R6NVcvNWpVakRSa3U1V2NCdnFITTlZRTVEWWVQUHQvcmovM0ZpVWVUek5XSnFLb2p1YThRTUZldWcxL3Fabi9oeFBQYS9ZMnhnMHVwb3BFVkgvR1NaTkxhRUxDSExTcVN4OUExVTRjNWtHWG1xUktvaHkwdWtjZExZbThseXFRYjMwanpBSzliVHVrQkc1V0dQU0NyTnNVUkp6TlRKb1ZuMFZpZHpjbXNoMEJiaUFadnhGdHBGRHJWbGJDMkVOWnFJc1Z4aHAxWnZ0RHRKSXFhbitpMVd6SXdVa3pNRjYwNmVHQzFPZlVJZTFhWmRSVG1zQlJHWTVzS2tDNnNGVVpnR3N0enV3bUFVejlxY2NvUWlkOTdoTzRkVC9CSGhqYVV6OEF1aVVQcHAveEorSlZmK3d0OFFkVWMyL2UxbHdPUksvWW1SUkVPeUVJTmIxcHdZS2YwbWZZSTQzTHlLUFg1K0I3ZHFOZUF1WExrS01YbCtoMUt2RkZJTjFHUURUYm13ejFEejZzdjRscW92M1VyMVpjQnNkeXFhU1BNS1RPVHN6YW93U1g5azRpMlhZcXB5dTBrLy9qZkRCRnk1ZVdXb0d4bHd5ekR4QTRqUTdRZ1RneXNUd0pYUU1seUpMY0dWMUFpWDZ3cTRvbHkxT2JvR0hwWVo2T1dnb3k0TG9HRUttM29YeFZraU03STVkS2g2eC91Q0Rwa3hZS0pKVWl5MFlCVUVYVElyY05Ib0t6cTU4RnRpNDB6UTN4V1BiUkxWNXN2T1E5bnd6U2N5ZE5HK0p5NDdDM2szSTQ1cHpTbXN2WmFKWXpwY1duVnFqRmFkbXBTcTB3Q3JpNk4raWVhVnA0bkVwV21zUHJWc24za3l0Z0tWKzdSeFhTTzEvU2JBM2MweHVuelFhS2FXakJIVVZNNGx0OWhBWDZaTWZpWUFnelY3dmVneHNTazl4dHlvaWJyTTBWWXVMWmY1anlGcmFaMy93WWxZNS8vMk9ibk9YMm80L2Q1NDhaNHUwazlrOHB1MDBsK3VqVzdncDZxK0FmdGd2RncxaWQ0RkJ3MmtpMG53a2U3QlRzaVJMcGZaQXUzM2hsMm9OSzVRSUVWREU0anNvQzRuZXV2aU5Ta2dMQVdYM1AweUpSc05FNW9ka29pWk1rS3hQd21yNDdHVGp3eDhCMnVrUTFVS2gvWGtoYlN6VW01aFZyUzA0dHpoSFg4cHVtdEM5OXVmbU5aYit2amllNkZUSDVDS0xmTlh2TTR6SHhIam45YjBmWERZalU3emRYYzhmT3V1OXdhcFZpMTU1Qm5uZ0RHRVRGMXhOTkRBeVBvWnJRdFZIYUVaQTIyWVNkZFVHZHIyc3BXaEJVMHFRM2ZLbGFGNStmOFZ0YUZvREY2dFBuVEN6TzBEcjF3anl2Mm8rRlAvMTh3Yk9lWlY2MktMWVhkZFplSkprZmhmWk81NzZOdzkxemozZHBlZGUvc1c1OTdtdjJiTktWZSsydlFYeU02U3F5SGd0OThXTG95Wi8xTjAvbDJ3MS9sVjUrOHY5b2h0UU4vMXRDbUdMZHdSOWQydWwwVkl0eFlSNHFNSXljSGlSZXh1Q0Nhblh3Vm9zVkswMEkzZjBTcm1kU24rUjlEVGdrNThOVnlWdG1DWlhnMXhvUDlpbnJCaXEvSUsvcXFWdmRPTzJYZ3RHTXp6K052NmdxM2xqTEVDT2MreUVZRmc3UVhieUFLdmpkemhycDM4cmQwbHlNVzh5N3hrQWRFbXRtMGpXTGR6T3NDdTZXckkvUWVRcWtqUXF5Rnl5UlA3RmwwTmNUUzdUY0dYdWp2RlZ3ZW1CeE84Rm54NVBjSHI1RHoyYnA1Z0c4VWRmLzJsT0N1VVBmT0ZGa3pOQ1hya2I1NUxjTll6Qm1lZEMwRVJsbkhtYlhNMXJJbmRyb08vZWZMK0lhSnNLY1I4RGJYOU96QU9nSzkrSmI0T042UDcveXJZL1JnakE3ZE1tblJMVER5QTdtMU5aNzR0VThCMFlub3htNWxBYTVUWjJUN1JxdzM1VTcwQk15YkJPSHlJYmYvMTNtRG5wTlptUUhobkkrRCtPbnBKdVYxdmltY1A0TmxEWTVIK2psNnhzNDE2d3pyVGxoR2QzYnA4OFFiQXEwZlo2R29oeUJuTXJiMW9jM1MyQnF5dE9sQzFLTW1MeFZQcEdhMDhIZWhmQk5IZEVXeGY3anBhT1FsY1VUUlltMkdYYm1zWHZsOWFScDZUcTVRell4UXpoNmFCWnN0MTVhUFBIWHp1aGExcmx6MmZQWHo5OEdjT1pYYi8vTkhGbjB4aEc5WkdxOHpuZkhIRFFlbHN2NFVUZTlkc252WEw3MXR6Qng1NTl2Y2NINjA3bDlIOXpJWUJnd3JhekpzemMrbVNYNStPVktEUHFQbFd4dnpKTVZQYlBySk1Ma1luekRUcEE5cWZJQWxqR3RIK0JQVDREMXJjWWxCNmVDcE5DbWluYTJ3UWpER05KazBLbEJSWU50cWtnQVkwbUdtUG4xczYvNDhEKzVZK1Z4TTRXeC9jdithR0FmdG1MWmk0NWkzcFBLdGZjbUhGcU1IOXlzcWwrdGRlbFg3YjFtMUlEY1l3dmswZ0hTa2QwQnAva085WTQ1OXo5U3IvM010VStiZjY1NnI4VVZtNWVxWC9nMmlLWGJiYW4zMVpkcUw5VDg4RkZaQ3J6NFdrZ2dweStjbVFqNm42RVpuTEhqcVh2S3ZQcGZWbDVwTC96NjRMVlNpdVBwMFppdGwzaFFrcDZnVHdkM2xPMWNyNnRHWWV2L0tzTU15WDZ3dG15YUt3bFRmaUtHdzJTMHlFeUFTMm5pT0x3aHpxOEFpMmxrTUE2RWZNakFNMmtsRXM1dWJBWjFyeFA0VVJSZHhkSFNVUG8zUG9DdmhRVXJrWjl1STVXbHQvcEdtc2g4VEVla3pOWXoyY0V1dlJ3NTdncTJqWG1ndGRhZmNCRm12MVdXM2o4NkpWdjlGWWorbnlzWjdEVmVYQldiU05RU1FEamdYYmxpRm5nUWFieEhwSVRLekhGQlBySVd6eldJOVdWamp2cnVMM0l4VW9nTks5YW9Gbm4xYnk1R05pUFNRMjFwTndwVmlQNmVxeEhzc1RucXEyTkhsZUhobXZJclgwQzFVaEpoV2tYN25TNFQ4YnhGNGJqNmlpYVdTUmxodHBUbnBhRDdyWW5VNjUyMFplR3FZQmFRMkNrdFhkSmhzVGFKell5RjAwcWpDcFZ3KzBGZUhadE5NR1VlVm01L3BjUlM2TmpaYmJzNW1OOWQ1S0QrQnB0ODZ2R3picHBmN1NFZW5IenNSOTE1enIzdTcwd2VkMzNGa3kvK0M5WTErZjMzOXM5N0hQREpyMlduWDlqcm9UNU56WTNiUDc5dTVLdGl6c3QyRHVnT3FiUmtrN0h3b3R2UHYxcFhmY3Z2ajFZYVdycHZhOWIvL2tGMzc0YTZSV2plOEtPcndWZHR5UXkzUXZnSTBtT2tGcmR6c3pRV3RQaTR2eXh1YnRERm9wN1F3Q0tsc3lGZHhwQkdqSmxsUGNjbE9EbGpUdm1FWUgrUzBvMlpjMlArRDNOMVdyRmQ2NEdlZ2NleUZrUm1xSEwrbUdrTlZTTjRSc3BSdENuVkdWSmpkVXYrYUdDRlJTWGJZcHdrYVVVSmR2ak1BSjBUalAvd1RzVkRKZEZuWXlkL3VzVDY0QVBOdE41Z2NSMlBkUTJITXVBM3R1UzdDM2lvRTk4eC9GdXl5SkxnditUaVZ5YzZVSlVCRVVnZjhwQ3I4UDR6WE40UGUzOVlnNXNCUGE1YlRWb3RpQUNYVm9hVUtGTVJOcTNYUkNZbHVNMTZUNXJtRnFMV3lPeTg5elZrdWxxVmVhZE95MjRaVzVWeXQwbDRzWkVjMW5uK2J4Wi9tQzZUTG56ZlpHSW83SzVOT0ExMmJLVERqejBnaE5CREhJS3JNeUVUR09KTlUvdU5JUkNYdFpGTHlHa3ZWS1U2YWlsV1AyRWkwL2pGK255SllpeHM5N2dpcWFRaG5wMWEvMUJIVktkblVjelJUV2VySDhDdE1tOWQ3R2c0MW8zZ2FlU3JDWFd4OCtQWC8rZkhiZDZOSFM2RzNiMkwvS3ZldzVaaERnOVMzUTdaMjBJamNTazdIUlkwTzBjc3NRak1sRTlnWjNUSFE1YWJkVDdHcGpWdmFHQ3d2Wm5mUklONjJlMkJ6R0JHeDc0amZMTVpta2REQkZDV2MwTy9UdW5FaE1SbTQzVDBNeU1qcWpFUmtha01GNHpLRDFjeEdWQjU2c21icHhIbUR6emFWam5NUFp5dnVmM1hXbTl0NzF1ODRNMDI5ZWRRU3hPV3Z5MXBWSEFaOHp4ckwyOWJQWjZlT2szOExmalNIcXZldmxQR2JhcDBGMUVHU0lFLzNPbCtuVTRMcE1wNFo0cFZORHdHSnp5S2w1VitqV2dHdzJ0bVBESVdDc3pibzI4TnZsK011L0VTNWtvVTA2U1dDdFFEUEF1TDhvenZvSWJIc0FOdmNWWUV1NERHeUpqYkE1cndGbmxFWEdnbmRjOGZRMUEvQjdXUnZuRlBpcUtlNFNtS21YZ1JDenRGeStvRjNtQ1BIZWFPaElodGdHUE1BcDh3QW43VXdXVEpDL0pUU1pEVWFXWEU1Z0F4YjFWZWVpTUlIWXlYeU9IcVRtTTRucTBYS2ZDcUFEQzJOdnFWT0Z3eU8zTGJsNnB3cFVoRnZxVnFIWmpxcHhrNDRWZkNBbTNvWTlqNVNlZndPWTVtMFVVYU1sLzJMSEkrRmY2WGlrU1czU1E3Rlp5eU9nQnhtSDFSU0g4Y3hkbDJMUkwzajhEbC9RS2hPQzAwc2JHUXZIZ25aNXZlMFdUSHJEekhQVXhIRldEdlNXc2ZLcFdGZkh1N0xxTGVIK3hLSjlUMXlLKzFjYjE3NldZYlE3YUU5ZW1xRkxDZGl0eDZiV2NxcEJrZ0hMczRPNk9BdGFsVHJNUEV5UFRUUkFXUEdjQXl6aFNvaFViTXVaV3JvNGRQalpHMU1JWWpKYmFXMGVhUER3QmZCZmU4OEJrcnhKbFJ6SmNhMC84YW0wNGJYeG1LcEZla2o3TUcyTFBWeEx0UHNtS09sK2UwaWZRN1Avc3JtU1B6cHMwMWNSdlZDcnB6M1QyaklkbVVjWW12S0tmUnh5dE5pRGhEcUtZRU9LK2JBV0hiekJBa3NxbmtKVmdMWi9FWjFQSm9pVlRObFd3WHkwQW0vQWtrZnowWXd3bit2UWNnR3hMS2J5WVBOYUJGR1RoQ3RqQVh1NHp1Rk13dE1nL1FVQzhJQk1PWVZDek5NMG5vN0pVeGNiMDh6RHhtTlZFNVhoVmd1UUlhdFNPamMrZHI1MlBXRzZkZnAreFRHaVFjL2E2WFh2b1ozODJLb0xYYnBKNFEzTHp5MEFvYjdyREw2NC9ZMzlITkZWNVYrOFpKdDA4SFRFYkg1NStaTUJrUFVnNUltYXpDUWE2YmRGU29kSHhCbU53YXAzMFJpc2hhbG9Hb1hGMXI5R1gxQXZ4NUZOWHV4WTQ5Y2RDOGJKRkJ2cFhROUxyNmJNS21pUmlkZDY1VDdCRVZKdGpOanVBZ0p0R3JGVmNqNkludC9QbnFQMmN6NnRCT2VvVlN2dzhyRjVza21yZ3lHYjlzTlZRdXhFVDEwcksyWFRHV21kRlBGNzJZUHE3cURUdUpnU0JvODhOa2ZPeXNIdXZkVHpUV08rd1RqWndSMUhtK2hocHhGTVJFY2R6WW8wcmVOdzhSM29BMUZUeFl4Y3hoZE5pcG81bTFWekxuVW5FK1lEM3M5NVFLK212VmdzSHV6QVVxZm1MS0JCRy8rRlhpd2ZORE1PVzhkZmFneitiOGp6TldGMXdTVjV2dlNNUVhVNThLME1qQ3VtUjd2RTJwUkVDS1ZwZVZDYlpLTG5rQ2haNytueUNjSUFheHJ0SUp1R0xjelQwL0F5SFpOTjAyUk4zR0NYdXlhNjAwQ0lhRTBXcWtKb1RSaGpGQ0lsYnVrQzNkdjByRHpLaHJ0eHlpR0tjdlB6OEo4bWYvL2tuM0hMdlg5M2RlYk5vOW9QRzNaVDIzZWVXeEc2ZHd3MlJRL3Z2L05PNmZPdnBGL2JEczZPNzN6SFk3ZHZPVHJzN3ZCMFZaR1NwekJBNDJGVWpDNVNEUk5kamNqWkRTcDd0SnMxZDhrcEtwZ1FjWlNiM2ZDM3Y4cDU1dlVIb3pubWpXZnJaR0JudnBRbXAyamlPU29XV3dyeWVZcytXaVZndzNOVXZLQ1IweDVtMWtoSFdodm1oeVFrVW02STV4OWU5clFVN0VMaXRQS05KL0Rrc0xWajk1QzRsZUs1QjNxTi9yYjJPZW5zZWdQSE45UWJOaExUYzFoRmNLLzA4L1lWMHJrL2pHVVByaVRXZy9kT25kSnY1UGpWMHBsTmxWdWs3NThaUDdIZjlGbVREeERMLzkwKy9QLzhtU3djY0VxR1ZmODM1NERuTDhxdnlXK1dBLzd2T0ErR1paaUxaM1JxR0NPSDhXQ2VlUlpLK1hnZkh0Yml6L1hLL1hjUzhjZ0lUMVljMXVIbzVaUUN3ekV4eVVhUGZjYnRuZXVnaDNhQTJZMEpmWTU0T2JjZ3lRQUVrWUxKQkZueWtaNGVRU1FPaExDUWJtL2VXaWdBai9MS1NUTElyZXlzQ2M4TGpCNStsZDdoOXVSMnZUcGVseDNQVFNDYkI5UStNcnhZT25VcS9GVjRoTHQxajk2RGY5YytaNVNxa0t3NzhOazM3MHJqN0lQZGNiNkI2ejhocGU4VFczaGZVbzhoanc4OC9MT3FLSGhDMnZDek9McXIzWEhudGkzUFBLZmtMV2t4YjhrQk52SlErUndRekE1eUtreWFuZ3hrdCtLcHBja3lKckNmVGlvbEZvZDhQcENEQ2pLc3BYZWl3UGFpdVlHYW04a2NrdXZZN0U3RnBvaWNHaFF6VHlHN01hT0pxeDFEWHIzdHFRY3JPa2kvZmhWK3IyRU16NUR0Ynh6Kzg5dlNJTlhxOEFyMjd2Q0twRzdsYzB0ZkQ3SHZoZHRYYmxxN1JPbWROb0ZoS0w5Mm9ZM3Z4Qm5FK1pweWFzRVo1ZFR4dE9HbFErYlVEaWR0RzQyYzJrbjdTVHVSVXp1bzBoRk5DRFE2YUg5YlJoU2NrYmI0TVR3NjRsQ05aYzNIaUdyTXdmVlJkcnp4emp1UEhwRDBMTE5nTS9EaGxSRStySnFsMUFXMWRQcVFKZmIwSWVFS3B3L1JBcUFtSnhDUkFzcWJteDVERkdYVGVHNGM4T2xwR2pldDFoNHNuMCtMK1dsUjdjenRFVzBHdVRlNzVWaFFrUHVwQ0xJWjRhVGZxTm5vRUVCRFpjMjBzdXZxbGtRUlY2U1VyV2JrbE05aWU1Qy9UUTBmS0R0KzcvUnhlYmVOT1REcjh3RjVLMWZrRGJDdCtQTktBRDJCKy9iQ2dnMnJ2QlY1OWFwOXR0cGFXL1c4ZWNyNVI5SXVWVDZ0Kys4UnhWcjBPQ1dnVmhCaGtRN0xuSjBhd25yNXVHYlVGbmpsUUplbWgxaGh3d2ZBNEVOakpOY0VQR2xKZFYxOXRiU0w5UDAzbmJFbjAwSWV6UjEwTXJjcVdwSzVpWmJrYkt6TmNrVVBxUUg2TlZQSmFVYXR5Q3czWlRhWXFmZUVFWjFtbWl3UjFZR29oWXFud2FVSmRMdHhweHJta3E4bnY3TG9GdW44RDFJYytZSThmZktRQktnZElmRUZRNTRaZmZqVFN0SzNkdFgveFRNQXFRNFVleDVYakFha2Jra0Qwc1JvUUZUN29ab1BwUTg3ME9NZjZkbzVtT0Z5N1NZV0lZa2FzMWV4Y3EzQWcweGczdmhvNHhSUUdJeHVlblFmRXFQTlRyc1RXMlM2Uk9GSXFkVWRFclZtdWFVS2o4ZC9raml6SEw4cjhuVzB1Z2tRTFpjcHBIT1pCRG1vaGJXdkhqK05tN0RmVVg2aHJmMU80dUFtaEtzbVZxNW1VMGdwYVZmL3RqU1E5QVZ5M3NJZmxiNlZQZ24vMW5pKzN2L0V1WDRla0RkVjFDZlFTUm5YWVBiSnA4N1FSb2hVN2JmUWptaDRkclBhSzFzbDJDeTFqdGNZNWVpZGJQQTE4c0JNUVVjOGJFWDQ4SHl1c0lZcm5COCt6RmJNQzM4dXZWNGp2UmIra212UDNnM1FMTVZYZUVYRGUreVgwbnBwRnBsTGhvUlRLVXhsRjAveHMxVitKbys1blFua1V0MUNKMWYzNHdIWndUaERyaHR3RWFlY0NneXFSaGF3RXd1ZVRKQmtEc2xoZkFPUG9VYVNoU1o2bk9CUEwvYmJyQ0Jka29wanRSRHNCbFRZZUNhMm91TmpicXlpNDVYMW1mN0w2bWVQZlBIMjA4OXNQbjd3NmRNSGV0enovYXJEaEMyNDljNk9UN3dvL2ZqbkxkSTNoMHNuVkc5WnNIRHRrUFdMWnExZlgxWSs4S01YYnB4YTJ0R2FGMWp3WW1oaVpHMVZKVmM1bjAxaGpwRXo0Z3hLNk5tdks1WXQ3T2Jud3dueStYREFLVGZlWGRNd1JMWDZBbXlnK21vOFZramhZU1VhRTR4cFo4WTFyMmV6ZWVUajJSMlhjT2FnUVpZdUJybGkzQ0ovc3pRQ2h2VjVlazRHekF4YWxHaTFGVjhPTkZ1amhJbEErZHFBVml0WHRScGdXL25uRmJFQXF4dXN5NWRicXg5NWhQbDNuZ01JK3FVSytVNFM2czRKY3IwNmxWMVV0UlFNY3FZUjZKTldHdzNxNEdId0pvZDhJTERWSU1qMkE1Y2dhNUNDQUJaR1UvMHhzMUZ2akZVWGEySjB4Q2FhSWVBaVJpWDh6enBmOE45M1R1WC9oYk1GWlp6bDB6T2pQRTIxRkZFdEgzeU5FMUJrREVvZTJJS1IwNzFseWhHTzhnUEhORHlBTnBlcUNJWGJmOUo1aGYvcDUvYis5NTl2UjNWMnFvTzFiYTZ4bzdrZ0d3bFgxY0piVUwyYjZ0dWc3MVZmUEtTZXJYcUxTWVQ5a00vY3c2RE5aUE9KcWJxUVA4c2JpS2ZuVHNVN1FRTUFwTGYyaVNxT2RtQlRaVVRPUDZQMWd1UllwTk1vc25CMW1oY2tPWkNFTnN0TFRVWU1yWnJOdEZDUUVUTlM4Vmh6azVuUXhiSjI2TVoycHQ0NldERWdsM3ppeUN4RWY3YlZ3cWhnTC9QRWw4VlltT3pNNnNIUGgxZjFxdW05cXVINXdZT2Z2N0M2ZDAydjFRM1BPMGtHNFhyMWtzSkU3RTA0a2k1OUxvVjdzNlhTWjV1SEwxMDZmUE5uMG1jdkRILzIyZUV2c0wya0R0SzNQSy9uTDlUenNPL2VKVW44dis5Y1BMUmpmcUJqOUc0OEV4YU02OHZiTVh6TFNtSlRSb2VLSWJWbFFCdFViQm1xQU5KNWJRUWE5VlBkNnlZbHBxalVkUVVGdFJFM3M2QUxSWTlLdERlSmV5cW5KZEt1L2tKTGNjS3NJc3BtY1QvbGJCeXpZOTA5aEV3Y00yYUVkS2JteUMvY1BOWVIvbkxocGtIWHN6dUI3ODd1T096UEVaNmxPUi9MNTJOeElLcDBQbDlMS0lnNmtVU0RvN2twNTRQcHMyZHEySjlySXROSGN5NXFPMnAzMHoxMFcrTjRvc2JnalJrUlZQV0k4WDNaUVZIVW9OQURSVjZNaXc5RnUzSTB3aUF2Z3d6SEcvYnlHRkRrMVdBWkFFbXRWV3lxVzJONkdrUzRScENMTjBYbG5KdmFEUllxNXk3cFgyQlhoRkVDa21TOEplS3pMNHoxSnRraXpMYWEvQlRqTy9wNlRNUmZCSndteGt0MElaODZoNmpkcDA1WCtMODdnak8vMHhjOWtCemp6NXlqVVI0M0hrME84dGdveXdIRjlFWW00SFlvQjVWVGthQ0xWcmRGTEZNRlNrSVhrV3dlczJQNVFJQlR1Z1hCL1BwZGFTdy9EUlkxdk04emRFUE40WjhyRWNpd1Z2Wk90aWlyb21BMmdkSFpNb3d4c3VxeWdMVUkxQ1VRSVoyVkFxOHVBMW1WaW43dzVJZzk0YURIVFlFOW9kY2xPd0FhdlY0K0dFaDd6Ry93aW01ektLQjE0OHBxTVRjNG5RWTVJNDVNUEdYWGpaVkhTbE51MmFESXNoYUJQWnpEb1BOSk5pWlEzVUNCVnRwMzhqZkwxeFBqQm4xREE4ZmJwSmZQMW41OWQrOEh6b21IU0w5ZHU2UmRCN2RMWno3dE54SFVEZHVXU29tVWpoL1piOHJVZzlKTGg5NlZ0cjA1UzY1bnZIaEtzNHZXTTJkangyMHErd1djU3BJU0JaRzdUV2ZDZkRpbm9JMWdWeTRoZE1uWWRWR1hFV3BrOFdaYTY0enRLbkREWU8xZ1BPWWVxYkJoUmFvZ0NsclVvT0JCMWtCY2ZHcjBaTUwwanJSYkVFNExKVmdXbTVzdWtJZ2V4V2FscVZsWWtwNkdyYVROSC9ZVDc4YktsekVjK2VmTk9ta3ZFWjhnaFBSZ0xqNytoSFJSMm5meGNkVDZYaWZYN1h4VDhyLzN0UFRqMjFOMmtTNS9EQTlqRDIrWFB0NnltZVRzM0U1eXRteEdaWXBsS2hWYU1qTE82Sm5CT2gvdGFpamFZV3ZHQ1l3R0RVS2Q3STdoYVIwbmxuQUNYOFl1NHpxSG5NR0NiZW53WkJ1OUlCSmFKQ25FeVhFQnV3RDZjYVMzVkphUDZsL0VCbXdVUTlicVNuSnc5d25pQ3JIbE5WS2lkS1A3Ynp2SlY1THI5Wk5zcWZ1VHV1M2ZBd2Z0R3Q3UC9iVHFGWFpWUU80WHJKeUxtY2prTmowWE03VkpYVTUyWXlXY25EdVc1S0p1YTFwbms2SFUyV0Q0SXFucHVaaXAyZjlrSFJ5NXlybVk0NE9UeG0xY1FFdG42bG9vbE9tN2V1dzlzK1ZUTVZsbU1kam9XNEVlazBBbUQ1ZXRKMXAyUkx2N3h4bERBU3VSTTRVamFZNHBNTGtVbW5zdU9wVlVyaFJxajJEdjUwd2hZTFltb0xIdXRJb0d1amJaYVRSWjJCTHB0cWNweW5hcFRFVFRNVDJhRmNkWUxaR0ErbUpXYTA3S3VhN3ZzRTVzV1hMNGplY1htNWVSZHZPL216Ly83UEp2cFJQamZoSHJUcDhSNjlqc1hzTm1sbys1cGJTNG5YbDUrWW8ydTNlZFczcHUwWkpmbDVNdXBGWUN5Z1FhblVRSXJiMEdtc1B6ZHBEbVVwa2FoWU9aakhLNmo1aHFEQVZkc2hmUVpZd2VLR1lTUW40WExSNUcxNS9lRnFwVDZhMWFzRXBzdExaWFpaTVBHYVBoS093SjQxVE9ySGJobWRYKzFDYXVOdXFFVUxmZ2FkdExQbHYxaWpqNjRUKzlLRTBrYytldWZIYTVWRXZHM1BQWWcxT2tKM243b21uUDkwdDhhTlJEVDVmZk03eGkxSURSdzBxSFJjNWw0eWJDZkdKOGJEZ1AzdGpvWXhNdTYyUGJ5OWFGQTd5OXZLRVBwZTlrNlFTL2tlTEdqcGd4VUIrYk1TU3FUU0M1RGJTaHRjR293K003NUpvZHdTaDdHb3cwMk41WERyWmp5eHlyTzJwWHEwMDB1UUQwN3FCV2RtbWpoT0x3OUI5aU1FVzliVUpoMU5sbWs4TXl5UXRXc2E5dWRwUTE5TFVQK0pWOVdOTGVVaDRtWDN6YTBFZWFUWEtsRTJRT04yelBZVEQzLzVlZjBWa0lzbjg2NFB4U1B4MXB3VTludWlZL0hlRXdSWU1Va2o5SXcyYXpBNnZZZ2JPbEllVFZHZExzczFWbnBkbHNLWGt6UElwZGhTK3BTOWpQYXFYemVISUMwWWZQNFFFS0YwOXpDL2xjc0VpR01vR015RGxtOFFpT0ZaaWJRWjhSajlhb1NqYld6Y2ZFUkRPR1pmMnA2S1pUTzdFSk1KN1NpVVk3UXgxS0FZYWdvUEViQkg4eW5sb1ljRGdURlcrZHM1bXpUazFaRys0U09ST2pvdHVMcjAzWTl2U2ppNWRNZk9ySnNRTmU3dDNsK2M4MkhOajh4c2t0cCtlWExaNTU1MTAxZDQ0ZmNsdDFZY2ZTNlUvUDNISmo3ejJ6ZzhwWmhTWDBES1UrTWI0VjB0UXZKelQ2NVlRbWZqbjByVnpXSzdkM0pQdm15SkhoTHJ5OVlTSzMrTUpwYm5IRHhHaU5RWWxxRC9YTFRXMDI2cVYrT2VIYS9ITENaZnh5b3NaeUpkZGhqSDh1QW0vL1J2OWNMT2lxTGJIK09mbU1SL3NsL2puUzFEOG5YTmsvZCtseG1ydzlQS0xKY1pvd2p2YmlUM3dtakpPSU5sbENoTWFVeHBJaVVZVUNjVkgya2lRNzZob1pDdkJpR3VtSU9PcGdiTVUxVjFRWTY1clQydHFuWkhnNlptVTZUSVI5YTJSWUVoSUwydlc5dnFDNHdtUm9YZkxJYThSWlZ3UkkySjIwVS9ybXdNSmIyeG9iejdsOGkrS2dwQVhhVVhEZ3BxWkpaSWt3aG1tNFZyK2NqZ2g3N3lSYnlKYnlrVktGTkJ6UXM1a2RCSEJVaDE5anIyOVlmY2s2ZEw5a0hXTDhjcXBRMHlXSjljdVpXdkxMd2JMc3FLb0s5K1B0VWp2eS9vWFRKQ1M1WkwvYy80NXpOV1c4SU4wMDliMGhrR3Bqbys5TmFQUzlDWmY2M3ZaeXNCbEdZaDBVdDd1aHovK05zenIvazg3K0preFgwRWY4ZEkyaS9qbUVnekUyOGMrWnJzMC8xNVdiTEUydjRuYVhnNGJDN2FiUC8vZWV4OGZoT2FqcUNyQlJVcGs4d081TTJjNzBXMzFpaGk3a2IrT2x4a3FBSXpRWFFzekZibWRldjlzVEtabFJpdWR3eDZpelFQT1BCK3JSdGdicUFTTU4rNENZblVvZFRScHlDbXdlV0lEYWY1d1ZOMVJ1Qm1ZdzZjeXVCSFhFdVlvNVM3Q2RjY0hRV01POWxRdDR3b214UlpaMGI1RkFVeGFkUGhwOHp0RE0rT3UrTzJiMEhObGo1cUI5Zi8zYmE5N1NQbm1aSTN2UHVIM2ZYOGVTdnJWVHB0USs5d0s3YzBvdDZmdkNjN1ZUV0ZNRHllemVoWHdueFhmcExwMlVHcVFUUXF2VVZLbWNiT3JVbGJUNlZlbzVpMTA0Nitkd2FCWjU0OGhQcy81TjV5L3VCWjMwRUIzajVvZ3Z5VWg5Vnd3OVNvWFI2L0lqckRIcXhCSWEvVWxDeEkrSHA1TDA1Zk5iY09NQlgzeDZKQ2lhc1B4OWtDdWdmaW5UOGlJZ2dEMVVONHY2OFVoVFA1NnEwWThuWEZxL2NHVS9Ya2ZaajBjelBSZU5mR0Rja0QvZlZGWFY5OE83MXU1Z0Y1SDUwclJoRTN2NHlDbmcwZ2Z6ZXE1UnpwT2VFQ3NUSW5pZzI2dUpENi9aOUtrN1RXakpod2R6dng3L0g1azd0MXV1VGFWNDE3aGdQRFBtNUVYR2szMTRDdVpOQ3VhVndTMVhIbHp4NVFXTjhqSzA3TXFMZ0JPekdvMHJRdnMzOCtzQkp1ejlkS3NpcDh3Unk0M0J0Z3d1dWl6VTlJNUh1NFRxekt3M1lEVFR0SFpHenQrd0tRS3NzUU9VcnRHWHg2TGlHZVBMeXdOR1VUUmcwVDNkUDlncWxWV1I0bmxybm4xTWVnOTRralFoNjZiNytxL2NCUkN1ZTNEUzNWTmtmZ0hycEVvRkdKdjc4aFJBWTMxNXhrWmZudERFVCtaczlPVUpsL2ZscVp2Njh2YU9KRVczUFRHaCsvdGJwUjFST0ZmQTJrWWdMVWN3dzhjajU3UlQyekdrd0JyMTVTbGdOb0hSMlRLTWwvWGx4UURXRWxDWFFDU2Y1UW95TEJGa1dESktZZHJ6bWdNWlpzZVZqUU83UTZ0SnNtTm1tVXJ1MEtvK2hyc3MzaHdLcU9PcDdNRDBDSHBzb0lhTCtQSzBnaitlNXJUaUtWUVJjd005ZVRUblU1TWJvNktrVmZSYnUrZWx2OGVGVDdLWnRwL1hqdDF3UysvaTZ2VjMxWjVic1BEWHA2U0xPM3I0Znd6ZStjTFg1V1UzZE83ZlpVWERzaVcvTFpkN3pKMVN1d0ZtQitnT0VkOGRWU0RjMmxETVVkTnA2QlN5bXpVUnJVMVdKQnhDSkt2UHBtVDF3YUk3NVN3ZWc2SlVPUEZFRGhXYW84bUNxREZUMzUwZE5BdURNem5HZDhmRXFGcEU5dHpGYUZ1d0FLeUZPSS9WaHFiZi83Y1ZULzVsbGs2U3lQalBBdE4zVkh3S2IzZkJZdVIrU05KcXp5OS82dnpLUjc5YUpLV3ordGVsOFAzdlB2QTY0V2U4aS9NY0EzUnlRdkdaeFBycGNISjJZNk9mVHRYb3AzTTE4ZE9aL2hFL1hjZEwvWFJqU0wrNVd3NEh5SkVxYWJQMHR2bjVCMG1GOU96OFZXUmQvT1paajc4RUxIS0pOSUU5WHZNZytkT00vOTlqb1htUEJjTFlBUjlkVmNlWkxEekZNQk9wMUVyVlhIVHJJVHBTVkxROFMwTnRMNy9LNitkQWdjbjIrRE5wWitjTTRFQzhGdmgrUmladXRZei8xOTdWeHpaMVhmRjMzNGRqTzRrL1lqdTJFMGdLYmhLQ2t6aThseERTUUJndEh5bGwyWWo0ekR6WWFFSkNLWXhVcGVsV3RxcEZHc3VZcGtvMENld2pSU3hxYVRaRnRtUFJidG9RTFpvcU9tbG9RMnZFME5SVlphc3NkYlJhTzdRQ2NYYk91ZS9aejBsYTZMWksrMk5Wby9pOVoyN3VQZmUrYzM3MzNIUE9EMTYxUklqT0lFT29UeGR5SEF5S05sNkpPSGdocnM4aUw0WGJsNFhnd3V1ek5ldVZubUZjQ094d2k0OGN3UVlhSTM1Z1RKVVB1YjFqM2V3UDZUQm14Ny81NnA3ZG9TODhlQ1NHV2ZMZDhtaDBjakthSHI5eTdWenEzSHUxMjZ2T1AvZHJQVGwrMU5CbGZjcWwzSGo3akNmTVBwY25iR2E4UFhuRERsTUZDTUNiR1JLa0xMNHVROTFFbFJLS2paVUVzRFBwOHBSU3ZMMlNNaUoyUGNVejQrMHBRTmVEK1grQllDYmV2aEQyUzNiem10RGowZk4wdHM4bVAxYndZZjBiajc3VzkrVlR1NXRYZi80bkQ0LzgzU3RXVEYxMmZQaXpYNDNjLzJKNit0ajFvNkpsLyt0RDI1ZTN0NnpwNkx6NndwZVM3OFUrZDNId28vOXowdjhQYzlLTHdpdXdzRllvNHhUalgyUGlUNDRMY3NwY0FDVW0wSDZlZU9tejNNaWc5MTg1ZEtCTHFSZ1l1SEZGdCtjUzdHRUZkdTB6cmlkUzlQM2Fyc2pzZWlMVDZYU0N4bE1vdUpHNTNFbUhjREFVQ3lWL1IrSmlJVkcvSUhla1E0MWJIZmlDRUE5TS9aSThJLzJWTkFMK0ViR3lwbmwxVjM5dnVQcjhvV3VXQjliSmo5MTg1dkZ2V0MxN0J3YW9Kc3YwK3hiRUxYY0x0VUt2UUVjd0dFdGZBYXFjcWFUZ2FLR1RFd24wZTlKUkc2SkVBdXhDSGZtVFNvT1VTNEpHQ2N0d0ZxcFlpUk9QWkx5QWFpTG95a2Z2MG54WVBiVVZSakYzazVjcEN4TU5iMU1HNytTNm5UTFlaMlBXL3lTOVplQWdreWNxQ3lZei9xaUhkR3hFdWkxUGh2RjZBUjN0Rk9oNFVLOHNtdlVLZWR5WU96QlAwN2NGUmgxN0wwY1pYc0pzaURKODVFUkcyRUVoOThVcERwczhQakxOT2JrRHhoRGRKakFubnVsaXl6WWZQYkR5NG5pNlkycTlWTUx1K2M2SkgzOHYvVnVBRVIwTTd0MTE3NlB0d3o4VkM2WSs3SHlrcjZlWDJ4K3F2eklwbEdERVloQjc3OVM0NWZIT1pYbEtJN0VnV1o2QVlYa0NkR0FiUU1zVEpMd1hSTXNUNEFHOVRqMjcyaFZ3ODFvQjNtQUcwWnN0anFra1M0NmQ2WnBwWDB4MVYwWk45V011emNvaFlMazVCTzVQemlGZ2tvK3NqTms3K2p4Wm14d1BhY2J1R0RuZHZ4UmNRcW13ZFZZMmNra0VEMG5KUStvbWVzNDJUcytKSEc5K3ZzdENMRm1NamluUkZTeTVvK3lCcGViMGdibWNKRmMzTFRweGZCSGxEOHp3bHlpak9iNWsyTGVIYUwvYVpzb2ZVRkszMzdkVDBFMVJOby9BUFZjZUFXM2Ewd083b1E5dDBzczMzMDFmcGsyN0huTnVlWXVZaDAyUmRCWWtPQ09QRTVOczRSbHhlbmhrSlFkVGNjVnA5aGRxSGd4Q2QzWDZNQXlkclV0dnVYSEJPRzlUV3JoL0s0c3lMSVZ6dHU4MjJrL0tmRVp5bXo4cmJ1anc0UWtjcTBvL2lmNUlNL2Vya01QcytwODlDMHRqNGhBODg4L2lLRFdSeUVxbFluanZYdjU5eThuYmY5L2kxcjgvSXBleXJ5aWpNTmZWQW9VS0pnR0U1OHNabHNoOFR0dVk0NEh4Z09YRlZUYWZhYjZSOW1pZ3RhRkpMaDNlZVNDa2xhL1dpc1k1N3BKZHJKbmlsaUpDd29MdDVtZmJWZDVJV25tMUVxc3JLZkhWTDJVNEoxdlpDaGFDbDk5cnlldUhwbyswUitYVjVmZHBudkhqOENlSTEzSzZna1VFckVWZks0QjlTbHJ1c0dXL3FlVjl2T1hUMUdQc083eXpJQXZ4ZHlRTFA2SkZsRWJNeGJWZHJFRFRLNjdFZktxUnBad2pHM1NTRlBEaTNralE2K01DUTBWZGdFYy9zc0tMaTVsRXA4MFdZNm85R214dFhHYVdabzVjUlpTck9FWnk5YU4zQnlVYks5S004akF1M3JlNXBRQVhxT0d3NWtFZDFUeElPdmtqWjRUNjZVWkcrd0kvNzZkSlZCV3pKNFJ0YTIyY01URU41YXRWWTRxZ256Qkg0a21hSStxbklwQXNjYXF3bjBYL3JYNzZQNmFmKzNMN2VYcUdLSWQ1TjJFdFBjWGVFVjhqZWU3Z0xMNkdFeFNEZHpFMzNhcVM4alpZZFdtVjJjbkUyWUtZN1RGaHRkbXRkQmFJR2V1d0dxMDhXNTM4cDVJSVhXVVd2b1h5UzVyVTVLdndoRHhQcFIyN0hXQXc3SjEyT1JSMXNPcjBwQ1BxbURvanJ1YzV3aURBSzVSdk9LUkhxbUFjRWUrQlhVdkt2R05ZSVFJN2hsQXA2Uk85c0kxSHZqa2ZmMXFrVGlqZVBHdVlIRUMrTnhLaW5LZXFLcG9hNkZ6Q1h1aUVxNGtHbjllQnpocE5pM3RnKzJCenFLcnVGOEtRYlRkV2cxSm9CQzc0WkVYV1JRczNQSTJLNUZFeUE1SXFmRlV3cWlFbTVPZFBDMU9PSGllT3pjNkV0TFBId1VxalR0Yk51aHlaY2FaL2xQNmhFMzVOc21vK0IyK3pTK0tiMGtXWWd6cXFDaURKV0ZaQS8yVW9JZ3ZWR3RCL1plaHBzM24vYjUvbzd2ckJVTytlUWZGU3orRHdudDVuQndsWG53YWJja0VZMDNIMUp0MVRKc09RZFg3YXVHSkR2eWp5YkxOc1NTV09yeU01NVBZUklxazBJSFlrNjVCR29LTC9uRDdNTnVEL1kvUWYvTTIrNmZkdDFjcVlVRUI4QVZXQ0tyUUN1ai9Qa1M4bFRNZVdhL0V3QUw5N1ZVcW40ZkhhZ0ErVDllVVZNc3pwVWkxZUQ0L1hxVW1YSFcvRVhZaUYxMmRDOUFyMXN2amNIaUthV3VRalB1ODZubTJORzBRTlBxNkVqeXRkVk15MjJaZUtQNENwVllXQUwreHlBQVBBNDNXTDRDSllYb0ZnSTc1bUpVejIwdVc0QjZzSGJEWXhiNkhXalBkOVNEbWJKMlNMYStSVVhTQ0k1a0hFTktzZ0F6MVM1cjdkMTM0c09oQkxIQjJJUGZURXRzNkRoN1oySGd6TDgvZmZ2Q3EyVE1CTi9Oa0xEeDQ5dEhYN1FYRVlMK0c3Y2JyMUJIeFhidm5xQ3oyWGh3WXZUdzQvUHZMY3RaT25ibjRSSXg3WmpzRS9tdThlekwya0dPWXQ3QmJ4Mnk0UWpKSVdpaE50U1V4U3lmbXRDUHlzSHBkOExyZThpVktlNnhGaGkrak5iUXQwaE41Y3RpMUdNVE16T1hTUG1ObHkyWFQvZEpNMGFrSFdZQ0VQQU42QWRQWnJ0MVpkc0Z6K3FNckl1WDlIYVZjU2dHZWZFaEsxdUo0cnJYcUNUSEZlS2ltd1d0Z3l4ZTdTNG9JZFpsOU5XdlBvUnFrV3Q5cFRSRW14aER4OVpaNVVva3dtNmdLa2ppOVJFM0tad1hFUCt4Q3F3VjJHOFpXMmVxSitxSVNQMVl0QkZSUmIzVWFZSmVEMHlzYUdKbEM3NU12RTdBRlJkNFBBcHR5dmUwUDB1aGhDMWRmSExQYnhjODFzOGF0YmgvcWpOUjB0KzRkMkhuKzNRVnd6ZGRwdUVhTlRMOVhmZXZGYlp6ZTI3L2pMeU8vVHYybGsxM2N0VzdGMjFhNC9zM21MTno2NHFtbHp6L0tydjlqVmVuL0xQYnZPLyszSWs5b3pwOWlDYTJSdkdxV1FudHZoRlI0VE9IQzBGY0JiRHJ2YVpUU2hvTVlKdlZwc01CK2c2U2lnd3dJenpsWGluR2VhTVlXLzcxNnUzYjA4MHNQQk5UeTYrSjJvS08wRnVtMWY0QXRoRElkYks2VjRBU2trdVJ2Wlh5KzJzZWMzWFAvSCtyWVA4ajlRTnExZE8zVlJYQUkvL2VrQjFqODF3UDZaUHNiMnBhMlkrd1M2eWlzai8zVnU5ZE1NZ1hhZVBJT1VIa2w3OForZ0UwRVN1dkNNWGZrVFZjUXFFdzV6enlsTWV5S0EwdkRMcVltQ2dOOEtxa0pCVlJHellkaVBYWGQzeDEzendBb0lTb3BzY3puYURMUnhYdGh5T3RXRWx4Sy92VVZZVUVSTitMeVVFWTd5NGFrK01iOGFMM1BqMGtKbkdTWDhZQ3dkMzhVMU5HSEVvdzlmOVBtTW53MHozUS9TZFR6YU1iQjUzZmI3OXZhQ0NJNTFpV1BmN091V1hvNzJKS01kZ1oybFQzKzdPNHBiQkxiUDVDcUJ1Y1p4K3ZWeFBxS1AwcS92NlZ6R0lQQU1Fd2NhVU0xanBSM3FIUThOazB0TDNIb0JzTnNPYXE0Qm5abGpPTGZhbE1rYjFRQ3pZUng1VmhwSHJiQkVhQlJlMTMzZFlWWFRFaEdjc3pxY3MwaWROUndMYVRTYXNzeG84UDJHQWNVVzhHUEVDVmVnU3J2YlQ2TlBGUG1yVlZ6Z1N6L0ZXR3NZc3RYRXd6Q05sV29pWElQUHd0VllrMFZOMUlUeHFzWnZJLzRxVUF1eE9qWGVDRzNXcStoempOZHcyY1RWTUMvaDhMRXlXdkFwMTBQN2NMVGp1NXZYYnNNYkQ2ZWY3WVlGY3FCcnRrUS9jY0hRZTJHNWxaSHp6dzBwMTJsNkhWa1VuV2FXSENJQUx2QjRXVVNkUStRc3BuNG1va1dUdmNTUkludHRDTFh1M3hYcUhRbjBwVHNRcDc1Z0JlRmZRRzk3QUFCNDJtTmdaR0JnWUdSd3VoWnpjRkk4djgxWEJua09CaEE0ZDJQM1l4ajl2L3pmSms1TmRuMGdsNE9CQ1NRS0FKeVpEckFBZU5wallHUmdZTDMrYndkREorZk0vK1gvRjNOcU1nQkZrQUdqTndDMTJRZFdBQUFBZU5wdFZFMUlWRkVZUGUrOWUrOTd1cENJMlRhRVVCUVNVaEVSRXBGbFEyQ2tGUkV5dEloSlJOTFJRQWI3RTRtaFJjUWdnbWFCRkJaWnhCRFJRbG84eUVVWUdSZ3hEQkV0UkdRVzFTS2svMnc2M3gybnBGd2N2dnUrOTkzdjNYdk8rWjc3SG5zREFBSzNsVkFJdlJndTZ4RWtkQlhPbW1GMDZ3RWtuRHd1ZTEwWUlNNFQxM1FVTjVqcjhQWWd3eml1VUh5anMwaTdXZXhVRXppaFpwSFVCeG56Nk5IVnVLZ2VzbWNsZTFYamt2TU9ENGtVZXd3UklmRktOV0NmejM2bUdTMzZLWEs2Z0NHem16Rk83RUxPTlBBNWdweTdHWE1xZ1VZOWdaeGFZUDRqMFV4TXM5ZXhwVGpGUFZIMDZsb2t1U2MwUUVzd2cxYjJiZE9QVWEvNzdWMmU4Y3pmR1hzVmtGSFR4WjhLVHIwYVprME1vUnJnK1dJNHErNGo1YzZUQzFrWEVEcUxlT0lzRm4rcE0zYjl3ci9PMm9LOWc5U0hVdWR0SllmZmtHQTh6bmYzMUIwY01YTklxQXppNmhHYVZDZFNYaDY5N241OFplenhzaGd2YzY5dW8wK3ZSMFpQOHZ6blVPODh4WDNxa09iWlZwc3g4aDFGbjRyeWpPUk51SmNjei8vQ0c4RlY1Z2E1UmduT0ZmYnVLR25qTkVxT2U5dTR0Lzl2RGRHQWR1RjhKUVJ4YkJRZHJBYkxRQTJxUkFkaUhiSEpYRUJ2V1lOL3dUTTlZRXhiSFpiQjZuQ0NHbjdpbmNuNVN2QnZNbElIMFdBNXlQOW40WjRJaUZYYU1GL1c0SDlJL3BqVllUbW9nOVdac1dJN2hvSXUxdkpNNUtxUzJFNXVYc3BkeldzazZXZnJSL0hVMHIxcnhJTVZwNEFLZXM1WDlMclV6SkEzV0QrMjZMdDhwbzlscjNFUmtWN0JJR28xY01pc1pZNlFQV1lEWUQwY1dlS1ArOFhIOW52MHIrMDVYL0t1cVdFK2pWdkJOSHQ5WVgwbldzMm5QL1ZOd1FIR0tjNmNlTGlhbmg2alI3Szg0eXpXQ0c4bWkyMjhWNXh6R0FyVWFmc3VZTTlRL1NqeHgrZXc3SC92QTJlWi9KZzh2VS92Nm9ENU03amliMExvSCtaNmdmNTR5MWhuNitNbVk3VnN0em9WRUxIZmxqNmNoZExjWUxYTWpsK0h3RDlxNXlaaXp5QXo4WUdSZk1nZWJ4andhK25YcGVpZUJKem54SllTTU0rWVpPVE15QXlVb1hZZ3czcjVINDBTS2Z0L2ltR1VTQkd5N3VlOEQzbVRtTk5kR0pjZUZTUG9kcytoamVqM1lzV1VmTWZPWHBwY1JUZ2ZNcmVFUDRVRUVyOEJIOHhUbndBQWVOcGpZR0RRZ2NJc2hrV01MVXdTVEJ1WWpaaURtS3VZRnpEZlkxRmc4V0hKWXBuQXNvQ1ZnVldOdFl6MUJCc1hXd25iRzNZQjlpa2NQQncySEVVY2JSd3JPUFp3cW5IKzRkTGptc2IxakZ1UE80dDdBWThJanc5UEZzOGNuZ3M4MzNndGVJdDRyL0JKOGZYeHZlQVA0bS9pUDhUL1RFQkd3RStnVG1DTndDMkJGNEppZ25hQ1lZSWxnaStFL0lTbUNQMFNqaEJlSWFJaWtpVXlSZVNVeUI5Uk1kRTYwUU5pSW1KbFlqZkUrY1R2U0doSjVFbE1ramdoOFV2U1NESkI4b1RrSXlrUHFUWWdQQ0pkSi8xQ3Bram1tc3dQMlNteVIrVFM1RjdJODhpYnlBY3BjQ2xvS09RcDdGTGtVb3hTckZKY3AzaEo4WU9TZzlJc3BRUEtBc29KeWh0VXBGUkNWUHBVVHFtcXFGYXBQbEF6VWV0U082Y3VwQjZodmtYOWpnYUxocEZHZ2NZdFRSZk5EVm95V2wzYVl0b0x0QS9wT09oMDZWelRWZEh0MEQya0o2RFhvUGRIdjByL2w4RXNReVBERjBiempONFlCeG52TUZFeVdXVnl5ZVNYcVlacG11a2RNemV6SmVaTTVrbm1EeXpDTEhvcy9sbDZXYzZ3ZkdIbFo5Vm45Y0hheDNxRGpaZk5MSnREdG55MlByWXI3TVRzWE96VzJJdlptOWdYMlM5eGtITm9jTGpsS09GWTVyak84WUdUZ2RNTXAzM09VczVoemd0Y09GeWNYQmE0WEhGVmM4MXdYZURHNUtialZ1UjJ5TzJUdTRiN0N2ZGJIaUllTVI1VFBHNTU2bmcyZVo3dzB2SmE0YzNnWGVUOXlNZkxwOERuaksrV2I1SHZGVDgrdndLL0pYNmYvRTM4Yy93UCtMOEs4QW1ZRkhBbzRGZGdSK0N1d0I5QmRrRmxRUWVDaFlJemd0ZUZjSVRVaEZ3SmpRazlGL29uTENKY0xUd2d2Qy84U0lSTnhKeUlQNUVXa2RNaUwwVXhSUm5oZ0E1UmZsRXhVU1ZSUFZFN29wNUZDMFduUk8rSTRZa0ppemtYOHlmV0p0WW1qaXZPSUM0c0xnMElQOFFIeFJmRlAwdndTdmlYdUFRQXFpamZhUUFBQUFBQkFBQUJUQUJXQUFjQUFBQUFBQUlBQVFBQ0FCWUFBQUVBQVU4QUFBQUFlTnFka0xGTHcwQVV4cjlMYTZtZExJaUQwK2tnQ2xvU0JjRnVZckVxSFVvUjY1bzBhVkpJRTBrVHNWUCtPUWRkL1NNY0hQd2IvTzU2aGc1TzVzaDd2L2Q5NzkxZEFxQ05Ed2lvWnoxYU9xKzRwbW5GZGNpS0c4eDdkRVY5azlVcjlnMExkbjBhdHVoOEdhNnRjWjNybHpld2kyL0REVmlpYWJpSnJtZ1ozc0syNkJsdW95VWVEYjloUjNpRzMyR0xsN0tmNXBFN2w4TXNsWU5aR09WeUZJUkY3R1p5SEhqVE5NbExYQ0hGRTViSU1FT0lDRG0vNlJBVEhER2Z3dFpMNHA1T3dIekQ3Z0JUeEl5WjFwZWNWczQxblFJSmZPcExIRk81WlRWQlI3TVBEKzRmOHdkNk10TlZnQlBjMFU5SUM4NUpYTEl2Wmg1VmQxdm9TdmxxNHBuUloyY0hwWDRmdExwZ3Q5cEZ3cUdxN3UvUSsvOFg5S25ubkhZeHB6YWttMkpRM1dqTVdZLzdxUlB6Nmt4MVdzR3FSM2VpMVFzZGJYVDVuak02WEtzLzdPRHNCMEdqVjJBQUFBQjQybTJUVjJ3Y1ZSaEd6NWU0eEU3dnZmZStVM1pLdXR1bU9iMzNPSEhieExFZE81dkVTU0QwRGdJaDhRYWl2UUNpVjFFbGVpK2lDSkRnbVM0ZWdGZllaTWYvdmpEUzZQdG1WdmVjLzE3dDBJZkwxNytsek9GL0x0WG43ejdxUzE5S0tLV01jdnBSUVNYOUdjQkFCakdZSVF4bEdNTVp3VWhHTVpveGpHVWM0NW5BUkNZeG1TbE1aUnJUbWNGTVpqRTc3NW5MUE9hemdJVXNZakVwSEZ3OGZOSUVoRVRFTEdFcHkxak9DbGF5aWlxcXFhR1dPaktzWmcxcldjZDY2dG5BUmpheG1TMXNaUnZiMmNGT2RyR2JQZXhsSC9zNXdFRU9jWmdHbGZBUTEzRTlyM0VQUDNFRGQzQXI5L0lJRDZ1VVcvaWVhN2xiWlNybmRtN2lMWDVVUCs3alVmN21MLzdoUVI3bkE5N2pDWTV3bER0cDVDT2FlSjhQK1l5UCtZUlArWmxtdnVSenZ1QkpXdmlUdS9pR3IvaWFWbjdsZDI3bUdGbU9jNEkyMnJtZkRrN1NTUmZkNURqRmFjN3dDMmM1UncvbnVZSUx2TVFEWE9SS3J1SnFmdU1QWHVZcG51WVZ2dVVIdmxPRkt0VmZBelJRZ3pSWVF6UlV3elJjSXpSU296UmFZelJXNHpSZUV6UlJrelJaVXpSVjB6UmRNelJUc3pSYmN6Ulg4elJmQzdSUWk3UllLVGx5NWNsWFdvRkNSWXExUkV1MVRNdTFRaXUxU2xXcVZvMXFWYWVNVm11TjFtcWQxcXRlRzdSUm03UlpXN1JWMjdSZE83UlR1N1JiZTdSWCs3UmZCM1JRaDNSWURUcWlvMnBVazVyVm9sWmxkVXpIMWFZVGFsZUhPblZTWGVyV0taN2hXVjdnUmQ3bU9aN25IYTdoVFc3a01lVjRsOWQ1ZzFkMVdtZTRUV2ZWbzNNNnJ3dGxMVzA5bmExT2VhNDltMHFsYWd0WmxVb3llYTUyay9TU2pDc2Ftck5aSjVWeXZkNldkcXk1MW9xLyt0YlMxZ0pyb2JYSW1qbUNsRFZ6QkwwT3h6ZWVZeFRIS0U1eFVxTzRSbkZ0VXRmbWM0M24ybnl1a1YwanUwYjJqT3daMlRPeVoyZmdtY016aDJjT3p4eWVPVHh6K09id3plR2J3emVIYjQ3aXVmam04TTNobThNdm5yT3RDR3hGWUNzQ1d4SFlpdENtQ20yVzBHWUpiWmJReUtHUlF5T0hSZzZOSEJrNXN2MUc1b2pNRVprak1rZGtqc2dja1RraWM4VG1pTTBSbXlNMlIyeU8yQnl4T2VMaVBvcVVYa2UrVzNPczJYODM1Vm56cmFXdEJkWkNhNUUxY3pqbUtNNmNMdTR0dXZUTnV2bVBPMGtuU1RkSkwway95WFNTUVpKaGtyMmNPTW1xUWpvSjEzRXFtN010dWE2bXhvYnUxc0lyTjFQSWRLYWtMdGZWY2ZraG5hbTVsSm5xd2h6NWRKUDBrdlQvQTN3NHNWTUFBQUI0MmtYT1BXN0NRQkNHNFYzL1lYNWlETmlBQzVEZHBOa0xjSUNZSWpSUjB0Z1NkM0JIVFVOSlVpRkFsRWlweDBrVFJkeUNBNUhQc0V5NmVWNXBOUE1qTHl1U2F6RWo5eVVycFh6UHk2bWpzb1Q4ZkViQks0WmxQaUpIelROQlpweVNxWjdJaXRNdmMyeW9LMnpBZXRSdzR2UlgyRllpdEd1VkhZUHRWcTdKNHU0Nmx0MnpSZ09vbnpTYVFPTlRvd1UwbnpVZWdOYmJEWkk4L1ZNYjFTc01WWnJUQmVpRDdROW1wN3JyR3hQQnBWdVZqb3orU3c4cjNXOW1BUFlPekJBTTlzdytHTzZZQTdDL1pRN0J3WVlaZ2NQam5Ua0Y2ZzlqbUdrb0FBRlNzd3RqQUFBPSkgZm9ybWF0KCJ3b2ZmIik7Zm9udC13ZWlnaHQ6MjAwO2ZvbnQtc3R5bGU6bm9ybWFsfUBmb250LWZhY2V7Zm9udC1mYW1pbHk6R290aGFtUHJvO3NyYzp1cmwoZGF0YTphcHBsaWNhdGlvbi9mb250LXdvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFJUkVBQk1BQUFBQkFVQUFBUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCR1JsUk5BQUFCcUFBQUFCd0FBQUFjWHB4RW4wZEVSVVlBQUFIRUFBQUFPUUFBQUQ0RmNnUHNSMUJQVXdBQUFnQUFBQTlwQUFBZy9zTHVGeTVIVTFWQ0FBQVJiQUFBQU5VQUFBSHVmbnVNdEU5VEx6SUFBQkpFQUFBQVdBQUFBR0JRN0UrTVkyMWhjQUFBRXB3QUFBSWtBQUFESHVPM1lhbGpkblFnQUFBVXdBQUFBRG9BQUFBNkZYUU95Mlp3WjIwQUFCVDhBQUFCc1FBQUFtVlR0QytuWjJGemNBQUFGckFBQUFBSUFBQUFDQUFBQUJCbmJIbG1BQUFXdUFBQVliOEFBTU1jaG51OUlXaGxZV1FBQUhoNEFBQUFNd0FBQURZRnhzTVRhR2hsWVFBQWVLd0FBQUFoQUFBQUpBOUZDWFZvYlhSNEFBQjQwQUFBQXpzQUFBVXlhUVNHN214dlkyRUFBSHdNQUFBQ2xRQUFBcHdNK0QrWWJXRjRjQUFBZnFRQUFBQWdBQUFBSUFKc0FhZHVZVzFsQUFCK3hBQUFBVThBQUFLQndRazc4SEJ2YzNRQUFJQVVBQUFEYXdBQUIxY3ArVHJ0Y0hKbGNBQUFnNEFBQUFDOEFBQUJQZzB6YXVKM1pXSm1BQUNFUEFBQUFBWUFBQUFHQzJWU3N3QUFBQUVBQUFBQXpEMml6d0FBQUFERGhlWHNBQUFBQU03WXUrTjQybU5nWkdCZzRBTmlNd1lRWUdKZ1kyQmtZQWRpRGlCa1l1QmtkR0JnWkhSa2RHUmdZblJpOUFDeVBSbDlnT0lzWUxVTUFEcHNBbVlBQUFCNDJyV2FmNHhVMTNYSHo5MGQ5amY3Kytmc01qaWJqWlBGUmEwWXlzSXVLeXpZTEFPeEU3SjJNT0FoSllxeWFldHM1QUZMRUxha2N0V0p0ajhVV3lHS3JGRmt1ZEtxV2tYUi9MRkMxdnlCckdoZkVobTUwN29wOVZPTlkyVWNwOEgyYTRXaWhyb1k3K3Zubm5kbmRwWUMrYU5ZVDEvZTIvdnVQZmQ4enpuMzNIUGZJRVpFbW1TYkhKR2FMMy9qNU5lazlXdGZldXJyRXBjWTdSS0dZdCtYbjJ2NHEwWnF2L3prcVNlbFcvK05QL0dWazErWCszaHR0S2VGUkwya1FkcWwzN1dXNzhkNFkrL2ZCMDJ5UWJwbGxKWW1HWkZKMnIvQ0ZaZXZjZzNLWDhoek1pUTVlVUdTc3NJMUxqL21tcENYNWJleTI0eVlFZmxUTTIybTVZbDdLU2x4V2JsKzEyd3pPODFCODdmbXB6VlROZCtwYmFtOUVldVBKV0tmaXUySVBSVDdZdXhNN0tYWXk3RjN1VzV1K1BzTi8xQjNmOTJadWx4OVMvMjIrb2ZxWDI4NDBmQ0R4b2JHNGNaRGpkOXVPdEowdHZsSXk0NldYMng4cVhXazlXenJ5NjF2dFkyMG5XejdZWHU4L2I3MmNYQmYrM2RiMytLdk56dDJkcHh0ajNmOHNITzQ4N25PRzExUGR1VzZyblZkNzdyWlhkTTkxWENpKzdQZDM2ODcwLzJidHBOMVo5cE85a2hQYTgrelBUa3U2Ym5RODJidm4vVysxSHU1OXovN251bzcyM2NCclBRRi9WdjZkL2EvTnZEY3dJc0RQK1o2Szk0UVQ4US9GWitPSDRuL2RmelorUFB4SDhYZkdtd1ozRFo0YVBCYmd5OFB2amw0ald0MWFDVCs3TkRlb2RUUVNhNjlRMzg1OUh4UEszOWRIcnE4S2I3cHpLWTgvK1lUL2QwMWlXOG1saEwvaU8zallZRE54c0tuWlZmNE56SWV2aUM3d3ovSDgvZUhubXdCVzhPU2JPTytIVXlEL1NBRkRvYStQSXl2Wm5oK0ZCeW0zMm51SzhBRHJUSVNKaG1kbGlsbW1LYjNmbnFrdUIva1BzUDlVZTZIZWZjWXZsK2c3eExQSHUyYnBZdC91OE1jdXZub2tVZVBQRHJrMFNHUHBrblp5Y2hkWVJQYUptWDM2blVuUFZEcEIzaDNrT2VIa1JQTndneGhVWTZHTTNJc3pFZzZYRVRQUEhybTdXeG1MTXliY2NBNFl6WHJZbVpQZWhrVnA4ZUl6cGhpdGp5ekZXUUNyWGJEYVpJK1IrbDlqSDZQODV6bStUalBwOEFDZmErR0tkTkEzOFE5NFhKN0h0bTc4cGlRenRWbFppOWczVzdwUVlMbDFCZE9Tai9QQTdSYnp3L1NjNGkvUjlDZ3JOMVd0Q2hydUFOdWs3eWZDdWZSTEkxbUdUUkxvMWtSelRKeUNHYWZCek8wUGNMOVVkcSt3UDB3V2o3R3VDTThId1hId09NZ0RZNmp1YldUMVg2QmVaZVFIYkZJeTZ1OEs0RWJ5UGtBZkJqbWpBbXpKaFptVEQxbzR1OWU3Z01nUVR0NndMWW85ZExHYkIyZ0UyWTlTSTg4ZUltWlNtTE1sR1RJTG4zWWFVcm15VzJkK3ZaZitXdVMzTk9wUHZKcHVZZzFBbTJOYVd1UDl2Tm9HWlU2SGRVZC9zckp2bExwMjhIc1NXbkhWaDNjTzFkTGtkZlY3aVY2Kzh3OGc5MkwyTjNINWdFalM5WUdobFZsL3RES0R6ZWpYMXpselpCNTIralRBVG9aczhZbUdqTkZaTnNWK3kvRWpVL2NsSWhJUENjYlZZZThER08va2ZDWCtITUpmeTdoeXlWOHVZUXYzOUZZM29uTVhmUWQ1M21DZnJ1WmV3OSttS1o5UDBpQkE3cE9pL2kxaUUrTCtOTERsd0crUEkwdnY0Y2ZYNUE1K3B4RzdnSXlWcmg3K0lLWWdVL2U3QWpUUkdUYTdBTGpZSCtZeEZlK3NWbWprYXNiVFg1VjBYK0MrMjVkVVlHdXFMUmxESmNBRGo0Y2ZEajRjUERwR2REVDVwUEFyWkxBclpCQVYwaFp3dU5PeW1uR3JBQlBiUjJnR3g2VUZ1WnF3MUlkb0ZNdFpsZkE4MlFyRy9FQnVpMmkyeUs2TFRQak04dzR6eXI0QVZiS3k0UDB0ZEpQY0Y4SW56ZTJyV0dkUGpOVmVxUTFwK0Z2YWFTL2pSS05FQ0o3R0QxR2lQaXRXSCtTSGxOWWVScGJSRkxLNjc2a3JBNnJ4SktUYUROTlNjNkJCY1l2TWM1anpZL0pxQmtIZTdEMFB0NDF3aXB3VnY1bm1GeHh0dk5nVVpJcFpsOENkZWhVUXFjU3VoVFJ4WElxR3R2ajQ5Zy81K0xvUEQ0NGp3L080NFB6emtLQnkxd2VzajNrWG5SNTNuTXg1RlhGa09kaXFFZ00rVERKYWo2d3VTQ0tvZk1hUXpiL3IvRE03b0d2Y3ZncVY0bVpqeEhkNlVwMDN6NlArbWpUWGNtalVVUkhIckdhekdqK3JKNjlPbjhHVlpHYjExeTZ5K1hUL1dUeXNoYWRkNGljSlN6bm9jVXlHaXk1cUxIN1JCYlBYcWhFVFJReFN4b3hmVld4WUZkckJnbEpSZ2VNOURUQ0o2MlhyTzZzOXNmQVVieDFES1RCbk82WUdXdXhkWDZucnpsSTN6cjBERlMzYXAxc0ZEZFg1WXppbW4yUU4rTjJZbXNML2taT3Q3UnBESTNRTy9KNTJkOUZ0Q3hxTE5uSTNhTldMZStGSlkzUUJWczFFUFBmYzVreDViaW1aQk41S3dGR2VMNGZyYllBdXdhMmNkOE9kakJ5a3FpZEN2dlFyNDlvZWdBZCsvRGhpMFRUQS9KUStHL3lNRGdVenJIenpLRjNIenZQSEJIMkFEdlBIR3RsREQvL2hFaWJSNnQ1dFBvcnRKcEhxM25XelVFaUxvWGZsMWsvR2JSTVljTStZbUFaM24zRVFJb1lTTGsxbE1IdkwrTDNGelVmUjZ1a3MycWxUT2hlSDYyV01iZ3UwcXRKWTdTRGV5ZllSSytFUmtpeWtvMjMwcjZXa1l2cTgzSDF1ODJCdnNzRkdiaG40RDRQOTR6YmJlZmhUczBGUGtlZlE4enplVEREKzBlNFA4cjdMM0EvVER4Rk8yOGUvbm40Rjl6T200Zi9NL0RQYXRZK3A3dXZyYm95TG50bkttdUF0UVAvZkdWM3Rld0t6cE1GNThrazdFcXdLOTNpeWRFcVQvcFY3RXEzc0p1SFhSWjI4N0N6MVdRV2RpWFlsUnk3QXV3S3NKdUhYUUYyV2RnVkhEdWJSd3F3S3poMmVkZ1ZITHVjODI3QmVUZmp2RHNQdXdMc0NzNjdCZGg1c0tQS2hWMmcyVzVZMmRpTWw0Tk5EallCYkhLd3lXa2x0Sk8vMTliUEpaZnhGbUdTaDhtaXkzaDVtRkIvZ3M5cERsOUUrN3p6aWUrcW9iejZJOUkyaDdaK1ZRYk1vZTFpSlFQdUkvZVU4NC8xUTFiYXlHN3RaTU1PN3Ayc25FMUlTbWl0dWhuTnMyaWVkVFZjRnMyemFGNXdXdHVZdllUbXYzUitTS0w5WnJRZlJmdk5hSjlIKzlGYm9td1dQOHpDWWpOK21JWEpLSDZZeFE5SlZ4UE11b3o2REg2SXF0TGo2RGJIKzlNOG4rUDlBbU9YK0h1RnY3MXdNOHpTTUV1YlBhdlhZVGNMdTd5eFZodlFDdXArTXVZV3NBMXNCenMwRndhdU92RmRkUkxvK1NPcVRxeE5mVFNJTWsrMG8xeGd0Z3V1SW9rcUxNWVl1NmYyVkdxS3lMdFJYYkYyUnZHMThvNU9OcjVLdHllYmFBWi9YVjBSZWN2WE0wdlhiZmFrMVByYVhpMGNxT1RIdE5iSklERmJ2UTlWZEt4anR5c1JqUVZ5NjJ4bDdqUm8xeDNJdmkxWGlGR3ZqTzR3UjdGSHBLVTlrUlMxVGpoQmJZQU4yYzhDSWo5QTB4YVZYZEo5NlU0VmgrVTVCODdwam9BRWRvUXhkcGRkM01lNTcwWGFQdDYxT24zOEtuM3lTRTVYNlZPOFJaOUlqMEZwd1JJYlFSc3JwQU4wZ21GSnlSN2FIcVRlbnFMM25lbzhlOVk2UWI4NStpd0J1MnZ0a0VsMFRLSGpKRHJhTEw2SW5pV3puejNUb0ZPdVlsZXZ5cTVSMU5ocTAxZUxURlZpTGFxRTExZkJnYXVDeXg2SjR1MGNiZEhwMWNhYlQ3ejV6T3dUM1lHckdTSUxSU2VVWVRSWnM1RG5MRlJBbWdjdld5Zlk2ZzQrU0dEZHdpT1MxSXUxUnBGaTk5SVUxcHBGaXVmcXhpdnVkSDNGbmE2djZPbjZ1UE5pVkNOZXdVS2p6a0tqemtJcDYwbU5LcjhTYncrV3orVVZwaVgwSzFiT3VDY2lxWldvc2hKYXFxS3A1S0twNUtLcHBEcEVOYXFObm00ZHNRa21NMWpkN3FzelVVV3N0VVJPN1JLeFdxc2xxK3ZJdzVWNm8rVFdZOG5wNUdsVkhMRzFOV1FKVDVSZ09jT01ubGJGZHRhTW5pdzZ1TnZhYS8ycy9ybzhVNTFqb2l4UVduZTZpR1l0Kzk5My90ZFRCck5tS2pIUXI1a3RXbk4ycHNERmRzRjlUU21JM1lkbWRKL3pITCsxODBNMHk2TGpabU85VU1scWU0bnhNcS8vcnpWdjVmVzdyZG5FREl0MzhYcEp2YzRhdkVQV1hUL1M1c1pVWmZUaDI1em1qcTg3MFhHdTUxd2QvZXZybDZ3U2tUd0c5N1d2TmJhbW1xM1V1VE5WNTZoeXBXcFBaNWNZOHpOd2xYVmxUK0h2NkttK2l4M1ZkNVd2L1FLVVJXYk9WZlpKcmM4UHVMTlp0Rkk4bDNzWEt5dDVRZmZ1Vy9lZE12c3hKRVk3UkZteVBaOWw5R3gyUUtYYWlGdlVHc2ZXTjdybjhHNmxTbXF0MnFoc24xcDVoNHBoREZoNTkxRXBGSW1KSmlxRm9uU0NUZkJJZ0hQZ05kcGZSODhTUGQ4T3Z5SFhlZjgrdUFFK0FEZkJoMkIxdFdnTXFBRzFJQWJxUUNOb0JpMEErUWI1cGh2MGdBbXdUMjM1R3BGaUsrSTZiSnRCdTd5OEI0di8wRE5XQmkwejBxU1YxODlwZlJ2OEdyeUxWaC9BTVFicVFRTXlHbW43cFBKUkxxcC9FdjN6alBUMGk5SGJQUDhhU2U5eS95MXQxMm43Yi9BKytCLzlvcFJGYWxadWdnL0JhcGcxQXV6WHBScFFxMStac21ZRHFBUDFvQUUwZ1diUUFqYUNWdEFHdWtBMzZBRVQxczVFVVZwZVlmYWZjYjhNajRpVDFVcS9COExlY3JQc3JlUThuUEptV0MyUk12WmJ6QVo1RmIzZm9FZUorMVZ3RGRUUjZzUFd0dnJhK2g2ZXRtOCtkbGYvdm9vdEloOW5uWTl6SDRtUGpiek9XbWxWTDc2Q1ZoRnJEOWJlblR4cGVua2VBSFlucmxWdWx2VTEwSVRlZWF6bjBacEhkL3Nta2xsU0srYXdvclZBbnJPcFBXMUZKNjJzZmplTVJtVTBxdDl3VVhHVmtkRUlYMjEyQTN0UE1NYk9xcmJXNlB6a2JVNnBHU3laVVV1K29wWk1hYlJaSzVhajdEcDkzd2NmZ0ZYT0ZBSU1xQUV4VUFmcVFTT25xV2J1cllCNW1MSEpNSS9oREVVVUpZbWlKRkdVeENwSnJKSTBDVEJNbndrOXA2VGtEOWJGdmRYbW4zaTJqTy9CR3BEd0hxNkRYdEFQQm9EOU92c0p0emJxTmJJai81U2plODJUdGRhcUdoYzJIdXJwbDc5anRtaDBrdngxOGJFbTBXZEVqcFZVSFRsWFZVNU9hcGpEeHB6UEhEZDVNc0MyTkd1Tzh0QTRlaHVEYjZENk5Mc1liZEdxcTUzNW84b3JpMlY5ck9scmRCdDZ4bHhVSjdoUDZLcTR3YXFvWlI0UGFYWU9YeG9ZRlRBaTZsMFBtbmpUcFNNOWJPWnBELyt1UFpxWU5iQlM4WitkT1ZEcDYxa0V5cUpSNXphNjZzbzliTFJiZVVHRmEvMjY5Y2s1dUdwdEJ0U2JVYldVMDJycGVvWHYyZ2lyWDNtRWxUbGgrK3VvOG9qSVNtVjlxNWw1YU9JVE4zNlpuYk5lUmpaVU1Tc3o4aVMyem42OU5uZG9IbDJMamJ2WnBteVgrbHQ2UlZrcDZrRVZvVHROMDIzOG5mOC8vcloramxVeWVWbUx1b3FkcW0zVVpjOEF0N0dMWDJXWDZ0N1dMb0hhb3VPZS9CN1ZwMTlwMW42TnUzM0ZGdjBhdDFsSFBsMzVncUsxTytzdTdiSmdodldXMWt4cWdQM3lzTkg5MXBkMEZmUXkwaThpZlJucEY1RytqUFNMV21sR1g1eHM5YllzOFkvOHQ3M3liMkVESCtrdmIrVlptbjVYUFZpcDJ1enZIL05VaE4yYzZXYW9YbWM1SVl4aWowbE94YU15QkU3QjBMamZ4SCtmbUswWDBkOU5qRFJ6MVdEeGpXU1hOa213S2taa0N6MjMwbTlRdG5GNlRsQkJUc3Z2VVV0L2hyYlBjaVhsa0h4UnR1dXY2dnYwVi9VcCtST3VUOHNjMXpTem5aTDljcHFMMm9IcmdEek5kVkFXdUQ0amY4ZjFFSlhuRW5aZkVROTVsK1FWSkw0cWwrVVJlWTM5LzRpOElUK1g0L0lMcmorU3Q3bE95TC9MZS9JbHVjYjFWZm1OL0pmOHNWeVhtL0tFL2plRGt5Wm1ZbkxLMUpsbWVjcTBtM1k1YXpvTk5qRzlwbCsrYVJKbVdKNDJJK1lUOGkyem5kUHFncGt3RS9KdHM4ZnNrV2ZNWHFyelovVVgvL1AvQ3lxQ3ZVTUFBQUI0MnJWUE93ckNVQkNjVFo0aUtWSWt3U0tJQkF1eEVBdEpaV2NaRFhnRmc2QUl3U0xZZUFkUDVFRzhUcHkzaVpMQ1NyQjRzNStabmQwSEFlQWh4UkhPNFZhVjhNdmllc0VJaG4zVU5Sd0dwMU1KWEpoalZSd1FLeWJsK1ZSZ3FqaW55UElXSFVWUkJQcndNY1FZTXl5eFVqZmh6aWJ1eWRvZGR6emE3Q21tNFNScFkwcmRnbS9BMmtPQUdJbmszSlJoSjF1TnVXdzR1Wk9NbU92bTdLY1plNzNoclNOTWVHMXp2VkV1VkF3NmVhaHFGNUgxYnJXOUw5cC9lQXI5N044RVJ0WjBDOWdMUDF6MDVvaXVjc3E4QUg1T0h5QUFBQUI0Mm1OZ1l1RmpuTURBeXNEQ09vdlZtSUdCVVI1Q00xOWtTR05pWUdCZ1ltQmpaZ1pSTEEwTVhPc0RHQlM4R0tEQXhSRklPRER3L21aaHZmNXZCME1uZXdMakxBVUdCbnVRSElzbDZ5d2dwY0RBQWdBNWdRME5lTnFka1ZkUGxFRVVocCt6ZktLc2lLQ29nSUFEeXRvRmxiWlVLZEpjUmNBdXN0WVlhMUFUUmFNbVZ1eEN4Qklzc1Zkc3NkZEVwUHdIOVdLL21IaWp0eVltTHZrY2R3MGg4Y0xFU2ViTWV5YnpualB6REJDQWYwWWpPaUxoT2hOZmJ2QkRyeGtvcmFLMDZzZE9MS21TT2x1SDdZUHRreEZzbEJ2Vmh0dG9WSFlWcnFKVXJJcFhEcFdrTWxTaGNxdVd1UGdFNzAvRHNuNVgxVjdGUmFuczlvb1JZbFFZTlVhRFFvV3FDQld0bFBZbUttY1ByMml2V04rdHoxYXJWV3U1dXF5dWIxMWZ2WjNlRG0rN3Q4M2JaRHJNT0RQV2pER2p6VWd6ekF3eThYenhOSHNTUHJvQ1MveHYrYzhSYUxQN1NQQlhGY0gyUjluK1VjUHZETkRrZWhGSWIvb1FoSjIrQkdzU0lmUW5sREFHTUpCd0JqR1lJVVFRcVJrUDFkUmppR1dZcGhWSFBNTVpRUUlPUmpLSzBZeGhMT01ZendRU1NXSWlrNWhNTWlta2trWTZUdjFUbVdTUlRRNjVUQ0dQZkFvb1pDcEZGRk5DS1dWTXc4VjBabERPVENxb3BJcFp6R1lPYzVuSGZCYXdrR29XVVlPYnhTelI5OTlQUFFjNXpBbk9jSUVyWE9ZcTE3bkdEVzV4aDl1MGNKZjczT01CRDNuRUV4N3psT2M4NHpXdmVNTmJ5V0lqeTFuQktzbWhqa3ZVc2thSzJjeHFYZnNBelRwdThuRmF5WlllN05heVhjZWJ2R1FYeTFqZnZiK09IWkxMVW5hemo5TzA4bDZTSlVXY2tpR3Brc1lMZmVJZGJWSW9SWkl2QlZJcVpaTE5Wa21YVE1sakwwZll3MUVPY1p3R0dqbkdTVTVwUnhQbk9NOVpyZHJwWklPdlR3ZmIvQTEvQWRZd2pTa0FBQVE1QlpvQTVnRUdBSzRBdXdERUFNc0EwUURYQU5zQTN3RHFBS01BK0FEOEFQTUErQURrQVFJQkNBRVFBTmtBNkFDd0FQWUFSQVVSQUFCNDJsMVJ1MDViUVJEZERROERnY1RZSURuYUZMT1prTVo3b1FVSnhOV05ZbVE3aGVVSWFUZHlrWXR4QVI5QWdVUU4ycThab0tHa1NKc0dJUmRJZkVJK0lSSXphNGlpTkRzN3MzUE9tVE5MeXBHcWQrbHJ6MVBuSkpEQzNRYk5OdjFPU0xXekFQZWs2K3VOakxTREIxcHNadlRLZGZ2K0N3YWIwWlE3YWdEbFBXOHBEeGxOTzRGYXRLZiswZndLaHZ2OEgvTTdHTFEwMC9UVU9nbnBJUVRtbTNGTGcrOFp6YnJMRC9xQzFlRmlNRENrbUtiaUxqK21VdjYzTk9kcXk3QzFrZEc4Z3pNUitjazBRRk5yYlFTYS90UWgxZk54RkV1UXk2YXhOcGlZc3Y0a0U4R0Z5WFJWVTdYTStOckJYYkt6NkdDREtzMkJCOWpEVm5rTUhnNFBKaFRTdHlUS0xBMFI5bUtyeEFnUmt4d0tPZVhjeWY2a1FQbElFc2E4U1VvNzQ0YTFCc2FSMThDZ05rK3ovenliVFcxdkhjTDRXUnpCZDc4WlN6cjR5SWJhR0JGaU8ySXBnQWxFUWtaVitZWWF6NzBzQnVSUys4OUFsSURsOFk5L25RaTA3dGhFUEplMWRRNHhWZ2g2ZnR2YzhzdUt1MWE1em90Q2QyK3FhcWpTS2MzN1hzNit4d09lSGd2RFFXUEJtOC83L2txQitqd3NyalJvRGdSRGVqZDYvNksxNm9pcnZCYytzaWZUdjdGYUFBQUFBQUVBQWYvL0FBOTQydXk5QzJBVVZiSTMzcWU3NS8zc2VlYWRUSjZFUUFZeWhCQVJVRlJFUkFSRUZoQXhJdkpTUk9RbElyS0F3UElTRUVYQWlJcklzc2l5M1pNQkVaV0hpTWdpeTdJdUlLS3k0Q3FHUlZkWUYyT1k2ZnlyenVtWlRDQ0FlKzkzOTk3N2ZmOTFNNWxNUXA4NmRlcFUvYXBPVlIyTzUyN21PSDZZN201TzRBeGNxVUs0NFBWaGc1aitiWm1pMTMxMmZWamc0UzJuQ1BpeERqOE9HL1FaMGV2REJEOFBTUUdwSUNBRmJ1WnoxSHl5UWgycHU3ditqWnZGQXh3OGtsdkxjV1N2YmhXbjQweGNKUmZXYzF5SlloQnI0Vjl5SlVRMkIyWDlFWmtyVTB5K1dwa3ZVeXlrUkRIcEpaY2k2aW9yT1lVWUpKY3NWclpwNnk0UGVJVThBUVphUy9KNnpydVpPSFY5dTNlUGpsYzdrbFQxTkk0elZTZ1hac000SW95VHhkSEh5L3BRQkg0MmlDV3lyZ3pId3NkemJkcW1FM2hZd0EwdlU0TWtkUy9wVWtaUzlnbmwvSU9XMkRyNmdzL3J6WEc2N3ZDOGRDNmI5T0hDYVVCMzJPdExEWVZDWVFNOE8yeTBXT0Y5aENOcEJsdEpEUzlsWk9iN1F3cG5ycTN4K0ZQUzgvMWxFWjFJZnlVNHM3THhWenI0bGQ1a3RzR3ZpSndUbE5PT0tLbnVXam5WcVJoZzBrWjNiZGhnTkpmVTNHQVFUU1d5MGFuNDRGTXZmT3IxNGFkZU4zenFkVklHV2QyMVNvQ1V5TzNUdG5YSi8rYzh6bHRpM3RZbDY1K2o4WTJjNXF6aDB3eHVHSmUrNnZFVkJxa3hwUnJoamM5WlkvWlozUGlvR3B2WENuL2dwSzhTZmZYZ0svNk5uLzROL0tzVStxL2dtZW54NTJURW41T0pmMU9URmYvTGJQeGN1TUhKQ3poSnA0UmN5TWpNeWk2OTVIL3lEV2tjcm1mSW5RZGZJVmlIa0JEeTV0R3ZQSGNBdmlwZ2FYcC8zdkdqY3gyT2R5QzkyeC92OE9ieDZ3K2NyenhlcWNvVjhFSjZkMUlWMHVNd0dYYVlkRlczNDlkaHRmcXd1b1gwd0MvNEhPUk80SVkxVklpYjlFNHVrOHZuU3JpRlhOZ01xNmJrbW1ybGpLQ2NHbElFYzYxY1VDWTdnMFJ1RlpRTlI1UXNxVmJPY2lvQ0tRbWIwd05sWldXUkFqZm5GVXZDVmxjcS9DUVhPSlVXd0h5ZlZLdTBodTlaS0pxa1V2RzFBR2wxT2xCYWhRejRpS3VVbmRLYnhPRDJaUVZhbE9UN0srVmNsK3lxbE0xUzJHU0RQd05oN2tKOGZxbVVsTGRyWDFFZTh2cjhoc0lpS1l0NFBYcURONjg4MysyQjM5b0o2UXgvVUZnMGJOYTIzMzM5eC9QdnJmdmtkK1BuTERuenB4OCtXS2QrZDJlL2NmY05KeU9xUnY5aS9NRnR5OVBJMHV0M3ZiSDJzR1BTRTJremR6MllwVTd0K09HdlgvK3phLytCYktIK3B2NjVaSlRodnVqRGhpRjMzRG9nRjFnRE8zRm93L2Y2a2JvTm5JVnpjR2xjSWRlV1c4MkZyU2poK2JnOVc5cHJ3emFVY1FGWmxtcXZqYlRKeWhkc0pVb2JlT3MyMGJkdWV5MlJ5NEl5ZHlRaVVUYkpFaFhaaUo3OXBIY3E2ZkJUQy9aVEN5ZnlMQktnUHlraHlrYkpGVFk1QkdDSTBocFlHTGJsWjFVaUU5dFlnWi9wQWZnNDFRM3Y5Qnh5ek4ydWZhak1CeHpLeXkxMGt4RGhQYjVRV1h2Z1QxNHVTZnBWKzhhUGgrNTQvcmwzOE90Wk1XWC94ZE92RDd5NVc3OUJOM2ZqQjhKbmIrUFhGdmpwTHZnU082NDhjbmpWeXNOL2p0Nm5XMVUvWEh3dS9QampBMy94UkxTdjl2RS8yTTlVcG5vM2ZLbnJwd3NEei9LNElEZUpDNmNndTdKTXRXRWpjcXExQVhqU0ppanJqaWo1VW0xTmVyN09XS0p3emxxWkN5cnA4QzNmcWJTRXFWdGcrN2FGNy9ucElDNThwZHhTaWhoVHNnSTJsQldMSzJ6MzVWQkdaS1hBOUQyK3lrcTV0YlNaMDFuY2dTTDRDK0NGczRES0RwMjF6dCsrd3E4MytBMUZNUC84Q3B4L0JiRVRsQ0VxUDNtNSt0NmtiZWZLVTl2V0gxYmZ2OUM3eC9ZSDdqdTViY2ZlYy92Vk9uWHV5SVd6MUoxVlE5WUhPNDBiTjdoN3p5RmtIbkhPdkhOeG4rVi8rbkI1N1BINnlhdUg3WjN4OWV6ZDI3N2NmcytrYWFSYjhWUDhBKzBIMzFROHBsZjNRUStBV2tlZFMzVzd5TFZrR2xkVHQwVFdVY2tRZkp3YjFsc1BreFU0T3RtNDlnWEZteGxYdVNpVGhKdWhuaEFLZEZ0Qkp0MGNrYTM0N3hXRG8xYXhVWlh0ZG5JRmZqM3ZkUGtOM0F5U1FkTEhmSDd3NE9kall2djRuaVNiaEY5Y3QwejluWHE5dW1uWk90S0JQVzhvUEU4UHp6UFQ1MW1Dc25CRU1jTHpyUFI1L3ZZdUoxOVV3VWxPTXBRK2lhK0k3WnU2alBRbDc1TSt5OWFwZTJNSFloK3BlK0U1a3dVN1g2OWJ6VWxjR1JmVzRSd2QyaHhkU0NNWXJZakZSMjJNcVV4eDQvTENUQlZpcnNTNXVpdUtLdnhGSVVPRkg1ZkluMWRobUZ4YjIrT2pqTVdaQjNxY09kUGpRT2JpakkrRTc0Y1BuL1o4ZmYzejA3VHZqUDZsM0RGeGtiZ1ArTkdYQXdHU0RTR0ZXR3ZCa0lVNWdnYUJNNXRLd29URHQwUXdsVkNXbVpFY3hRUldSU3dMbTh6NE81TUIvc3hzd3JkbXpsUVNaMmQ1UUFLcjdRMUllZEpTTXIrV3pGTW4xL0pWcDhoY2Rjb3BkUXFaeTJqb3BoNGwxU1NWczhMYzRma1J6czdaY2VZMnROclVaSnVjRVo1dGNUNm8yT0haQ2dmN1Y3WlVJb3RCL3NyellCUlFiTjFrZmhTUlhucDVWOTVjMFNHUzFPL1dyYkd5TWNhVGV2NFEveDNzcmx5Y3AwSnN0ZmhGWkRHb2NLQXpCTXBjUlJlbjJ6dWVIMExxZi9nQi8rMENlRUg2Qks2WUMzTzRGd2tnaS9nYmZBUktrZUNycFYvc0VRaFdGaENKd1FhT05CeFE2OFd1K3FId0RFNEF6UklTWHZva09sU3RONHlzVzBIeHk4U0cwN3Irc09lZGdDcHU1c0kyZkxoWHFBMkx1T1BUQlJnbG00NGllV3BSQmFhZ0xmZlVLam53UFFWMG5HSVRjVE9uZStHdFVkTmxydnhRbWVqeWVuZzdnVTNMRjNpeVNCbnVWajR2MTA0bXJpSTVXOThrMlN2dmVmWGIrVnZWVXl1SU9IRDlwNy8reFlFMUQ2OGJ3Qjg0UUhwLytJRXFIMXlwZnYvaHhBOUluNFBQMUM2WS84MlNZNlI0M2plVW4rVkE5SERkV2s3UEZYQmhFWFU2UTFxR29Dd0NMMkFIR0hFN2l0UjZJVXNMUWlBRXVuSXlRLzVKamVtS3A5WVBGdGQyWjJzRGxsUWNwOXZFWlhDOU5QNm1XV3JEVHB5NTBRb3p6NlM2enUycERidDFLR0h1REJBMm5SdmY2bERZc2xBZzBqZzZsR3lVYW5RV3E1dnFzRkE1aWFzblExRm5IdGpoOWRnRmd5N2dIVWErZTJIaXpBZUhMQjhRdm0zZXJta2ZFMzEydXdkSDNLMGU0emZzSmE5TlgzZmZpTWVIajFzd1l0cHQzNzEzMDRUN3h3N3BkdUZ6UnV1QWh0UGllSXJYdWpLMHBvaXdTZzZrMVc0QldqT29rZmZEL0ROaC9uNERXbTBKbDhZT3JLamhpTXVQK3RjaHlSSzEwRm1FV1pJU1VrUUNJSFVrUy9CNnhMeWNBZktkV3lZOHZGQlpPYkdZeklvOUowVFVjUU9YVGI1Si9lWUxkY09YYTRjTW1USnMxSVRWNU1YUDNsVkgySzZyV2paa3J3b3kxQU9NcmhuV3hNelo0SDNZR0YrVmlObGlKTFlTV1FncFptTXRCYW4yb0d3OElsdkxGSU5FQWJFRGlEVVkyV0lwRmpNREdFU1NiU2hKSkNRQmJJTGxDMVFFcEI1Q3h0RURCODdGV2tmSlVYSkIyQlI5K0ErSWp2N0FkNkQ4cVFMK3pLRDhlVkxqanlBd002ODRyV2pXMDJ4bzFqVlc2Uk9zb2lqejA0dXZVbkJwSzdYTDFwMDZ4Wm55azEyV2RuS0tWU290SlRWV3dIc2F0aU9LSCtHN25RR2lORWF2U1FvVGl6K09mZUltMmxBRUVEd2dnQ0ZEOE1QbDVWUlZ2NzFseG91dlB6MXI5Z3N0aElHeEdmNUh4eS8rZkk3NjJYZnFuM2R2MlRodi9NTXp1Z3pqZC94RmxZdnYvK1B6eDlWL3h2ZW51QmYyWnphZ3ZQRmNPQjFubGdkU3FzZVoyUVNZV1hHNkhtZG1xcTB4cCt1TkpSVHZ3WWJOQWZYbExKTnpuRW9oQ29TVHdickNISkFHdmMyZGp0TGdseFN6Q1NkU25BZHo0bUFHaWhtTnRyTlMwZHZndTRsdTU4NENtR0svb1pTZ05IY21iRHE0dFl0S2lhNFJrZWdudG4xd3liN0pzdzhNbTl0MzBZQVhJNmFiWHg2LzZPU3ZGdjd3L0kvTEIvNkMyTmZPbmxYOTZ0TXpYK1hYUFgxbTk2SmV2WHUvZDBPbml4L2RkTWZJUHkxYStKY25sdzlVcGJITG5wc3dadEV5SnUrZys4U3BzSjU2MEp0aFhWeWlRUDNXNGw3SFRRN3VFMjQ5UVhPZlNJQXNFTDZQVFZHLzRtZUo3M3l4NDJLQitBNW92YUVOWjhYMXNNZTlYQTV3Y0FFWGRpTUhVd0hUb0p1akZKdHFJL25aYm5Ca2xIeGpMZVVkcUpFQUNHZkFLZnR5amtnSzU2QUF4K2ZBajVRTTRLRUQzaGJpcjh3YVZnNklET2tVU2hGM2FsYTJBWGxyZHNsVzRHeDJLbklXcEVYT2x4UXJEOStMd2Zrek0wVlpVRmplTHA4cUIwT2Nwd3pqSUVkejlJQnk0cndkU3ZoREpPUElVWkorYU5yc3hUKys5SjI2LzhMYWVmTmZlME9OdnRGNjZSZExGNDk3N0JreTcvekRZNDYrL3NVWHYvbDR6SFhybnB5MjQ0Ry9mbkRQdEduMzNmLzRFN3ovM3NjZnYrL3VDUk01S2xOVFFLYjJnMHlsQXpZZXErbDhEK3dXaW9menpiV1IxR3diZ21EZ0VwR0xxRFJsQUw3TGNGSzN6RSs5V2Vvc1pIQ2FtcEVEVW8zTmt5ckF6RG5GWTZNeUpLZWlzcEd6WGJLZnp0NmttUWNPeGNtSDlrRUVURnRVUVZWUmhZYnZjclFKVHlFbGYzdjYzVHZ1SHJoVVBmM3V3aytIemJ0cjVUM1ZiK21mK3RQWDZwbm9xOFM0K3ZVNU0xY0p1dytUdEI1MzNLMWVQUEMxK3ZJSEErL2ExZTNHdXQrLzhOT240eGEvTVBheDVTdHhyc3RCbU5hSmxkVHZEeVpaVVIxQkZZcFcxRWh4amxpR1JsVFcwMitLS1dGTENYd3RKMDcxZStKRW15b0VTSXI2RGZyUGdCM3d1VmF3bkxkeFlUcyt6aWJXSnNNSWlUci9OdWI4TzhxYWdnbFhFcGlRYlJJb3djcExRWVViaHU0dDh5T0o4NldYV3hGbk1yWVFlMUF5WUo4czVsYUxWVG9SOWdubkxpZGVFL0V1Rmc3RkN2amovTkRQeVo2L3FkdlVyZDhpSDJReVJCd3Iza3o1a01GcDB4ZW9hQk9CY2tHYk5OMUw4Q1VMTzZJM0NqdklrSysvNXJtdnY4YXh0c05ZaTlsWUZlVW1Bc050NXorTDVRdUhWditOZENQZHYxVTdmazdscXkxZ0RWVzNFZlpjS2plT0MvdVE1MzdnT1kveTVjYlIwb0t5NzRpUzZxdXRzYVQ2akNVUksrTUxNTS9DM3FVNkZTY0ltQTZVZERxR0JId0lOZXdnYUJaSjRkM3dQZFVsbTBIVzNIN3dyWFFXTHloZm1aZEFHY01FMmdlb3ZlVWRKRStveUdlNkdIblo5a05TZUl6b2J4aS9aS0JuWGJHWlRIMXF6T2FWYTRoTDNQZmxxZmVHTEx1L2srTjFjcnZGOGVtQWg5WmNQQjZQdTR4Ukk0YlJzRmR1NGZwd2Iyb0lPVWdYV080U2pGU3lkNTZnN0FncHQrbHFJNFhzZ3p1RFNvWU81dG1YK2dudDNKd05QbXpuVlB3d2wyNkFYN3M1bFo0QS92TFlaUE9jU2pIOFpLWi9wdHdGZjlPem0rVGE0dkxvZ3BWZE1sQ2I1RWxLVmpaVkhqV09uT3M3c1cxV0NUeTV2aE1vN2RzS0plcUQzeWx0TnZ2eml0dHgrRTh5WE9HczdKeEtEWksxUnoyRG04N080NlpEYjdLOEhTSVRmNFZmMEhzMXBWTXE1T1dLZXQ3cmNmbEUzSlIrZlNDM1ZDeElVdkpqRnY2ZDNQSFdWbkxIMlFVM2pGM1U1OUVWUlF1VjFZZnYvT1dHQVR1R3B1d2RaT25mWThLTHZaNTdQL2FyamVvZmowNTc4aGpwVUxQczJ5Y0tZdW9YTTg1OXVPNnhMdnpReCs4ZnQrR0plOGR2NE50dUpqM09MNWw3UXYza3BXa2ZUTDJoVDVjbFIzNDdhdWZjM2k5TXpZNUZiL2JjZE9meGZZOGUyN3JvenBtZnFYLzY5WHIxejhkL2VWTzNUcXR1blBENisxL2ZQM0xTenFmdmYvSnRXSjlPSEtmM0FQWXdBUHBveGZZMzRBMEdQL1JHRHVDSG9rZWJZUWxTMTBnaENEYk1pTkVBRFFlRWdPQU9DSjM0eVdmNFNlcUZwYkZCejMxUHZxdlRyYTBmVEFhcDYvaEt2alA2eFZzQjN3d0ZXMlRuL0dCRkh0QzBpTVBLb254S0R1Q0xGRDhkS3NVTVF3V294a1Fya1ZJbU81ek1hMEw5aVRaREQ0WTRGejV3WXpERkNNdm9kekFka0NMQmozS09TOVpYVXMxVDV2ZHBka0hNS3dndy9nTlMwOTVzNVdmVlRhLzZhTjR5OWRRUGFoVlpNMnZwYzh2VWNXVEFVMHVmZmx4OVhyZHFldFd6UjBhWHZyN28zWTlPakJnNmVOamhCNGZlZlQrMXE2RDdkU3RBbnJPNERocWFnQTFKeFZxeE5xSjlwNWRDZkFCQWJrU1BKaDlGanpva3NWR2NHQ2F3STdpaHdvS2lsYzlQZVdRbjhiMzhGakdNZTNYSXpnbHpQcDFDN1B1ZmZQdkJOYjFmT2pyemdLcTh5eDlZUVp3ZlRoei84TGIrZzM5VnUraXdlblR3a0xWM2piN3hmZElQOXh2eWVoL3cyZ3JhbzRQR2FZQTVqTk5lcE5CSEtiUUJRMjFPUlVMOENNVDZrVmd2R2g2RHhqNHE3YnllTW84cmI4Y2h6L3pyU05ZSGp6NzZnWHBxbmZvVlNmOExjYW5mbmxDLzBxMTZaSWY2NHd2TDFicWRZNzhpems4T0V4ZmxGZEFpMWdJdEZ1NVdqUkpUZk0xRldITWRFeThkaWhkejZFMU81cHBTdDlVRWJxdHNMbU0rcXVhWU1xZVVmVzBWaTZLSCtZT3h0a0s1YnRVcGRlRXBkZnBKTGpIdWx6Q3VpYnVCamF1TkNXalBxS05qR3BFUjV1YkgxQWEwWERMZ1ZyRWtlb2ovT05aYXQrcHJkY3BYc2ExY1FoNjJnRHprY0k5ejRjdzRFb2pMUXlRbE5WT0hjbTFKeURXSWh1eGs0ZHQwcVRic1M4ZHhmU2t3SW9xMXo0bjYySnFKK2pnZGJMNFI0YVVuRTlZbHZWSkp4WkNQRTJDQWJKVUFYTW82MXhYa0NTRkJoUVRTTG9rQkZLbXhJRktySTF6RGhGY0diLzdsaktOVEhqK3haUDhTZFNrL1ZMMm8vdTR6OVkwdC9JSG5pZVAzays5N1lFZXZudlBQekYvMnpleUhpZTE0Yk4xZmRwTStDWjdxQnRPMTdLSnBDUVBURXJJdUZCSE1sS3VDTGJHU3VGLzVNdG5pUktTSjRNRGdyRTJzSWVJQzlDcUJxVkYrWXpRYTY2ZGJGZHZJOTZzZnpnK09yV1hqN1lXWDNUQ2V3QVdTMWpEaHM4UFQ4RXVYZU9MZUtJYm4yTDh0YVRnckhJVi82MERFWXFlK25vM0Y0SWpzcEg2ZUdWeHdDVVZldERNWHhDaUJCOVhvMkFGcEhvTStMNmRrM1UxemZ6SHFDY0xQZnVvTDlmT1BOL1RydDNpK3NERjZSOTNzcHpTZWJLSThhWE1KVDhSUVUwYlFxVk84clFpbXlrcEdNZ21ZQUhRYmtBa2JTRGt3WUt4NlVQV2RBRjRFK1VPeEY2SUgrZGxmcVZXYVBLK2paeVNhaHFhK0dlT0hQczZQc0VBbFdOQ0JKQmthR2UyRnA1L1hyYnA0KzFlSmRkUlhVdjNRVmFOWm4wU3pqVDdOQ3FyWHlzNGRVTjNhVVVkZzJKV25zUW8yQ3lPYkJVNEJWcExrRVdrcnNaRUkvR2VOcXRjYjFTNHdqVUg4dXZyaG9oZ2J6TDhTamN2UUtyb3Z1emN6dHJZZEhSZzF3akM3b2dmd1FnOThXR3hRMFF0VVBWMUNRWWlnTE1Id1p3U3U3dU1vNkp0b2p2Q1grdUZDTkNveXJLN0htS3dMZHVqTlhOaEJzVlI4aDJZSmlXM3BobTNwZGlwcE1KN1p5MHhNR2dhWUhmU2dLUXRna21MbUxnVURxQjYxQ0UwT0JpeEtTWTZkVEhuMGZaTDI2aHFTc252c28rK3JYNzE2VkYzL0RqRk9QVWw4SjU1NDhxUjY1c1FVL3NCeTR0ZzNlZUtINnZjcmxxdmY3NXU4ai9UZHY2QjIvcnh2RnRIWHVCNjNVOW55eEZlS2FURlFMeEd6bGU0M001THZUWWlabGU0M0N2dEF2SDBvY1I0RXlEcE5vM1BVUlFxa2trWWoyTDZlRkw3VThLcjZKU2xZdFA3MUplcHgzU3IxcDgrclR6NnNobmg1OGNRbm45YjhuY1A2NGNCREQvZzdBN2l3UkQzQU9BL3poWVNUNHdVZWVwMDB0b1U4UkE4bnh3djZ6Q0hwVUorWndZT3pJemRUYWVDTE9YVmhtTXRsSUNzZXNLYWNCVlZXVklIQS9sTHVMbjN0MVkwN0xzVFp1MkRlbUF0cjZucGN6dUc2WFFzaXEzNmxzZmlXUTIrZEdyOWE0M0tjejFPQXp6Yk94OTJqU2FXSlNhWGlBMVpiN1pUVlZqUlMvb1RsdEplaDhYUnByTWFnbmd0c3AySUJtVVFyajhqYWJxVUFSZlpKaVFVUTBTdUJMZDlrQ2FiL1JESzJyaWF6MUtOcXRmb2hHVGYzbGVwRjZsTGRxcnBERzQ2M2pwMGtQNmhXL3VPbkgzMXNhanlPZFZiY0JQNTRJZmNRRnk3Z21Da051NUhjRkd0dGphL0FqU0VNV0EvbkVYcW9rTTcyY2E2VHJVZTZrMFhiRE5KbTBlcE95UzVnSjFCaHIzYXE0QU5YUE1JUlozb3UvRUp4ZzhHUnZja0JyMUpTVkNxZzE1M2pOeUNlUlZ2alp5QXJaOENLaHo2Wk1YRmUyYUtubjF3enF4TnhIeVhGSitidTNmN3dVNVZMRnZ6OUMvV3JyOVFOaHlMMzN2dkEzZTF2dlRFN3M4dlFSUTlzL1NheTQ3bWhQU3Q3ZEE1Y3QyUFRCMS9EL1BxQ3J2c2Mxc1BBWGNkT2c3VzRoYTFXRnNxb3M2ay9vdWhBM2VuME5JNElCanVzcDlGRlBZWVVHMzB3VkV0OXhRWHFkYW9vbnpsenNiY29VLzZ0YWFqVmpZSG5TMXlGcGczMG1pNlZ6U0V0YUkvcVZCYWMrRERGQ294REFHcEM1ZU9nRVZIUU53elJ3eHNuRjhqaDFrUjN2TEZoUjFSOVUvMkwrcVg2Tmw4bFhCZjk0NTQvZjdRYnZuK3NmcUJ1SVRmVHNUczFYTkR0cGpHWmdEWTNqcWR3dXpFa3crbXByb05ScUhISTYwVDhSQ2FiaUJUYitBVm84YkRZcTM0d2ZWYVBoZ3ZHdGJyVm9NZTdzYk01MlJpaWoxTUVmU2loeVFsNHpzUkpUMWdRNWFFbTF4TU1OVnR4c2RGOUR2TTZNOXQvTUdDSWpta2llVDNBVys5UHFnNlQrK0diVWJVZVUxOVJYL2tVQ0RnbWxsdzhMQmJWRHhiMUYrdVJqcDZ3ZitaUlBWV283UjZnZzJlNEFHMGdzM3c4YW13V3RzRXg0di92eVp0Vk15a21ENUxoSkFCeWJvUk5NRmVkd3gvamQ4VlVuby9kRk12anMyTW5jUndRZGQxeUdNZUl0dGJRaEhjbWF0TFJVcGx4ZmdaMmtxUndoaWFzQkhFb2dLR1drdVVrRVB0QUJmTTBtNThhZlRXMmh5L0g1OCtHNTZkVDIxU3EyVmlEVll2aUM5YmFSSGFBWW1EaGFnQ1RrdVpxbExNQWNNQTdXK2dWUFNCT2pZYUZYdHRFN2k5dlI3a1RiTTlHMUF0Q01aWHB0cHdHUlEwMGNxQXp4T01uaWc2d29JNkxpelRHVVRSUjFnQm9oSitvVGliejFBdjZ0YnZyVDc1SHp5WnExWHB4aUhZMkVTSjUvaytFbDQ3cWgrTEJCT0JTOVFML2ZYeE1OZzBZRThTTTA4WWt3RElZaytqalIwUTB6WUtkZmdVb2RneE13WE1mZm5Kc1huZGQ5dTZmbU55TkY4NExpM1RWSU1ONWpXZDZabkRDY1hjMkNTenFXQWlhNUZuSWVGSXVrL0x0aHc0SjU4a0d0VCt4cStlUi9xaTZWVHpVTUFYbzkzT3lRRWxqNUlsQkRka1pZUEtpZVBoaXlkeGRNTFlxN3VhMzZsM3c5em40OXhFaW9zT3ZZY0lJNzBNNjRpZEJGZTQ4OWVTeG5icE53MVFGOVh6ZmhscXhTT3hCejdNZjQ4SWVsQ0EvUFo3VjE0WWRHTTB4V1dvalFyN2ZnVUJXbDdCcDZRNnFRejJvNmdObFpZcmJvU2xTbEdnTGJDUFpJMjBXVEE1L1ZqNk5LZ2lJRkhUZVNveHFvMXZxd0RpbWRrTHQxK0xhR0FUMmVhVzhjckJ4cFlSRkxEc1JWS2Q5eisxNWVlRzhHYysrZHZPd2Q2ZWUvZnVGV2NkSGJYejR3cVI3bmx6ejhNS0pNMG5IVFp0YmU4Wk52bmx2NjliZmZoYWJQcnY2OXVvSlBmcFBIOWE1WkJET3NScm1XSzg3Q2xnbml4dXVZUWFxNG54bUxXQ1hnVzh5cUpRUlBCUmszcW9MNXNTN3k4cGtsMU5KUmVQdFpBZFVxUzV3WG5VT1h3YWRtUThYVmFxVU05QytvZThoYURnV0kvUThpNHdVZVlXa1lFZjFqMHRPM0I5NTV1NjdGMFdHZnJGVXYyM21ySEJreHN4dHVxT3hUZnQ3THZ4MDFzeFBGdmJjc1o1UFgvSGVqcGRYN25vL2NRN1JRK3pOcFhPZHRQTnpDV2dXa1hpTG1SMCtBTVYyZHZqQUtSS3pVTEpGQ25OR0Q2SU1rYm13N0JndEhuZG5BUnB3c2VtSld0VVNJcXhlZXJEUHFpNHpCOHhSM2x6VWQ4NE55d2NjZkc2MTJyQUVpQ0hDcXFwQjY3cmU4dnRubC8yK1c5Zm5IaGk1QXNTY1lvVmh3Ti9kamZ5MUlIL3RWK0t2c1pHL0lET0lMUkhMR2xKQmhzd094bDhMQmdkMDlqaC9MUkxLQ3ZLWG8veGwwNkJCSm9TNFZGcjRpaVQrRHV1M3FHYm9aOC9YMVMwNVdWWHp6TjMxVzJiTzJMcDF4dE1SUG52bUp3dDY3dUM3MVJkSDl0K3g0UGgwWU80cVlETE9BZms3R2ZpYkNudW9peFpiZEJvMURtY1pheU8yTko4SVc4Qm1wOUFZZ1RDbk9IMUFtZ2ZqckxLN1VrNUxoc0t3OWdJQXRnQ0xRbVBBcTVDdkNGQ21WODM1NFlVSE4weTV1MWlNZnVYNXpSTUQ1dC8wN0hyMTIrcm9zZ3Q4aVczeHBFZGY0RE5YRWJLaTA4UExOZzVwblRKemFaZXVNL1l2Sk9LNXAxNStpZW5OSGtEd2FkMlhuSmNieUhZc05jOGh4V0VFcTFhR3hzVmdZZ0VORHozWlJqN2J5OEp1RHoxc2xFeDQ1aDcyMFBOR0Q0SURHdVN3T21nQUN4QVFPNThwRDVXM3E4RE42UVdXWmhJR0hIck1HOUIvOWNpcTNqY3VKbG5xMTNYQ3NJTzlJZ1A2Wnh4S2UrMzZBOUZxWVpnbUQycEUzQTI4ek9aYWNoTzVzQXZsd1FSOFpMTFF3bFFyTzRLS0IzaWFudWZDS0VBNlVsdkNUcGVBMUJ6cUhDditBazBrV2lGZVJyVWl1U3JSSTkyc2MzalM4MXBRNGNqRGM2V1VTcmtGQ29laWMwaHgxeC9GdytjdkJ5UmkwQWR5aWlxWUxrRTVqOHVLazRyS1hmUGwrNTdhM0wxdS9yUHFFZlg4NGNGYjk2MlRlMngrcWtxZTM3ZGVtZm4wdG0xUHo1TDVmaE4yVCsvMndOMnZSdGVxLzVqLzdJeTN4MjlZMDY5cVJMZnA3NCtmdFg0RDBhLy9OVnVYYXNCb3crayt1S01STWRNNTI4Rm02dXlOK3NVZDF5OFlEQUR0Z2dZYVBEeXFUczB1YWlRNFJXZVhtaWdUVkkwU0ZYQ3ZWUDNqcklPYlAvcnhpVWZHekFXMXNXM0h5UjJ4M3Z6d3B4WXNmVEsybXE3QkswRFFCdDErR3BkdnFaMW9JeWxhcmdBMWRTSk5JVFJRS3BLajlERGNLOFRjd05XSko4NmV2UmdRS3kvdXhXYzJmSytHNlRNeC82a1ZpL1VEeUZCNFl5MEZOUGhVSjMycWxUM1ZYa2FEQ1dDdWdOOFVGUVp5aTNBRVowSE94RHIxL2ZJYlpXS2VwcDhGQTd5bDdqVHI4ODZlVGZCeE1mRFJ3clZ1akIvZ1Jrd0VEeHlOd1FPeCtlQkI5WTlrRjJtdDlpWHZxS2ZVYlN0MFI2T3p5QW0xZTJ3NitYaTF1cCt0MXdaNFdRUGpDSGh5Z2VNa3dpaXdGUGpWR0ViWlVLYzdXbC9NYURNWVFiWUQzTWg0dkRZbEJINFJpcmNlR1dJSktabldXdGtEWmorWFBpekFWam5BYkVnS2htK1pOK3FBRWZMUW5BUW9aTUpJcmFsU2RtTFVGcUJDWnZLMHZOUTAraThSZ2lScDZQeml1TWZXdG5yMnMvQyt1c2RHalp4ZU4ySEV5RitLbGEvMUh6Wjg0STVqZTJLOStPRy9uTGZvbDdIVi9NaHA4NStkRm51bFVWNWhMcTU0SEpKNmVJbU5ha2Q4OTdNa2xTUkpxdmZLa2lwV3JyOUVVSm5lUFFrME9HRU40bmtpbnJobFN6T3piQW5NRTNIUVBCRTg2TUIwcEN4VUVJMTVJbW1lWnZKRVdOdzQyVEJVUFU4c2ExNGp4dWNHclBoazZocTE3cm02ZDU1WkZubDd5Yk1SUG4wbEVWYStvTVplZk96Z3lrRmcyVll0T2ZEN1pVdjNmMGp4QStDeGVzcW5MRzRJMXdnZEdsa0Y5ZzAyMXIrSUd4ekp1SUZvSjg2TWdRbmNJUDBNM0tCdTFjMklOQUlIMVNrOEVFY09xSXUzVWwyczBaNHd5OFltdEZ1Qy82Sk50aWZiWkdNVG0xeU9JY3gvMVNhdnI1OU9vazF0TXBWUHdTWDJBbTNUTmg3cFFhb05GUFNJVE50b0p5SThVelUwaTZ4UkV0RitBVFZNRE50WERaeHF0dGpYN3hNci8vSExXMjlVNjQ4ZlVvZlJmWEJ6dzFuaEZiRW4xNTRZdVhBN2p2a0U0UlJxK1JGMlZ3UmxMK3hqTnoycFI1K3hyYnRXNmNCeVBMNWQ4NTZDT1I1MjJlR1V6VHVWUXV0UGNzbE8rS0hHNGpDN1MycXM5TldPcjNLaHM2YW9zQVIrYkVGZmkrbHJTM3dOdytjNTgzUG01K21Cc1dETkt1WGlTcmxsWlJqK05mNXNyMFNkY0lQRmFuZTBLREZiQ291S1d5YWxCcE1yL1lMbWxRUzhMTEtobDJxRWxLeDJHTmRvNjFMU00yaWlTVHNXNWMyU2FvZzNveTMrTGdVajZvMzVKcVZDVVdHUWxJb3NjVElSMnhEOUdONFFXZnJvelk4b3lwMEQvUVdWMXhVWVJOZDF2WWRlMy9MNHVtRi8rc1hROWZOdTdXTXZ5TG94djFod0NCMzYzSDk5eTVQS3BIT0wxcysrb2RKZmtKYnFzdkJFTDJWV2RIbWcwL0xJamRmSnd6dUZYTm5wN2xTYmpZaEV5cW5vVWxXNTluZDNZVDVkdzNkOHJXNG81OFl6TWlldWo4WENkaDg0MDVnN0xodks0amw5SXBwWFQxQjJzWncrQnp2RWNNVnorbVJiV2RoRjAvcGNpSHk4VkdZdzlnTXM1clQwb1BLUWx1VG5DWlZWZVBWNU9hbWsyN3c2a3F0K01idjNiVlhUMVgzQ3NNT2tXRDE2T1BiZDNJTDlGYVFUZU5WVWpoWUREaDRrVmpKOWlwcU1FYXUzYXNSaUlNVWROekFZU0FFRGh1bVBWazJmMmdTYTRNQ3hMQmw3NVNVeEZZcDBDeGZYZ1NxZFUxZUhXcFhNNCtYWXFxZm1MM21TSDNweEx5aFhSa2Q1UTUyNEFPaElpcWVRYThSVHlvbVo1SkVDSXFyZFRvaVYwYStGdElzNzZMTzZOdFRwMTRpZE9DdWV1RnMxRzhIUlUvN2tlSXF6TVo3aW9QRVUzQnU3QTJldm8vbFBwbEk3N2cyZDZTZWRMTzRVQU5xWU1mOUoxSm5NbXB4ZUduNWh0SVhTQ2Y0ZlhlVzhyckZQLy83eCtjL3IxSmMrUC9mRDUySmxMSjJ2amZuNXJ5N3U0TCtNWmJJNEVyVm5sWmZFWE1qVll5N3BXc3lsRTNsR25VSHM5ZlhFQ044WHErZlZDMm9kWDhCNzFHb3lMSFkrZHBoTVZXZHIvRlhEbEw5T3JvU0xzeFlUSFd5SVl5VXRCOFBHRG9SQnFoVGVVcG5nTkUxd29taTBvcHdZU1R1U1FuaTE3NDJ2enB6elJMOGV0NWJmbWdYYy8wTEl2YmgrM2J5dVc0czczSUxqallaNStXRzhwQmhNM0RNUmpEOHZCak9hSHhkYkp5eVBMZWJIYmVEMy9INUQ3SG9OQTQxV1R3alRkVnU1Tmx3dlRpNElLdmwybHJ1aEIvZ1daTjVPMjZEYytvaXNLMU15UUFPNnk1UXl6TkJwRFVPazRtTGxBemN6V2xiUzdMcFVVRld3aXI1S3RvMm83c2QwQUhBd3dSbkNiSE42OEl3YWhBY1BWQUN0Z3RaaGRQdW5Sb25GSTk2Y1gzTHZtSTR1M1VPakh4NmxjM1VjYzIvSi9LM0RpOFZSVDVIdjNoazV4VFhlY2RjVG8zcWtyazFyMjYxSEo4OGp2dkd6Y3ZObVR2Q044WFM2L1pheXRMV3BQVVkvY1pmak1kZVVVWFJlMzZ2MVpBdU5BV1Z5OFVpSTRPWXl4Ukx0V3p3Z0FodnIrdy9paWF1RUd3NzhtQnJuUjV1Z3dnRS9nQzI1d0E5ZlVQRnIvREFlUVhEYkF2aVJ3ZmpSd2lneDNGYUEwbVVzQVg3azBqaUh6NlhZTTJnS1RtZUJjcU45QlUxREI5WEtGMVdnajRoT2VFZmlaZDQ0bW4zRGNHU0RpR3dRR1J2ZUhBRnNtRjVlL3RSb3NYajQxdm5UMHNwdXViMlRaNHh2L05QQWd2RytSenlkZW5Scml5d1lCU3dZNzVveThwMVJVMXlQQWI5RzkwakZtQmM1TEV3VFhLQS9XM0ZnTTJuRXkwYVRCdEM2ZVlKTURUcHQxQmdvZ2w3TFpIQlQwSm1JRDlDczB5bjVJd1oxL2pDN1pSdi92TVE3bnB2NVpOL1NEc1ZQNDJzenRVdlVjdE9zT0wxWWUwbnRrcGhVdXlUd3VQdjFuTGI3UStYdWtOdUxlVkpyZTgzcnFaNG16dTdDb3VqNDd1S01lQTdONklZZnhGNjZkZWl6bytWR24xMzJobWdLSTNnTUViZmRSek1ZellqR0kySVcvVWswczRSUmRycVZKdEVqTFZSV25ULzR4MXlxckh5bHNxRlU5amtWYitwUHNnR1VHbnp6T1d0MFByMjdaRnZuUC83akxmZ3JDeFlDR2IxWUtXVERWMTJObmY3Z3dkZkdQNklsUWZEUGFqTHhWVmVUaGQvQzhGR1NyYytzRE1NajhKMnhrcXN4MnZ5WnpLWmJkWHFEMFdiM2VIMyt6S3hMS29FSXA5amRERDFtU1dITzR0UUNQR1lOLzNZa0ZTRURMWkFSYU93aHo1QlhVWWh3ek8rMms5RkxDTC9hbFIwcG1EMW1lZmRiWmo4M1o4bG10YzZhRnlsKzdmZm43KzB6WStadithTXJDYitpZWt2eDVGZTZaOGVHQ1RNWEhaUVBYVWNDYjQ3NGRRbi92UEFocXpzQW5iUmR0NGxMUjd0QWRWSXEyR1JhTENUWmFpT2lqalBiY0RVb3c3RjBLeU1vODBjd2ZwdnF4UFVJcC9Kb2hWUFRNYkVnMVc4cUNmT3ArQUVQWmhtbGdrYXhVclVUVGtuSExMU1pXZWhRZVFVWXcxQjVPMWRqSkl0RktBTGVHV3ZXcktrN3Nmcmp1M1plUDdIUGc1T0lxdkw4eWxmYWtwR0gzejFKK01mSHJMcmp0dm1UM2p5c3JqbXU2YitHMDdxUnVqQWd6QmxjdUJUblVRRG0ya3F6UXF5MUVZNlVXbUVlMlFBemRBRC95aUpHQS8wZ0xhUVlkWmlJUTZ0NXhDTktwck0ybkNuaURESURNSVBVc3JDWWlUK0pPQjlER1MzZXlSUkJ5azF0cVkwcmdMZkZvRFlWcjFHTGJGQ1ZDUXFpQXFiV25rTWZJSjRjQ3pNRDNlQ0hieGhONmt4WVNneFhOSG8xTDc2eXF3dHA5L0U5S3g0ZjNHcDd0OFVqSG5xOWhHeFZBNklJem02M2xwc21kUjE3ZHlqUzVlbDNIajJoN3IyZUhOaVVYdEVsYzlNUm9pdnFPYmpMb3FwQnN5ZHVhbCtZMFg3VEUvUGIzSG5Uckh1bTNFR01YekMrRkhHY3JqL3NZUjgzZ1hrTjhYT0ZpRk95Y3phRUFZb1RsS0tsTE9MeDBnOEFpbm4wQ01Yb2dhRDlpT3dDRDEycWxZMWxZUnNOZmRnc05JQWZ0dHZ3SjdzVGZ2S1UwVU5DbXoxK051RnRBa3RneHZTL3ZQSUErNjhJSU1wa01vbGtxZ1drdXpxQkxGUW5uR1BmU0RmZHF0aDZma0NzY3N2eUxZY093UXVMUlkxcDZFSDY2M3JRT0FoYWdzYXNURGZMeW5USHN6SXhtQ2pBMTVqYTJ0b3RQS2R5ZUV5dTRqTW1ONXdWVjRDc2wzQWR1WmxjT0l2bVN1dTFURitySG5UYTlWU2J0TUlLRXRTckRwaDJLNmZTanBVaWdxNlEwL0hqUXZpNE1JanBMVW9uOVA5RlBHWUt0TVROV3lpOWFiQzZzdktLMjFZaUNrOTNoZDNtRkhyeWFNMlRYRytLSm5ONlRvRCtEbmQ0QmRxUnhxTkduNStWd2RIWFBDM1loVlZ3TklqdWovK0Vmeno1K0xpamI1UEExbWVxZjl1Ny85aVh6KytiL0dEN2prZmVWazlzWGZUaTcvcmVOV0hWdVgwbnhzNVkzTzJXQVkvZzYwRCtZTTExM2FmUFcvUGV3bWNyMjdUcVhGQXg1N0Y3SjZYbmpPejhxOWZlVzdDMFE1dlNHM0lyNWk1cGZWTk93UTJoMWwxekNyb2d2N2FJdTRVZXVvaVdHNHRWT0dJSWcwNklJZUt4cDhiVFJCRkJvN00yRVlBS2VVUHd0U1ZhSFJWM240UC9jYlNHYkV6RGFYMEY3Rk1KTU8xMTNQTk1KaU0rbWhiSnNpZXo2UHRJaDdaMm5RMitzWjhLU3VoUEJWcnFiRWVLQTF3c2J4SzhjOUQ5a1ZMMlV5bE5jb2lZV0xMazlaam5VQ3E1YmpDSk9wODlxNkJGZVFmcStMYnRBQUphWGltWFNGdE1MaTR0dDVnNlZBVXVjTm0wby9xYzVBeUlDbzlMREpYbHU4cmI4Zmw1dVNLdmErSkdKZG5XTVJNK0lCNVNSdHp2ajUvd2dYcDI1VWZxRysvZHNaRzBmV3NiS2Z2dFJ2V1BiMjFURC95VytFKzlNZnlaVGxYREh4b3hmLzZJRzZ2YVBkQjEyWWoxSnpGSlNmcHc4cVM5NnQ5ZmVGNzkrNzdKSDVLNzkyeFdENFlqcFB6TnphUk5PS0orOUp0Zm4rblVjZXpnbFdNZldobHNXM1ZMdDlPVXAzeFhmcm51RlJyL2FzSE41Y0l1NUtPTnBacHl3UWhoNzlLQ2tSejJyakFZTVdpY0xOYkNoNUZNeHI1TUo0MWxtZnhsWlJFdjQySEx1TXB6Z0gyUzg2UWFnODJWUnJtWWt3YWYrbEtvM010aXBXekFtZ0NNb2p2aVNmZkp4MEx0RzArRkNwTVBoY2J3eGJIUDU0enQwYmZITGJmZFgvVHc1Tmt6Rm5TZk1HaktvbzdCcmdOdXVMSHpMWHpYU1pOSVpQQlFuL242RzR2R2htWk5WbCs1cGU4RGc0dUN0N1F2OEpXQm5BN2krb2xqaE5QZ0o5bG9sclBmUkF6YXQwR2szenZxZVdKL1J5WjkzMVhQRWNlN3ZFY2k3MVdwSzlUbnE4ak94RnVxSzllVE9uRWMrRWc2ckhWRFQwL2hoTnA0dlJsMVNQV3Npc2dOcUYySVd3VXRHd2xyeXZLazljSytNOEtnTDJOdms2SC8yZm91c2NsZWFjTjE0RFpmZWJjRTJXNWhtY2ZoWUZza0xwZ0xtcmxWV1NTdkEvMWRucmJpbGMzc25UYnNwN1psY2h1blVzNEtWMjJzY0RWcE0xMEhnbERlUm5KdG9YdXBsRmIzdHBEazFuaGtJcmZDWFJXVVhCRVRsMWJpd2w5MWtIN21iaUphTnF2ZTRNNFQ4bEx4cEFVcmozN2VYaHBEQnEzbzErWCt1dzdKdTFidjZ0Nm5UL2RkUDJjZnhiNFFqUDJ1SDNYUDVCVDFPTEdxUDVCbnVrN29Rdk1ueEFQQ0VOMHNkbWJMSENqOFNqcXp4VVZhdzc4akh0aXlCV1J2a1dBVktnQzcyZ0JCM2N4T29pTXBiSmRaZ2hGSjR6azkxWXZZR1ZQdDlMZzFZbVJNeFhJc2p4MFBXMFZXTThsQ05KbkVrN3hQV0JCMjBSL20vT29QZi9qVm5EODg5MGpmdXg1OTlLNitqNGdEeE5sNzlzd1daKy9kTzd2M3hJbTl4ZDdqeC9kRzNiMklDNGlMeEswMHhuOGZSNTFtR3R1OGRpR2w4NHFGbEhqNDFGaExpYWNEMG1YbGxGZ2FzSWc4dzBvcTFlbkMzL2cxSjBpRnV1K0UrZ0c1TGpiOThHSFlYUndLTjgxOTFJTm5ZUVVLQnpIc3FXa2xyVGhNNHgwTkRrWkV4anZSaVVFSmRQMlFkNWpkaS9Wcm0zVUdvOWxxb3pySkRCaDhzMTQwV2V3T2FtWGJZbmNHRXdFZ29wTkVManFNM0tlKzJwWGZvcTVWMTVGQlpMQjZndERDNXoyOGtUZGVYTXhiK1BkakYzaHpiRldzVG5UK3I2S1ZrTzVnci9sNC9nQjMxZndCNHZZYlNQZGpKK3ZGM2VUT1lYOWp1bXFWdWxVY0xWWnlIdTRXbGdVblcwT0szcFNJZXRIUU9Ndkg4N0NEQkUrVDJCZE55ZE5qTk4vdXJydzg2a1ZESnRLcUgyYzlPSGJCanorV3JSNDVPWVFoNzlqeVI2dFhUdU9yTHU3ZDBIZlliYXFXQjlZWEROdHVtbmRUb2NXK0JENXhjQlFSV2NreGNGZ1A0QU8xc2pQQ3NjKzRZTHpJdDExK0NDVVNORTVoWDlLMm5uUlRDOTVRZjZvVzloMnRyeDlPZmhoNWxOYVJrZE9rR2hOTTR2cFpyTDF5OGF4Yks1NDlyWlhQQXMrdDZpWitPbkFzS1dmRDJvVG5sZ1RQZGU2UVFLeHZiVnRWQi85cTFmOHEyUks0UVlBeDl1aldVbjJTam1kbXVCeVJWS2Jwck1FNDJqQUZ3VjFQMW5sT1JxOHowUjBocnZPY0dHQ3gyaW94ZzFBeENmQmRINiticEowUE9QMWxuUThRVUNRZFJReXFlWHFXRW5sNmxtem5lNm1ocXU2MzNZTmY0dGdaa2Npc0daczNxLzBuVGVKTGJuLzRvVjYzUHpTYStSQ0FFNmJIY1VLRmlWUVFMeWxnMzhaZ3pzNDdwSys2aVhSamIvdXBHOE5rRkJrOVZPMHNxVGNNYVh6TGVrajgvenJzLzNWYWVhNS93M2RpSHRDS2RXd2p0TXBST3lCR1AwMnVGVmtkbTNiTWJXRWxFVmpTcHFjbGJRYldEQVNyMS9RK2V2NHFHeVNxT09WVWwyS2tkYmZ4NEpCUENuTjZwNVpHM0pudlFrSnVnMGo5RHBxUmtvL0J0Zjd4dWpWMU50YXRyZnBRL2ZTWVdrK21FeGRaU292WDFxa1JNeTFlVy92bEtVRmhHa3hnOVZHR0t2RHdMSno5OGdvcGEyT0ZsQ09JcDkwY29BZnRVQ05SSVZVQnNLMXBsZFR5azhkMnZwSlVLYVdQRGxQbGFER1dTelVaMDl6Y21NWm14cnk4S3N1Q0p1elN5cXloWU5HU3E3UElTdEo3Mk5uR01TdGhURHZnNmN2R2REU082UXBpUWl5TXljNTFHOGRNQjdibkZSa3VtZXI4YjcvKzl2M1Zxd2NsenhiRVVEMDhmMzYwaE5XSE5ZNmR6bVVsYWdNU1kyZkV4NVpUZ29yRlVDdDdNY2hnTjlCcUsxWm1SYkFhTEt0UzlrcHlPc2JtYVhKTWdoZk54SGVscGtTT3lCOHhxTlB2YzFxV3BzNUx2RXNtdU9EcEovdTJyaXlaaWEvUlRuU1pZQnN5dW5sTk5senh5clptcEFNakFZNlFZckpoVFRrOUhET3luSDBRZXl6aGR6blp5WmdGZzJRRXN3b2RFZ1lDWFM2RnQ5R2lpOHVFcWp6azFiNGxUK1NWNkVhZ3UyODBRYm56L0htVUs3THkvUGtrMmJLRDNzQ1Q4bUVheFpZUW5vSTRyZGo5S0tMWGxFYzJOa1dKdUpueWNOTWovamdveDVOeXQ4QU9YRk9sc0Y3bnd1Q09rZFdVWmpoQml3aEdNM0g1V0RjSGdtRWN0RktHaEd3bW1hbE8vQVAzTDlxMnNJb2YyaWluVTI5dlY5NER2M1JUdWo4eWFQYWNlMGQzcjUrYkVOcElxTWZ0N2VFTGJWWXF4eGxxYWEyUEcvUDM2Y2tkRjJwU2FDYTd5aUoycHhXWHdrN0x6cXlKc2pOUFVMWWRrYVd5UkJXWTdmTEtNeTlMamlHTmxXZndKV0RaUzZxUUk2Nkw4ZnlhMkJEQmVERWF1N0FkYk9YUzRrUTFta2J3YkphUHU0bldEZVpnWG1OYXZHNHdrNllySllvSEV4VmlMTzN1WHlvZUpBYWhxS0x3eXZXRDR5NytkdTdSTlJ2VWZ6N2ZiQVhocE9rR2RjK2c3N0lQa1BieHVnaXhGblFRNHBrN3IxVzk1N3hXOVo0VUwrT3hWbDVTeFVkQU9TWlY4a1hmeHFUZE9BT3BXdVF1bytmVy94UDBYRW9IYU1za09tSzlqcDJxYjZURHlkUmtnbzZPUUlmcjJueHhYNHNPejVYNTRxYktOSmsxMDc3NzZyczlMNjFPcG9xcVVVNnJzUVc2ZU1vZk56ZnE2cFNobCtBTVlTWWJ5RDdkQlZjbHM4WnE0b3dsaXNOSlM3TXdwY3NOK3NwN09RKzFtR1l5MGM5Rlg0d21VWHorUE5WRGZBTTI2TmtONjRteDArSjQzaDcxWUdqQ1hqeFNxaGd3ZUV6d3lBdzVKS0FwQldmSkNsSlNGS1hpOGRQM1d1RWZqeldEL0lyR1p5WlZEU1lDc2ZTWjJHd3FMT29NN0ptWUJTSEE2dStOZmszWHZINTRZcm1CenEvZ1pSMnN0eDVzY2JGV2VjQXFDUzJza3RCSmUwWlI2QlRtaVU2ams2MGVPbmpwYk5VQzBmaHl4UWtXR3FMdzdNV3daZ0sxSUxja2NRRURFVVlXU3phVlVhZU9zYVJHTUlpTlRjTmdQalZHK29FbFVWMHBvRjNBR2NGM01kbzIyaWFLVEdkajRqdmswMkN3QVhyUW1kajlib1NXNXlYRisxZWtDclVSd2prRVc0bWN3VUloYVVCQkZ0Z3ZHdlRBL0xUVXNyRGtRQ21Sc0tHUFE4SzNEb3g0U0U2VUNzVUVDaXc3VWZCbzhtcG5Qc2xGeFFISkhTOHJSdUVadklyM05kWVd4ODdVa3d5dHVQaXZaS1M2Z3E4NnhROW9yREhtcTlUWnJNeFlmZWFVVnNPMXlvQjVBNW5jbE1zcUN3RmtLalpBRFg1RURVNUVEVm5OVlJwbWExdFI0YzFneWdTcHh1YjJaNkxpQmJmTDRHbFMrQ2o3SlRtVEJ2WE1sWXJOU1hPamswc1JoV1lBUjd3ODBkd00wa2d1V1d3Q05VQXlhUDBpeURUV0wrYWo1bXVtZ3JHZ3VRckdRcTJDc2NhaEMrUlJkUCt2RkRFaVpyMTJJZU1zMkliWEttWVUxbWc2L0w5dExxamFyejBYc2doMi83VW13MitKNDJVMmw0NTBMa1ZYbUV1TDV1WlNuRFNYL0g5NUxockd2dlowWnFQYVdmM1N6NWhRb3cxaGM2cWtjMnJIUGRqTW5PUzJRU1VmOWxJcDdxVWkzRXZsemMyeGZkSWNTNXJPVVNuRk0rNTJsWEtSSkFkK2xpUTJsNTF4emVrUHpSOUpOMWZyeERacm5YcE5YdXlmTmExeDZ3RytaL3pnTlhsdHdVMXVqaU9BMlFwQ1NpNW82c0l5ZWx6VXlJNEFkbkZralIwTE1IY0czclpvWkJJZUcrVUg4SUFvQzFSS2dVUkxqZVVXTHNXZithK1dITWNQRTYvTmwyb3d4OWVXQ1dxbENUZVgyeVl1RS9lQ2JlTGNKbEpob2lkR0pqS1hQS2krdUlZTUl3KytxcTRpdzE5VlgxU3J5U0F5Z2d4Ym82NGtJOWFvMWVyS1YvQnZVS1pHQWcrSEFlNU41WEs1bGxoNVJhMHlMVHNwQURhYWVCWkZ6UlpZYVFTWXVUUVBtQnpXVEZYeXNLcUlORHhkSTZuSUhtbXp4WmRpeWtRdElHT0FqQllVWXpJU1ZrZGtTNXVKWFJJeld1SnZUVnFmd1lwQ3Zwd3gwSS9aSW5FZWduWDIrUEY4RGRnSDRnVzJxR2prL2tGVmxJTm50ajd3NCsveFBmRHdtN2NleUJ6Q0w1N3c3TUsvVFAxcXdyTWZFKzhRODVjUEVMS0VNbkhxbUsvdmIrQ1dVRFpPZlpnL3VuRTJmN0x2L0RPeDkvcVNscDlzbk0yd0s2MDVOZlFIdjlyTGRXeXU2dFRYWE5XcFg2czZEVHRjSG9ZcUxxODhSZlI4U2ZVcHlUNTViRmR6SmFpNlBVd1IvNWZTQTZyMlVuck9mWHF5dmpsNnhHTk1sOGJwcVFSNlVwcW5KN1U1ZXRJYTZmRmVtUjZxTGk4bFNmL2RWeGlUYUphcWszR0ZLR2gwY1pSUHFZQ2FMcU1NNjVGOEljVnRZNmsvYWNsa1luRzQxMGtMNG1sZ3kwbDdPY2VKeDdDV0Q1cytPdlJYSWwzYjA1ZlNuaEd0ampaUGVCeGJzMXBaV0Y4alorWEtMNjJXdFNXcVplMWF0V3dOYnpKYnFaYSt2R1EybmZnTnlXV3oyUmhBU2lxZEZRN1JSV3pzVjRCMTlMY25ZZStrQW5vOHk2VnRRb1RrV25xRnQ1Y2xxdWtOckpwZVM3dzNhUG50aWRZRlhpbFJOeDhsMTEzZXUrQ1VXbi84cFpNUGZVY09MbVc5Q3doWDNSQVZsK3ErQXYzOUFJdEFZblFBODNkeWdvcG9TZ0NPZkltcWFReThHeVR3eXcwMHd3bWJhcWVWeVpsT0JoNnhrQVdoU0dZK2JUdU9NQkRqSFRsWWxHRndzQklXMnA2TkpxbGdROGdTVXM3Nk5KZHJ3UTZ2VkUzMEp6ODYrOFNJRzBiZEUxTC9laUh3d3V0dkxQMW0zSkRodnhURkw0ancyVyttcjZ2MFhqOWcydTA3am16WGpSOWROZG0xL2xGbDRFT0xKMS84Z2Rwb1dzZXFkM0ZwWEJibzA4ZVRLMWx6bTFTeXRtaXNaR1VsWjltQWQ3TzFTdFlDclpJVmxXczJla01XYTNvbHJXVkZ6OC9oejhqTXltM3hINnhucGVIT2E5VzB2bmZxMks0UHJsYlhLbjR4VEZXaU14TFZyVTNuWGdoemYvSm5WZkdXWExHS3Q5VWxWYnhzNWxuNVJTMm8rWEM3NU9ML2REMHZicCtyMS9TdUJOUjV0YnBlb1hYOC9GR2J2KzQ3bUgrQWE4MU5UNTUvUVpQNWx6VE92NVRPUHhmbW42dk52NFUyL3lDMmhXaTY5bWEyOXRtQmdoS05CVm4vSVJiRUk4SFhrb0oxTERiODZOVUVRZmdIS3VSNTg1cVRCZDFaNEVVcGR4MzNXakl2eXByd29rT2NGeUFLV09ZaXQ4Q3RIRURzU3JPa2xDRHdKcWp4cGx6akRhWkZCWnZoVFZhZ1JXbFpCOFliSmI4QXNVY0gzUDJjbC9xTWVFaEJZUWVHYjYwSTV1UlM3TzFJUzAydXRtV2F3YmpYWk43c1pqekpsS3R1S1FObUxpTys3ZE82TXJvOHprNVI0MlZFMHltbDNPcy9RNnZJNlVHNUpLUmtnT2xyQmFZdkdKVFRqeWhaenRxYTdLeDBqRkN3cnArb2M3S2E2cHlhVXJjSC9xREVTUmVrRkF4QUcyeVhuNDYrdGI4U004NXFUQTVOK2JTNE1tK3Z6azhNZ2lUeEQyMXBzeng4Si9wZWdtTkRvczJMMzdsekNkRVRXcDg3RitlWGZnYlZRMjI0NjdsM2Y0WW1BZzVGMnJFejRPdUNrWlphaUwxVHNuWXFJaVdSdGxxaVVWTmRWZE1LZVJhcFlMK3NDRVphc1RCOFo2elJLcEpvaDlBS3FzQ3k4b3RibGdZZGxIdjVWK2FlY2wwNytGMnJvc3FmcjhyY0xJU3ZqK2ZjTUh0MmRlVld0SERib2tYYkZvNk9SL092cHVoRUs4YjVCODJaT3pBUjNXZjcvTFNoazlnYjlGMGxkd1Bxdkpab3c4SGphZ3MyUEx1TU5RNDFXbXJESG56VDJWZ2J5Yml1cFllbDZXYllhK1h5TWpuREtWZmducWY2OEViSzhWTFk0MTJCZWFXby84MFczTWNaYmJIelRXNWVhUWkzOTNWWTVLRVlCVmJiWXBjVWk1VE1xMENjVlg3YTBKZS9wQUsrcUpGN0ZTd2Z0WUNWeFBmOSsrNlhGcXAxendDNzNubDg5cDYyWFhkUG5QckJ0SzU4OUd2ditzY0hMcmhwNlViMSsybkhlM3grZXZ5YmoxNFlQM0RqYzluR0J4YzlOb00vekxlMkxaNzgySExTOGJkYldudStRZjRON3YrTCs0ZThlbWhTcTFSV09ULzBGMjlTWmk3b2MzdkJQUjhuYXVpcjFFMjBud0xlYzVIVVJpRXIwVWFCQnVwRWkzVDF0Z24wY0tIWnhnbjl0czJjZld6dFc2Y3Y3NXh3endnOFVqaGZTbHJET3RLK0EyQzdVeWtsbDNVZXlNWE9BMW1OblFjS2dvaTBMdTA4a0hXdHpnUHNxUFhxM1FmZVBYbHM1NjZyZGlBUUt3Qjd4RjdYZUpoTWUwNXp0Ri9hTmFGNTJuOXUxd1NFRE5mc25MQWNZUGlWdXllUTQ0MllnZElPbUNHVnhxa3VvNzBBYVE4MDB0NGlpQUdxUzJrUFhJdjJ4Tkh2MVZtL2tRV2xKbCtWKzBKUFp2RGpDeUJxYzRob3NrUGpNRmVUSHZURFFFR2tONFprMG1qZEF1YnVhbkVZbHJPTDJiazJGbnlwY2ZyRVhKcXY2VkxjMmFnUE1LNnJ1TUhUbGJPa2Ewa2RQWXVsVTBkTGM4WHA3NDd1MDJaTytrYXZOUGx6NStqRXlYSE1DT2NiRG1QdFBzMVpTem9uSVVubkpJNnJuWk9VZ0t3WDFORW1PQmM3eGZzYllEOEFmbUxqTXhNVng0bHpFc2ZWemtrMjFIMERtQlVmMXBnYnh6ZnNnWmZaSUdkTnprbEkwam1KSSttY2hQQ1huNU4wWkZpd29BNmVTdGMvVHJEUWNCeWVQVmJMczA4Nkp5RlhPaWR4L0l2bkpBWFIxblZCbW9YUHhzUjM4WnI5N2JyVElIWEYzQ1BhcVczQVZDc1hnZXNJMXNjVWhBR0ozSkx5VExzZUtCKzlmcWxXS1VGTXd6SHJrUys5S1pvTVZvZVVaa0VKODdMYTF5SU0vWG14bWFjb2dlcFZyQ2J3eEkxMnA2VFZQakR6SWhpS0tvb0MvZ3Evd1UxYm5QT05abGtyOVo5MmJQWmRzMjQ5K3NQUXVza2tzKzMrcWtOYmh2Uy84NWxqTTZwanovd1FtYmR3MDVhRkN6YnczS0xQcHhTWGtJS0haenk4cHZ1QUdZUFV1cm5mekIyN2Q4WEF4UmZtejl6MjF0d1o0ZDloL1QvdDYzR1djd0d1bVhxRlRnbHlYbER4QVlyT1FZdWFha2owU2JxOGN3SUc4RnhvWDkyRnRQbGZST2RMemNsamtUa2xnOFk0dGM0ZlNnNkI3NFcwNDdtNytlNEt6UjJwSkhWY1dOWU1GcjYwQzRONE5BbitKblRqU2RnSFRzNEQyckdYMXBVaEpkNlZJYXV4R2JIWFFRTTU2VnBYQnV3TzZkWGFJYVZMRVp0TDlMaFptRHZsaXYwWkd0M2lLL1JvK1Bya3NWMm5yOWluUVd5Tk5tbEFvbHREVS9vemt1aHYybFVpMEZ4WGlWeXRxMFRFSm1abTVlQ1NHQ1U1KytmM2w2QTI2b285Sms1andPOUtmU1o0VDFQYmRCSjBocFB6YzNuYzNScjk2WEg2QTBoL1BxVmY2eWFTcGRHUFdqeUZpeGNHYnJhNTNGNi9TS2VCUm90VEF1bFhuRVlUMS9RS0szR0NIZG11ditKaUNGMDFFOVhNZXNEK2NZS1Zhb08zVGRENXRJalBwOVFNS2lLbytHSDNCSEQzZUF5c3lCYm1Wd0R6SzNCU3JZSHp3MHJiQW0xK0pUQS9UMXBXZm54KzZUQy8waGJhL0pRc3ZEb2huNGFpcE9hRTdvcU81UldtL203U1JobzVxTk0rZk5mcnluem9uN1NsWW1NYW1TRnF2SWhvZXlzZk14SXUyMTNZNFQ4UVVseWd2WFBMNHBFNDJHbzFraGZ6RFR3c2VwcDBpcEp1WWZ6QklGd0FSTFhHSnFaa1hYUGpKWnhCTm1kcW9pK2Q5NFZvZlh5V1pQbkZaaFljelBLQWhBalRZaTBCN09oYWNieE9yOW1sVW83V1FJanhPd0hvbFFCaXJXYVZaQ1B0Z1N5Ynl4cnZXS0lkaU5BSWJSRDJ4VmFxcXNvUCsrdGYxUnV3M2tMb2o2L3c1SzROcDNVYzRIYy9sdzM0YllKbXJUMGN1NnlPOWdpUnpTRWwwOFRPR3dYWUt4TGRLN2hISEJJN2Iwd1I4UHpFVDVIT1pwUEhaMGlubTk0QnNJNW1sK1hTTzZud0xyRk1xY1locE9GTllyTEJwWmhzbGV3RXBaenkxRjhSMGh0OFdzZVcrUEdKM3MxWVc5VDF0ZG5JMVRmbWR6ODVxdE5jWk94dkZ0MFNESkVkUFFZLy8rYUdXKzlidnJXZGVjdUxmMGJPRHVnMXNkc0x4NUMzQTI3akMwYjFKV2ZiZnFSMkNINzAvQU1EMGU3Uy9oSjZKOWdoSDlmM2loMG0vRmZvTUpFU3YwN01qZkMxeHVueCtxaUlYSzNaQkNybjVJWVRHMDRkMjNWWjB3bnhsTlpMOEQ5UEgzYkFxSEc2UFVnWk52UDJYb00rUEZkcDBoQmpMRGdBbHhFby9KakFZNHhHMEszb3RReThJbzFwVjZBeHZRa1BJOEJEZnlvbDFTWDdya0dxcG1DVHFWM0lvTjNsOVA3RTFDanVKVVp2aFBJMERidXBOVXN4WmxUNVE0ckh4a3FTMCtQazE3Z0YxQmcrNXlVVHFVbXoyb3owOWg1WURpVU4wQjllUU9OenN3dFdRR25xcnlVWTJpbE04blRXUkt1anpjd2xYc1BKczc0WklCK28rNXJwbk9FTnNrcVFhM2ZPUUxoOWhlNFpXSnJTdElPR3VJdXR2dGJIU2V0VE9KaTd2QVVrb21ieW4rcmlwRXQwY1pMKzlTNU9odXprL28vSmJaeEFEaWp2Tkx1UlFqTnFtM0FQVFlhWG1ReGZHVDBZbEk1UVErRmhxVWNwMnNHZ0I5Qk5EYkVablJSeFMzaTdVQXJTL0xPNHJxMTU4NXcvY2JFNmVpbm5kemV1L1JTT00ySTl1UWU4aHFGYUZ4OGJwaTZYc1pTQmRBRkx4eU1tcXhNN0FwcXNpVmlNMWp3YlZ3QTdUR00xZVdxOG1oeGU3YXdwTEkzV21LeGFZQytlR3BDVW1wcWJYOGdYZUxpT1JNckw1YVk4K2dISldpY2VTK1NvWnE1VFQzM3dLTXpMZmVMRWliK28zMkVxZ0hIbldDMDk3NUVkeFBUQ1lmVmI0YUQ2dllabkRPZkI5aFJ3YmJrTzNMMWNPQmM5Z295UVVteEc5ak1QekJKU2d2QmorN0tJdXl4WEY3LzZreFpSS29VZ1d0Y2h4Y1c1d1BTMFN0a05QZ1BldzFJRzJvOHJiSVdMRTVTYWRESnNQcDdHK25ZbVExQ2RGbW9ZdU9Md3BMbW5icjNsMDFsUGZ2aFVWL0M0dmIrWk1uREJUYzl1Vk04dHJMMnQremZ6d0s0dXIzdHJ3V0o1NjRKbndzSVV2clg5bVVtUHZjQ25QM1pveGFESFI0eWNqREcwekJiTUFaL3kwS2lwTHhCeEpUUDArMittQVFoQk8wL2w2SG1xRXp1Z0o1K29vaHRvQzRFaHhUNkE5TklpZHJ4YVk5VWJRUFZnVnFVcGlHZStOVGI2Z1JNa0ZJODZiZFlyOWltT0MyRHl3ZXQrVURwTkRsNlBhY2U5c0Q5ZUVYY0xWZFQzRHRBcWRDR0VaVlplc2FTWmpyeWFlbjZGcWVTNHIwMWxsL2pGN1h5dGZnWm40cnpjblJ6c3VIalZranNZRWJTSU5VME4wSzdha2MwMEd6U2lZOUZvOUM2Y1p0aDNnc0hJVTZYaHhxYm9Pb3JLU0xQaFkrSmZ1RzNod3FRSXNXN05aVkZnd2swVE53bXpBRmYvSCtqck1xMDVSN0dwWS9nL041ZDJSYlQ2NHVXNXRJVHIxWEJDUHhKMFRqWTNtM1Z0a0IyaEdudVd6VjVDRldVV2pHUFJhT2NFN0tNZU1hUmxJZmtHTExUT0NjcFpMRDRHRkdkbTBZTnY3S3FlUmZ0NlpHRmVaeVp6SGZIV0RFVGova3pKRlRiUTI0ckJaY1FiUzh6K0REd21NN0JlOTZ6OWVudDZNeHVucWRYT1BEdGhBUEh1SmE2T25kdjExVEZBdUJlT1B6d21XSEZEaDZvN1d6LzM5SjlmaklwYkFBQ1BuUmM3OVgwRFYvQzVLNzNEc0pzbVByVWdkbERjRXMrOW5tYW9vdjEyV2wxeXMwdjgvZ2lkSTdtUGRwTmJYTkJyM1Nyc2laV1gwRHpmdjE3c2tVajBaZmU0cktiM0JBN1I3dlh4V0xVc0w0dFFHN0ZMNmFqYjdHYkdNQ3pjWTRYcEFhMVViN1BPWXBjODZWVHNKZlNpL1ZqMmI2ZDlBeTIwN0w5cEFqOXJqaUJpejVQNFhWR1kyRlZJOC9jOUwwZlU4WXQzZmlJM2NBRitWbXhxRnVGcnBtOGZzV2FDV3J0N2xYcHV4MWord0F2RStlR2tDV00yYmpnbEg5Mzh6ZUFoNjZaT25mQ0JkdS9PLysxM0JQekg3NGI1NzhxNS9uZmRTY056NW9idmpkdGhuQURYRXF0UWZWckdTNjRWV3lhSGMyalRSN1BXK0NjRkJidGxqdFdtM1lGYUVwUXRSNVJVaVdZcStaaEV5TFl5ekJ4QWo5dWxKVTJrV2lRV2htaVpTKzlOMDdvb2RoWmRTQ085NWtLa2FkMGUzaTdrNVNZdTN6S241cGZtbFhkcVhaTHVGQTZTSGhkSXJucmlwOWc3YW1wYVJZOVJqOTArUUl5U214ZXRxRjZzdnFjL2FIVUU3MXE4aDJSR1NIb3NldmJ3TWRBTU03NVFOL3o5MVhzS3p6MzErQ01UNDdVWXhuZGdycGdSY2ovRHVUaFh0NmFvNmMxRWtnTnZVTlV1ZERja2ZJYkdjS1dEM1Uva3hqcnBNc3phOUxIcnh0QlRnSzJNcGJZV1g3enJMcTNqVDB4UUtnamtzR3lrZW41amxJeW9KUzcxN0EreERiRit3bnJTbS9pWExGQWpZTFAvd0pmRi9uQnkvNS9POEV0alkwLytkZmhEVkdkekhOWFpQdXdrN21VMVdFMVZ0Tk9iVU5GKzJwalR3NW84ZXJ5MG9UV3FhQy90ZE8xRkZRMzRGOFByRnMzQnRIcTB1M0lNem5nci9rYWxIQStySnBUeG5wT2dqSDlhTm1mYzVydnFxUW9lTWUvclA2a3VzdlJYTDk1OGUreTR1S1h4cnBSTldnMU9jemNlT1pOdlBKS3VjdU1SMWNSTmJ6M2F3UkxMa204KzByUXp6NFVhYW5YckROMEFlNldqTDJ1a21CcUVPSTdBMG9LS1I4ZDZ3MHZKblR1d290cmZXRkh0UTRlR2Q2YXkzaXcvd3crb29BV2tkcEpUR0NMcFpEdVpUNXl4UXdOT0xIbDJUbFd2b2UybmxMMjNzbmpHVTYxV2VEYXEwVGQwcTZMYmhhNFhYdzZ2N3Y1dTZ4NTlkQWN5Rnk3TW5MMXFGYTcxRnZXQXJqdXQxZS9PdXNaamt3bTh3c2xDbTZSWWFJZUp4aXN6a2x4eUdrdVhLRlFRdFo2VFRTL1J3Z0wrTGZYODZubzE5SU51MWNYYnhEZnJoNnNIU0lpdTEzLzkzWDVNSm5wbzk4MzFpZDgzbDBCS29HQjBYb2FVekkxWHp6RTV0bEVyYlVOd3BGMUVaM0ltWDBSbnFrd2dJcmJqRW9wa3E5ZzZlb0FzK1R0SlZmLzZrenFOOUh6ajllV0wxTGxnMHRVM3Z6NXcrS3VURDA0ZjhmRC9aZmNPVXV5VGZBZFlFdkxSTjRkOERFbkloNkllaW5pb1hIaEFIcituZlBHZzlyRnFYQUZQcEt3TVcvSENJNngyMWoyZkFpQ1hkcytVSGRiT1RhOE5SR0YwU3pUSjNjbmFXdFdZRFU1MGQ5eTB6UVVZTjlZNDJTMnhTM01xUXUxZEVyWkJFZktrZ0pCSDBEdzRQUXNIRHhKTzErUWRpdHBUdmlBcitPV3EvdVNiNUZOeTcvNkx0OGJPa3BCNmdQY0loOWVxMXYvR3V3U3p3Y1lzaFhIZGVCOFJIZGZpQ0xFYmJoU2RFVHZEZWhCSG9RbEJ5UUVYM1J0dnZsb2pHbXd1VmdGTEhidTQvaFBReFNQWmZIbnNOR25OajYvbng1UFdzYS80Q3ZXUTJ1OWsvVW0xbjFEQlB4RHo4V2ZvMTB2UmZmeTBCazZkUmFZUkxqYUw5YW85TGI0RFdMV1FlNWdMNTFPVER2ZytsUzZWcFRaaU1lZW5BaThzMnUzRCtpTktBSGpoUUNuT0FCbHgwUHNwSEtCMEtOclRPeVNXNW1mR1hHcU9CQ3JwTGJGWVRlMXlLZDZNU25vczUyTldQcUJkZWw2ZThPQU1SZTJUcm1CR0NOdDEzbDdpbS9SYTVMazFyOHgvYWZtVUozZjFtenVXNkNOZmtMUWZmcmxDL2VMc2Z2WDR4NXUyVHh3NmFzU2hNY01HamUzZGUrM29zY2ZXZnpPOGFPUHN6WCtmRUw4bmJ0dzE3b25URktRaDZaNDRHckEwVmJJYmdNVEw3b21UQ0Ric0psdnIrTU5uNi9BYXg0dTFvcjkrdU9pNUdNOWZIZ2MyeGdSNzRzSExhOGpjUWNXbVM5eTIxcWlkOGI1ZHREYXNqanVwbTBlY01Od01EZ0JNaXN0ZGVTV1MzSTJHSms1ZGFCV2FsaGM4YjZqUmpjbVVHb3FUN01xLzYvNUJ3SlM2WVRCT0t1YVBhQ2lMM2MyQ29BbzBKVEZwaUZMU0xpY0dHT2tDOWNEZ2xXSm5DZTljVTZDSXR6UTdlWXdiSmdQRG8xRlZhbkhyaEZuM0RHZ0NBbUgyVzJhby8xQ2YvTWVpZHY4ajdqSDg5OTJGK2IvMURrT1N3QWFKbThQajZBTnJLT0xKSm5nb1ptQVdSWEFtM3h4T2VTSStHNDBOUno5SzNJTEc2My9TdllqLzArOEMvcSsvUzQvaWNscEgzUHB5VlA2dmRBaHZIbDVmQXFualorejc5RC9vRHRDY2dTeHVMQ2ZiZ3hpQzlyQVF1NTA2UkhZYldIdFkvNndRM3QyR3JWZ0Y2ak1KWXVPZFRKS0haa1RZVU93OFplelVTNWRTVm9ZS0EwKy9UQjV0MWJ6Z1NZV05KdTJTU2ljWEFDYy9CNGJIYnEwNUhEYXlrSEwxaEVsT0ZabEJldGFUbm1TRytrdTFwbDZOcU5NSi84OGpoeS93ZTQ3KzhNOGovREhpSTcrWU8xZGRIL3VUdXZiRkY4bTl4UFB1bjRXY1A4Y2lIMjkvKzgvY3YvTSt2YTNxQVQzWEJFOEo5R1FpekFtTlhlOHU4VW1TK3BnNkVQQ0pHdUJycXNzUTRvRXVlNlUrbkhlSXVTUVhiNHVkb1M0SmpMc1VaRktsUHZ0dDJobWZWa3NWY2VwdHVIbWR0a1RqQktIcGNaN3owdHNEbkplZTIxVkkycDBjaFV1amM1OGVzdWZXYUxUMmQ1ODJDSE41dDlwNjN2SWIyL0F6UUs5V1RQa21jUmV1MFo2c3g2bTQ0QjBMRk4yWlFwZTZZMW9MVjlSWFJzM1p2dFFkQzBsYjYvbFFsQStCTjN2eFZ2RXQvSXJmU3d3OE4rNmlNYUQralR4WERKYXlCTmZ0R3RlMXdaM044RDB4T0dCdXU4VUlTd0NZUE5IUW9wRU1iUmxDU0kyU2R6QytFbzJyd1FPNjR2VFdSdC9OMHNSMzQwQ2ZDbDRMdFdVVzVydFptTy9HbDRVdHRFK0toV3YwM2RBMWJYcUpPSFk5VE1SSzNISGQycDJ2d3RCUHZ2cjVUN0h0OWVUbVJTdXJsNnE3eFMxL2pZZDVvaVZhZklmNmIvcHRRSjhaMExlZnUwdmJENTZRWW9sSGVMd2hiR2VWb0RFbDZkYWtlR3NkaldVb09YNmdNUlZwZEZzYXE4c3U4eTRKWFVNa3NrRDk3Q2QxSzlDNHFucXh1bE4wL0FTbW1WSjVFa21NZFdOUlJXYVQvQnFkWGVOZWdrWmlFL284emRQSFhJYXJFdFVjUVUybzBmd0MzWERhWTJhSTFyMFo0NzRlbmwwQkh6RVpzeng0NXFqNXVzWWprVlFXdzBhZ2tBcEtlck5vTU5zOExLSEdpQ1czSEdGRlA2bVZzbzJlbUh0WW1oRUxTZVpYZ0Y5Ym1OL29CRFRDaWE2dmp0ZytmVFBoc21MVCtCbUJCazZlOVA2OVM4WnpEVFV2RTgvT1I4YnVVTSt0MnEyZStYemRrTUhmYkQ0cW54clFkK1BERXljQmxIaGhsZnJkQnhPbUlrOGJUaHRVbUl1UHkwTXZoMHRrQTZScDVaYzBkcW9FcUpRNmpUYnRtazZXTHVaamlNdEhseDBSRjAwQVlPVjlWZy9MSDh0RU9PU2s5NnNMZUVteEZjdXVOZTZEczZxbEVQRVVIQlVCTXZTNFFtVXVoRWRncGJkR3YwdlpRbHBHUGlUWGIveXQrdDYrTjlXak5mNno1TXdQNzd4NzdwRzk5ZTgvaEQyNkZaTDIraDcxZHdjUHFKdjJyaU5abTJPdjhBYytWVDhoaFo4OWMrWlhjMnBoamoyU2FpYVQ3aDQyeE9HTVZlSU1XRHBwWVNGQThRZ2lhV3lQQ280SGRoMDNhY0UrYk9NbTIrZ0Z5NFRlTENKWldRVGZnMTJITVp5RFZ6R3dibzhCNGdaVkNUc3pWOStEekgzcExaSlZ4MCtyVjNlcjFmbzFjOGxqNnJQUHZNeW5sNXpZK0tjZjY0ZVQ3MVduc092Uk9lUnZNN2ovVis3UW5BcSs5WEhBRjFnSjlRSVh6cUNKVnVEbHRBZ3FiZ01lNVY1U1RnbExVV016cDloTFdBNWZFRk1WTVVvdXQwK1RDOU1JN0xiU2ZlQmJtMHIzNGVVTE51ZXVnZXdXSlpOVE51NlV6VTdac2hNMm02VzBsTkJYZXBVUlZtUXFOanZyQ3VDbU54aTF5RVhuUE1VZTczR25xeWp3Nit6RTBGbGd4K1d3NjNLNDVKUFZxWHBmd1kwRFovWGxleFhId3N0K2FmYmQrdUNpUGlPMkw3eHJpUnA5V2YxSi9iUXVNbnZlcHMxejVtN2loL1I1NnZuSEp2VzdTWnE2ZDBaTzllVENtenZsOTEzNC9wam5vOHRKejZNTGR1MVl0R0QzTHFxUE1UOTRNRGpXYUMreUV2RTBtNEdsNTZBVVJId3MydWV6SitBdnRzYjNsU1dGK09RMGpFVG90Q3dUbmFRRnFyV1lIOTZYYmNCS2p3UTh4M0FhN1hEWkdFM1RaaG1vNWt2V3ZMZnB4SkczMVBkSTZzRDdIcmdmUE1TZS9YdjFWbFd4OHRrbk4vVHFjdkJYTCsyNS9ZWk8zZGJmZG4ySG0rSjN3UW1yWUE1SmNUUjZ5WS81NThUUnFuazE5cE5ZZVRoYVRmZER0aG9WejhLemJLRDN0ZnRBOFlSUTRmUmcwUzMwTGdBTFFsRmpHVXQ1bE16eGxtUGdDMURYRkp2UHVOd0pSMWtQc01xa2Q0Qk5ON3FwVlFDbHhxS01MbXdIeCtKb2w0WFJzaWRNRWJxdENoeU1tVk1Pa3NmSVByWDY4SG55N2V4b3RWcEVSRFZLanZHTEY2dUgvNWZkL2VrQzIvOGQ4UGJTdUJ2NWo4ZmQ4TGlqaUxqSWVuVVUvTFN6anJ3SElIa1VXYWZXcXZ2WDFhMVQ5L1BqeVFleDczZ1hmcW5YeFJhUkErK3EzeFBudTZxR1hVTU5wNFh0d0w5Yzdna3VIT0RZdFVSaFA1TGtNbUxjTGVESHVCc3F2anpxVzdHaUFDYndTS1VqcUtSaEJDNHRFWUhEZW9FMFRGaklRTDBYWUFkL3FNZXhMTVdDSDhQU0s1NDBiRG9VUDJiVk5ubFNGQTdzYjlJK3lRbE5mT0hkWDB3YVAzTE9uRitNZVBDT0xkUEdSb2dZUHJYaC9YTzcxRzhXclozUnIydW5IdUU3TzFmYy9NaUwxV3VuYit4eHk2NkYyeFAzSkU0R25wc1RjVGRES0g3OUdLM2pRREFxVVRCcVpJWHk5TXhKWUhVT2lzRVl2eWF4YVp5SmM5TW9WL1U1a3ZMTm1lOWpzRGRqSmVRWmN1dkZ2ZnloV0ZDck81aXMreDdHOVdKdHp5VWpZK3pOcmt1Y0hnQUJOUmJNOW90WVdiQ3RrWm9hcHdId2NNVEJQbmNFdFhBY3pWMndXcGdUNnFCaTdMd2FvVUtGcjB4TEdVblEzUEdGVnRGV3l6MXZ6Smo1UmxQeWRSOWpRTzdwbGFzMC9tMmk5M0sxdVdRV1NmRTQ2WnJ4dU9wL2txTWtUeDFNOXFySDFiY1VHSytlMTFONTNMNU5qY0k0Zk1NUFloV01RN3RsK0xVKzFJS3BObXhHVVhTZ2xra055cVlqOUg0T0IzTnkwYi9Gd0pERFJQUDRFckU0d1VYNzhnYzh2QjJnRHUvS2FaRWZMQTlrMm9TMmRlcnYzRG50Tzk1OVY0ZU8vSDZqVkRsNUIybjUrNHQ3aFdIcjFOaGJzKzVzN1lqTGpLNDFuWE55clBieU9Wc2FRNkpJamdGRG9qenRhaXcxRTZzMTBjQ29pU0F2K3BKK0YrclZqU3B3VnJXUWZ5TGIxWFJ5TWhaS3lPeElPbjZYeXlRblloWllQTWhVMi9SRzFlUlluS081V0Z6MWorU0xIMzlVYzJISUhtVEx4YjBrb3Zaa3Niai8rZmQ0TXA2Z2ZEU051eUdCZW5OajNNM1JHSGR6WEJwM3F4YmVyMU5Mc0JaS0dJYkc3bi96M2FDTmQ0cG40bjVodlRmajJiRFd4bUpZWjd3WTFwM0dLcXF0a21MQ25IaWRkdGR5ZVpQYTJFeHl4VHZGWjRlYjNpbnVGeE9sc2ZzV2k5cXQ0aThBNTlqOVE4SXh1bGFKR0IyOVdNUGNKRWJuK0hreHVpSWhySzZ0RjRZZFBxeGRVdjN2dnNOUHdIdFk5VnZCcDBrQnY2MlVtNmRsb0RoQ1NvWVJ5ekhwcFdWaFFhdGF3R0s2Vm1XZzRHa0RBVmlEVkFmTlBjR1RWMTBXZUFvb1JZWjhKa1ZZeUdCenNIWUI3bFRVRnJBNFNyRUxvOXEwTFhxR0QyK1l3b3JOZ0JTMjJqQmlKd3ZnU0JoWjVNN0Y3bEVIeVhJNXFWalJTQkh2cGxYYUVzMUdUSWlaWWRnUGV4YU9xaHUxYU04L3pyKy9mR2pkME9mZi8wZjkwek1IOSswNytLbGY4UnY3RHBreGE4NVQvUWZ4bVlTUVZtUEl1K3BOWTlRL3grclZUNGFvbzhueUlhU1ljSzl2NmM0WDlIeEh2YjM3bSt0ZWZidm52L1BleG1yQXBSZm9PSW5ZbnZteTJCNXBHdHVUZm5ac0QxVHl4eGVxQXdkaDhhdFJPeURLWk9OT2hma1YwSHRCYjJPbnltd1VFOGIyYU05ZHA2bjJrcHRCQVQ5Z1pZeEZ1eG5VMmlTMlowdUs3YkhRSGpYS1UrdUc5cDcvVkYzZERYS2ZkZnY1NWVRMWRjVWRqM1lubjRPYVhoWm9FMDdjVWE1L0pka3V4SGxBdDllVlludU9hOFQyd0M0c3VVQVcxOFhuTGd5akpiV001NFpLR0M4cHRtZHVKclpITG8zdFhXbndhOGIyNHFTc3pEcllTRTE4TlhqWWZSejFUVEQzb1k5bXB4eEd6VlBqVE9DbSsybTRWVEN3dUprdGZyOXcyRVlUQUd3WTI5T1NJRXp4dUJuTmVUQnBzVDNOOGNUZ1hoeVE1dkdCbis1OWNkS05YK3hVdVF0L0cvTGd5UHRPQzhNL1ZtY1g5NTNkLzllN2hPR3hCL3IwNnQ0cjdrdnFkdEgxd1R6L3U3UzhHRzlJc1dwRXlyNVFSUEJZRWpTbUpvNzBlQnFrZHpMTEtodTF4SCtHYjdTakhXTThrRlBHN2dvcmlsTkk2Q0wrOWFsM3gzKys0OExoSVNOR1ZSMFMyc055cXJOdmZlbXhYKy9hMS9lTzdyMVVuaFllTTF4YXFkRVlqK3ZGeVFQYXVBUnQzdVpwU3pwcnVwU2dnamhCMVQvV0FUR2Y3VkQvZVFhcCtib3BLVXkyS3NCK0ZZbTlBSEVNMWV5WENHRFBqU3NKYWp4aU1xYTVNYTZuWStERGVDVGlaM0U5Q2pyK3Y5cXVCamlxNmdxLys5N2IzZXhtay8zTDdtYUpTVmpDN3JLYmtKRGRoQkFFQXBwR1pSVHhCd1NsTmFXT0lJeFNCdmtKVktkVUdRcU1NdER3bDBaQkM0alJTZDl1dG95T0ZQbXhnd3hGeGtKZ0dHc1o3VlNhaWc3OUpVSjQyM1BPZlc5L0lMVFlEc1BzNXQzN2x2ZmVQZmUrYzgvOTdqbm4wM0U5RjNkN2tvZm96b1VVRUFZWFFCZ01wemxYTnJZM0dyRTl6c3FIdkZReXFFd1o2WGJhNzFnN3JhMjdXSjNCZG51NkZzMWEyN1NxVzkzT3hKYzNxR3JubGxQS3h1YTd0eTFKTE53MHNhbGpiNGVxcWgrcDZwWTVaRGQxcHM0YlYwQWJNQnBReC9Oc2VrQmdodTY2ekFJajAyVkQySXNvWC9uR1pwRkRaMU54Y3F2TjdVakg0K1pyOGF3bGxFM05SSGllQ3pQM3VFdXk4RHlCQzE0MElwOGdvbmxaRnNVLzMvT3pvU2UzOTcrNDZ2S09VK3JuWmUreFBUdFdyK3Q0ZmZXNnJXai9mY2lrcmFuT2pwVFF3ZVJqNm1TeHBQM29rYzN0SDM3QTdVRk1GRmxMR0VBdWhvZU5LY3JMWUhqR0RJWm4rOTh4dk5HY3NTV0Q0VFd5eWtWclBqc3FsdmQvbWhMa3hhMnc0TDg4ZXlIYlhMRnJ4WTREb0JDZlZuOG1Icjl2SnBzOFk1QThDb3R2YVI0RkNpaStCVmtVM2gvNGpaNUZZY3JOWlZIQWQ4aVkrbHFlWnpnRDl0YnpRaUtvTWFnU0l3VVk3UWgyV0sxcCtpY0QwajhwVWcxRlZBWXA3WEVBdWtuT0EyVWVDS0oyREpoQW1RY0RlQmhFUlJuZzJES2FrR2ltbEFZUVVIWjV5VjNhSCtUSkthME9UWFdpV3ovYWF3UmhjaDZyYXNidExKM0lDbTJUOWt0c29icSs2YlZuOTU0NHU3ZHUxdEJRWmFoMjdvc3JGanl6OXBMY2x1enFTcXFmenB6NytmNEwrODhWbWdzTzJ6ZXNtUFg4Mm8wL3VucFdiaE80N3BJNmpFN3lsYSs3RHVtNmthOTgzQ0FRcFhJYThjSUlORUs5aGxIQUdkaVY2YVFQM0s2ZW1xT1hYR1p0Sk1HU0sxbGdIMElqU2ROTDdIVFNsdEZMTm9aNnlWSmcxL1NTYm5UYkhYRUI3VG9MaG80d0UwK1BnSzUxVGp1Rm9HYW9Rcld4UStaMzY4dE0zSzUycjJwYU8ydFJWekhibzA3M0tXM1QxdHpSUHYzVWxrNVZaVDltVVZnaTdlMW9tcmhwWVdMSnRydWJOODZlczRYYTBKeTZJTzJRN3hWR0k3TnVIYzNicHI1RU1la2lWTzBONUhycmQ4RVk0YnpmdFRBamorRlV1bCs5ZmlqTzBWeWJIWG0vZzladmxNb0RVT2pKdDFsY2xUMVcraTdFYnlWbzd3a0ZLNkU0Z3I3RDlCM0I3d1RVWi9Ia2ptaFV3bzFLcEJFZDhiQmMySWg4eXhQenJZVzJFWldXL0dBb0hNa2l5V1UzT2tGQXN0L05kWWpSMFNNVmx4R0ZZNjB6WGtLSXNsVEhKNEl5Unc5ejMxYUw1NHFkbEtoTVI1aXFwVkN3aGxYTDlUbGtqbVd5RjkzNVpjNDUxUHhNUEg3L1RHK2djV3pBSkR2SFRwMDlMdkxKN2lkKzk4anNQV3Z1ZXFBd1VEWnBlRml5U1dNZStQNjR5R2Z4Slg5OWFjK3FpWTNld0JDZk0xOWtSa2RwUTlNUHhtOU9UaHFyUERrKzVpd3ZjZmtLQ3BqTUhFTWJtbG9iZC83eUlSakhPNkNUdWd6SHlGOC9rcHY1STgyeFNRU05aRDhoSzF0T2RQVU9aa2tKL2ZLNUN4ZXUrTFg4SjFMcVUzaEJGdDdDZkNJVkF6WDlJNi9QSjVLNnFDYW9MZWcvWFNYd0c1cHI0bUplSHhuL0JaeTVBRnBqNWEwcDFBbmtUTkFobEJqVVB5eUVMYk1IaGk3dVZ6K29uNlF3eTNQR0YrQWU3Nm9ITE1hS0M1eWpRRXo5dzJTRU9XbW9FQlllRnhMbDJxNnBaRVptWHc0U2VXR2V0WWJMTFRnMTRUQ1BFRjdrZGRBMkdkcFRmdVRraWVLZ1IxWHZzUEdVSmw2elJvY2VsalR5bHl3VVNiZHQvRHFhbERaeUNGYXFyZmVYSUt4RXR0ZFZsZENsY2RNZUhOTXNPLzd5dlNlZmV2d0w4VmllYTl5eUF5eDRSRE9CTWxCVHIyWTNpa0tISUppc2hBdVhvTSsvWGMvb3FWdU42SUhsdEROT1hZeUJZcWFvUnJXRjIwNW9SWENmVmJRaWlnZzRSclBDcXlGa3hNYnNSSERHNnMzMitjOXFtZ05hUlkzcVFJem84blA3Rm4xeUFGb3pUT3k5Y0dqTzQzOEdpNkdOclZiYnZ0TzVhTmU3dUlGMmRFdkx2VGovVUc2Vk16RDN6aGZJZHc3V3hCaTZsai9ZdEFNVGJ6Rk5PMTU5MnZFV281cjI0clJUN01YRFlweDJ2TnpVdEdrUjIzYXZSczZlWDVTMjAvWEpKcE5QSldkNmVlSEVyejY2dFB6M1A5V25sSE9ZTW1XTk9CSWptNitld2FsRXM0TzdZUzY1MXUrZjVmcjlPMjdLNy84YWRQTzdOSy9rSUp6YURLUEZVUnN1a3QvL2s5ZEZBdnR1NFBVUG96ZnB5WGo5T3gyWWNLZ2dEOUVBdHlNaDJuMTQ1TG5wWU9BTUdEdzRCbkpzYTlWQTFhYWlycFUvZWZzYU9DUUREV3RyOGxZZEowM0hBRmh5WXdBR1haUGZWQXdBU1BYc3Y5U3RGL2hTOE1vUmRZQVc1WnJmdVBFNGFMcUdiRzg1U21Kc3pKQmE1bUNDdUNzbHU3SXh3WmpMNzNoSFBIR3lBdDNJV2V4cTM1WEorbDZhWVh6MnRUV1E4ZHRldTFPMG55akhyVFd3WDBNRG5UbThzRUlPNjZ2d2Y1MVRwU05pWDRhN05JdHJOb3RnVm5xWXFWOSt5WDl2M1BmZmYyKzhSL3Y5U3FtVm5USHNGS3hDdGNaMGF0Q2laalYvVkUrZlRtdFdTSUZlQm9lR2VNSVVDMWF3dThqampqbFdkbTR2VWNTNVV1dkZOMTZ6emk5Ykt4Zks2cC9vK2FkSzA5bHU4dGNCZVpzb2MzcE5Vc2pjd25nNmJ2YmdRRW1LZEJkRnJPRTNFdmd1SXR3STlYRTlldDRXR1UxVDRTN00vc3AyNldEWk90a21NOS9GM2E5YjhUNHQ2aG5XeVh4Z09ZNFVrTEZRdjRXRjhvc1lQZHpkMnNqNW4rRHFabTJCNngwZDBpN2Q4bXZiVTh6eHl2YUR3Wjh6MzlkMFdYaWZRVDVTZ3VUanhYa0pKYVE0WXBxUVlER0U0eDVEcVdWWTNFVjFiNTZNMEhCbGpYc0hYcWh4Y3pINnRFQnFFQ1hhTkNoUW1KMGJyeFZwakJkS1dWcTZ4MTdaUGtTWm55dGpiUDc4c3BlZElHMFJaUzJ0SkZtVHhpWnB3eHhxbFB1MEIvWEZOTGtvQlR6MTl5RFN4M2NXQVJRUDFIdnN1REhscG8wcDB0WXVYSGtYK1BDNXNYL2krY1dOMS9aUVlMRHVZZ2Zwb0RPMzMrYnJ4OUFnbERYMG9iUVUrbEI3ZmtTV0ZXY3Nib0xuTDdxVnorKzk0Zk8zS0NLTkNYeCtQamdxVnRNajQvaVltM1dzdmF2bnhWN3l6YXNXTXRTbStUZ3JhaVJrTUZuMitQSXRoV242WlQydmpsZUtTUTN1a0t2Q3RlaFM4VTVmLzJWWHUwdk8yK2hpTHZVcjEwYlgxZCtLZFZ3ZnJBWkI5UkUvNGUyYU53dVB4L1RVS09McGhHeHlSNk5SYlRjeFlTbHdRcW5ISjBwd3c4TDB2cUoyUTVjcGZWZnQxcXY3N2ZiK2Z0L080a3VYN1BaTCtCeE0yT0JrVTlnVVYvcEoxSVNhY0c1d3FsOXJjYnU5VEpGODB0OTRMaUY0N3lSWnlKTXJ0VDg2dGF2UlE1WDhUNXJLTmNNQzJ2dldrbVZ2dmJWc2FaZDRjdW1lTjVjdmUrTk53dHZXQ1lMaEdITm1iRjVDcytTOFdJd29YUTFtQkNxeGlzbnB6VExKblFFbjNSbHcwcDJaZ1B6cGYrdFlQck16QzNQQWgxckVQM0JKa3pBN2RkRzgwTkJGOWdQNkR0VUs0NFM3aEU4MGpCZ0RXSlN4c1hpa3NFK1pHRTBVaUJxWGJkeFgySmNjVlRZY21ZanFZL0ZSY0xvbG1uU1pzWUlubWJpYkJPTGdvOUtSWmxERmtwSEFJYVRwZG5PYTdwRlE4dk1TMkxSUktFM2dwUW4yK0oxUUdzTVZ5ajA0MnRGaU1Oc2tzQlBpSTBmQWNjSHdza2JhVllERldQek9DVkF6OXZaNld0dVBnb0hmVStLbmxOQ2NsdFVvWEVmTHltSk16T0JOTE92VTZFeTFRYThlbWwwNysvMU43ZnZ3czFFdVBuYmwvSzZaelMwUFA5cmNJczZFdXZmd3N4ZEtEOEdIcGZadmhsK3FwM2tOL0U2K2ZkdnAzbzV0dmFjR2lLTlRiazhzV3piemtlVUREMnJWZitmbGo3T0xNOXBvSEQ0cVBDek9JeDVZdjRBcEpGREtCaHB2aWhTbE1VQXdnY3pwdUhONTVMUG80K2xhVDhPMVZ1UmVDMTloZnJuTXRSZzV0MXpMTlp2SVpwVmxxWVdwQnJuUWlHeTdnZ21FdWw3YTk5bEE4MUhqMlc5Qy9IMmVsenB2bUd0SXdQaGFLU1NxS1MyNlZRdE1jVnY3a2dLcnRzSllLby9GQlFPdWhKSjVKcXFBaFVLZWdTY1VpdEtDcjlUZWx5aVZLUkdDSDZ4c1h6UWhsK3BzOXJDZWlNY1E0a0gvU0hNdGFiOEFISVlqTUZyY1NOOElpM1p1ZVFmcjZ4b3E2am4yS0dZQkZ6QXBlVFg4WWdManJ2NUNhTjZyb3J6allCT3JPL25ZMW1XenF2YTNySjh6ZjFjbGUwZjF5ekk3cDdaRXVwZmNzV0JhTE5uMDRyNGZubE9QakdQSHUwc2Fta3E3VHpORDZONVpUUysxUHJwcWNmZm80RzJqdTVldkhYWC9uUzg4MW5ZZnkvdURsbzlJcWpEVVV4eEFrYkJFNEFhZzJScExUd0JTbXV2Y2FJWStLWXhHQ2RJMm50WXlld3krOTZnWVNCOGtpN2cyTHVJUlVKcHFwTEFuWEVkWnJCcHJ1OTlkZ2M0VmpsZ0o3ZTFMRlpLam5xbUgydGlobGUvdmYrN1p3OWJEaHNvRkM2NzJpM253V2FyMnNzcXJhOWdCOVdOV0E1M1BpSEJ6dkR3ZStqNlVrN0dVODBoTEJDeHBmelRiRE1scjhiOWNPWXo2YnpMOC83Y05meVFtajFMUS9LVHZvZXNUSldpeU1odm9RU2VzdzRVb2FQKzRGd2s5N0lvSi9YYXNacjVEWEVRTE1oY3R5eE11aWpOd09YaVFaSkdMSXJKUkpqejhSdkZFNDZVVVIwcTBZaFNFWXlKVWwrS3lMWlI2U2wrZjFUV2dXNk1iM3ZaU2x1R0lSL0JpOHBvWjAxK2QyenAxMG5wV3BuN1JMNTRnTUVONjRzU1U1SXpwdDMwODVCZmpqcU8xejFhazBRM3lLWlYzYXUxY3JMWFNRMFFsc0VxMjVXRVdBQVFiVEdZZXFIWFRyU0lPRTIyZDZjbHFqNDIzeCtSSW1ESGp4WTNiTkVoN3psN2Zsb0ZPdzVuTFlVSEdkcGk2cVIyVlFvMFFFejdrYlltSFI4VmlpVnJvc3g1bTh3YUdlNm5iRW9JbkZJMlNXVE1zaG0xVFNxT0tCWHBQR1JxTG04MTk4ZktSY0JhTW1TcTAzdXUrUmJNajBKblFpMkg0NWZCb0loekJjK0VRbkN1UEppSmhMRVU4VUFyYmNWdGFxUUxkQUwrc2pzYnJRVXdSWFV6eFVXRTRLaDJtdlFtRGljZi9yUVpDRzVRNzUrVU1ERlc5Zkowd2J6eE82SDB3N1U3TDk0QXUzYW9ZamhXVVp5d1c0eHVHM3NCL0VpMElnaW1qYm9sRU1kZEVEUXk1Mmh4WlZxVmxDVThEaHlPcmJ6em8vRGM5RksrVjZKbi9LazF0cEFyL0JzTW1MdDhBZU5wallHUmdZR0JrY05vMTdlYkdlSDZicnd6eUhBd2djTzdHN3NjdytuL2h2M1djaGV3SlFDNEhBeE5JRkFDd09ROTBBSGphWTJCa1lHQzkvbThIUXlmbnBmK0YvK2R4RmpJQVJaQUJvdzhBdjlBSHpRQUFBSGphYlZSTFNKUlJHRDF6WC8rdmhBc1JLb2dKZWdxemlCQUpFNUhNVEtjTUh5QWlzeEFSQ1dtZ05MTnBLbkFoSWlJeW04S1lvSmNVRVNFUk1yU1FrRjdFdEFtalFxSkZpQVFHUmJtSXJPbmNPMk1OMGVKdzd2LzkzMzJkODMxWExLUFdCMkFoZW9oZTNKQ0xpT3RKTk9rdDZEYlAwYVVUYUJJN0VKZkRHQ0s2NUhFTTZpQVNqTlhKL2Vnbmo2bFE1b1YramdFWlFybGFRcmY2Z25iZGg3RDZqazVkalFIMUhtTzZrR3RWSXlZcWNZRm80aG9UeERReHExcXgyM3VOcUdsR2xYNkNsRjVDek93alI0aHFwTXdCZnBjZ0pVYnhWSjFHU0tlUlVsOFovMEkwRTJuRWRIdU9uM0ZPa1B2dlFvc3B3alVEVlBtZkVOYnpPS3dmWUx1K2pHRjVGZmQ1NW8va21BTDZWVHF6U3Y2bDdxR0ZleVpWZ3VlTzhCN3o2SlNDYysxNEJVblJnQ3VpSWZOWjNYVGoyOTRrY3huWCsxeCswdWJKUnNhQVdua1FkZnczb2VaUWJqNmdSbDFIbFhwRWZjNmdseHIzaWlsOEp2ZklGV3FTMDE1Tm9WZnZ3SkNlSTUvRnpzQVRSSFVSQnJuZWpMbU9xQXdpcXQ2aWcvZTdaYlczTWY2N0poOWhuTEZ4anBGRm9GNGJYRkluMGVMOFFXQ2RqWE4rQitkSC8rWVJyV2l6dXY4UGZnUWJyUmZPaHp5STBjdzM2d1Y1a1ZnMTV4Rlo4K0ZmOEZ3ajVLUE9penc0TDdyb0kvV3p1djhQM21VeXZiQSs1SU1ldkxMNmt4OFRDNnpWemo4Ky9Jc2dicE5ybkJmNW9CZk9hN0wvRERHL21iazhFelc1UXIzV2s4L1p1NXFmT0tJZTh0NGYzRjNhYy9kZXRYVllVSVRDZ25YWkhGdVRlZ0ZsUnRBclc4ZDMrYzFhdG5QTkJwVFl0ZnhwYk5ZaDFKZ1FZNFNkWTRJb2RIVmNrdE5QTU42ZTdRRmJ3M1pOcjQxblkvMmFVc1pua1BDNXJ2K1IrUkhVZTMyTTlSRHZVZU9mY251R1hSMVhJcTVTU01vNTZoTEVacXViQnhTcmJTalR4WXdSYXBiNEFjR2VTV3FWMVkvZlNhZkxDTWNDTzYwKzNpYldQK3RYbHpMK0VIR3ZFa252R1BOS3NkWFkzRk11ZjQ5WklLZFI0WHhhZ2JGN3E0c2NzeDl5dmZQTzlvKzNIOEpyWUgweXg1M0I5c1VQdDNiS3pwSFRnTmZKZXMyeEdBQUNiNGk5V1dDWkhDTWZaUTc3WUEycUF2M2VMdmNtRFJIMjNhcmpIWWFJSnFLT1BkblA5MnRFZnNJcjA0WXh1MGJCUzNTSmVYUVFVWGtuYzhMdTQvcHZtR2VxNHZnUSs1L3dHeEZHK0RmVXgwQzNBSGphWTJCZzBJSENCSVlPeGd6R2IweVRtS1dZSFpnem1IdVlUN0J3c2Rpd1JMSFVzUFN3UEdIbFlrMWdYY2Y2Z1MyRzdRYmJIL1kyOWo4Y0dodzVIQTBjaXppMmNjcHd2dUdTNDJyaHVzSXR4UjNHM2NQRHdHUEJFOGJUeGJPUDV3bXZFbThNN3c3ZWYzdzVmRWY0VGZoVCtCZnhueERnRVhBUUtCQ1lKM0JLNElZZ2k2Q1dvSk5nZ3VBbElST2hKcUVud2xiQ1hTSnNJajRpWlNLclJPNkovQkNORTEwZytra3NRR3lkMkNQeFRSSnNFbDRTQlJMSEpINUpHa2ttU0o2UmZDRVZKTlVGaFB1a2E2UWZ5T1RJWEpENUpOc2x1MFV1VHU2ZVBKTzhqcnlYQW91Q2pFS0d3alpGSHNVa3hTYkZFNHAvbEdTVXJKUW1LSDFTbGxET1V6NmlJcVZTbzdKTjVZT3FubXFYNmhNMUg3VUZhai9VSGRSYjFDOW9hR2dFYWRSb3JOSjRwdW1udVVkTFNhdEQ2NU4ybGZZdkhSbWRlVHJQZFBWMHEzU3Y2UW5veGVnZDBYZlNQMlRnWWZET3NNM0l4dWlPc1lKeG5mRWRFenVUUFNiUFRBVk03VXlyVEQrWlpabWRNdGN5bjJRaFlkRmxzY2ZTekxMTjhvYVZnZFUwcTJ2V0p0WlRySC9aMU5tY3MvbGthMmRiWm52T3pzbXV3TzZhdlp0OWl2MEMreXNPWGc0ckhKa2M3UnpuT2Q1eTRuR0tjanJnOU16WndibkcrWmlMbVV1Qnl5bVhmNjRlcm0ydSs5eWszRnpjdXR4dXVYTzV1N2h2Y1gvaG9lS1I1YkhJNDVXbmxXZWY1eVV2QzY5VjNremVKVDVNUGlrK1hUNlBmQzE4bTN3LytlbjVUZkk3NXMvajcrUGY0bjh0Z0NFZ0xtQk53SjFBa2NCRmdkZUNoSUlpZ2lZRTNRaldDSzRLM2hlaUVOSVQ4aWcwSWZSR0dGZFlUcmhOZUZyNG92QnJFUzRSQ3lMK1JWcEZMb2k4RThVVlpZRUR1a1dGUkNWRlZVVk5pam9VOVMxYUtib2kra2FNUlV4V3pLYVlCN0Z5UVBndFRpYk9LUzRJQ08vRk84UW54RjlKc0VoNGtkZ0hBTkJaNHhvQUFBQUFBUUFBQVUwQVVnQUhBQUFBQUFBQ0FBRUFBZ0FXQUFBQkFBRlJBQUFBQUhqYXBaRFBTc05BRU1hL2JXdFJVTFFnSG1WVkVBVXRyWUpnYjZKWUt4UktFWHZ5a0g5dEEwMGphU0wwbEpmem9GZGZ3b01IWDhGdkoydnB3WnRaTXZPYitXWjJkaGRBRFI5UU1OK3lMWWt2dUN4VWNBVjdDNjdTNzFOVmxUVkdyeml3ckZqMWFibEU1Y3R5ZVlrclhMKzhnbDE4VzY2aXBEWXNyNktsTmkxdllWdDFMTmV3cnA0c3YyRkhoWmJmMFZCNTNvN1RzUlBwWGhMcmJ1Q0hXYVQ3d1NpYk9Ja2VCTzR3bnFZNXJoSGpHWE1rQ0RIQ0dDazBqdURobVA0TURWa2FEMVFDK2p0V0J4aGlRcHRJZnM1dW85eFN5VENGei93Y0o4eDBHSG1vQy90dzRmelJmeWlkaVVRQlRuRlBmVXFhc1UvamluVVQrdjdpYkRPSmpHNDZYbWg5VnRhUnkvOG8yUm1yelM1YXp0NmtVdHdpLzhjdDJzeW43SFlRTWRlakdxTXIwMFBXUnhpUVhlNW81cG9YTEthYWVSbWpHNnFlWkMvRk50RGlmMEhiNUJzWDc5ekUrUTlGWFZqQ0FIamFiWk5WYkJ4WEdFYlBseGhpaDVtWmVRZDJJR3phb01QTVRreWJPTFpqWjVNNFVHWlNxMHA5YTFWNmFhc3lxaWlWR1ZSUVc2bDlMcXNQYlYvYlRYYjg3MHRIR24zZnpPcWU4OStySGZwdytmcTNsRG44ejZYNi9OMUhmZWxMQ2FXVVVVNC9LcWlrUHdNWXlDQUdNNFNoREdNNEl4akpLRVl6aHJHTVl6d1RtTWdrSmpPRnFVeGpPak9ZeVN4bTV6MXptY2Q4RnJDUVJTd21oWU9MaDArYWdKQ0ltQ1VzWlJuTFdjRktWbEZGTlRYVVVrZUcxYXhoTGV0WXp3YnEyY2dtTnJPRnJXeGpPenZZeVM1MnM0ZTk3R00vQnpqSUlRN1RvQkllNGpxdTV6WHU0U2R1NEE1dTVWNGU0V0dWY2d2ZmN5MTNxMHpsM0s1KzNNUmIvS2dLN3VOUi91WXYvdUZCSHVjRDN1TUpqbkNVTzJua0k1cDRudy81akkvNWhFLzVtV2ErNUhPKzRFbGErSk83K0lhditKcFdmdVYzYnVZWVdZNXpnamJhdVo4T1R0SkpGOTNrT01WcHp2QUxaemxIRCtlNXlBVmU0Z0d1NUFxdTRtcCs0dzllNWltZTVoVys1UWUrVTZYNmE0QUdhcEFHYTRpR2FwaUdhNFJHYXBSR2E0ekdhcHpHYTRJbWFwSW1hNHFtYXBxbWE0Wm1hcFptYTQ3bWFwN21hNEVXYXBFV0t5Vkhyano1U2l0UXFFaXhsbWlwbG1tNVZtaWxWcWxLMWFwUnJlcVUwV3F0MFZxdDAzcHRVTDAyYXBNMmE0dTJhcHUyYTRkMmFwZDJhNC8yYXAvMjY0QU82cEFPcTBGSGRGU05hbEt6V3RTcXJJN3B1TnAwUXUzcVVLZE9xa3ZkT3FVY3ovQXNML0FpYi9NY3ovTU8xL0FtTi9LWVR2TXVyL01HcitxTXpuS2JlblJPNTNWQkY4dGEybm82VzUzeVhIczJsVXJWRnJJcWxXVHlYTzBtNlNXWlRqS3VhR2pPWnAxVXl2VjZXOXF4NWxvci91cGJTMXNMcklYV0ltdm1DRkxXekJIME9oemZlSTVSSEtNNHhVbU40aHJGdFVsZG04ODFubXZ6dVVaMmpld2EyVE95WjJUUHlKNmRnV2NPenh5ZU9UeHplT2J3ek9HYnd6ZUhidzdmSEw0NWl1ZmltOE0zaDI4T3Yzak90aUt3RllHdENHeEZZQ3RDbXlxMFdVS2JKYlJaUWlPSFJnNk5IQm81TkhKazVNajJHNWtqTWtka2pzZ2NrVGtpYzBUbWlNd1JteU0yUjJ5TzJCeXhPV0p6eE9hSWkvc29Vbm9kK1c3TnNXYi8zWlJuemJlV3RoWllDNjFGMXN6aG1LTTRjN3E0dCtqU04rdm1QL0lrblNUZEpMMGsvU1RUU1FaSmhrbjJjdUlrcXdycEpGekhxV3pPdHVTNm1ob2J1bHNMcjl4TUlkT1prcnBjVjhmbGgzU201bEptcWd0ejVOTk4wa3ZTL3c4cm5iUDhBSGphUmM2N0VzRmdFQVhnL0hKRklsY1VaRVRIL0lWS2kwTFNwREdxWk1aenFEVktubVdqTWw1RjRWRTRXTkh0dDJmUHpGN0Y4MGppcE9Sa2JZcEtpSE5aWllZc3h1U1ZPVVZiREljeUprUHVDb1hVSkNWVnJrbEwwb3M2YThnUGRFRHJNd3hBTHhnbVlDd1pGbUJPR1UzQW1qQmFRRE5tdElIV2tHRW42VTFwaTFoaE93anRBYU1ET0tNdkJMbjhtdmV1dUVKRHBWS3pQVFkrN3J4N3pRRDBIelZETUZqVWpNQndWYk1MUnYrMEIzYm5QNVlVeVJkSHdGZE5BQUZTc3d0a0FBQT0pIGZvcm1hdCgid29mZiIpO2ZvbnQtd2VpZ2h0OjUwMDtmb250LXN0eWxlOm5vcm1hbH1AZm9udC1mYWNle2ZvbnQtZmFtaWx5OkdvdGhhbVBybztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24vZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBSUk4QUJNQUFBQUJBeVFBQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkdSbFJOQUFBQnFBQUFBQndBQUFBY1hweEVnMGRFUlVZQUFBSEVBQUFBT1FBQUFENEZjZ1BzUjFCUFV3QUFBZ0FBQUJBckFBQWpOSVhTUTFwSFUxVkNBQUFTTEFBQUFOVUFBQUh1Zm51TXRFOVRMeklBQUJNRUFBQUFWZ0FBQUdCU0dGR2RZMjFoY0FBQUUxd0FBQUlrQUFBREh1TzNZYWxqZG5RZ0FBQVZnQUFBQURZQUFBQTJGdFVRMjJad1oyMEFBQlc0QUFBQnNRQUFBbVZUdEMrbloyRnpjQUFBRjJ3QUFBQUlBQUFBQ0FBQUFCQm5iSGxtQUFBWGRBQUFYekFBQU1NTTdTdk5OR2hsWVdRQUFIYWtBQUFBTXdBQUFEWUY0OE1ZYUdobFlRQUFkdGdBQUFBaEFBQUFKQTloQ1l4b2JYUjRBQUIyL0FBQUF5Z0FBQVV5ZUc5NUQyeHZZMkVBQUhva0FBQUNsd0FBQXB3RjhqZ1NiV0Y0Y0FBQWZMd0FBQUFnQUFBQUlBSnNBYkp1WVcxbEFBQjgzQUFBQVVBQUFBSnZkN053a25CdmMzUUFBSDRjQUFBRGF3QUFCMWNwK1RydGNISmxjQUFBZ1lnQUFBQ3JBQUFCR0pmUmFXVjNaV0ptQUFDQ05BQUFBQVlBQUFBR0MyVlNzd0FBQUFFQUFBQUF6RDJpendBQUFBRERoZVhRQUFBQUFNN1l1K040Mm1OZ1pHQmc0QU5pTXdZUVlHSmdZMkJrWUFkaURpQmtZdUJrZEdCZ1pIUmtkR1JnWW5SaTlBQ3lQUmw5Z09Jc1lMVU1BRHBzQW1ZQUFBQjQycjJhYTJ3YzEzWEh6NUNyNVVzVUgxcFNGTWtsRlpZeFFLZHFETlBVZ3hRclEyS2tGY01vTWkzVGxyd09GQVZoMDhRS3ZIRnFWV0JWT0VJSXNPMEhwZ21RRm91aVNJTUZJUlRCSUIrS1lCRXMvSUhURDNLU2JRUlQwQUNHRFhRQndiTGpLU0EwenNhMUZFNS85N0d6dTRMb0FxMVNEQTd2N015OTU1Ny8vNXg3N3JtN0ZFZEVXdVZ4ZVU0YXZuVHBHeS9LamhlLytNMnZTNy9FZUM1aEtPcDk1YjZCVHczUytLV1hYbjVKRXZwdi85ZSsvSTJ2eXg1ZU83cW5Fakc5cEZrNnBjOCtyYlJuZWFQYWYwQmFaWnNrWkl3bnJUSXEwenovTWxlLy9BblhnRnlSdjVkQnljb1BaRnpXdVNibFg3bW01SnI4Umc0NW84Nm9mTlU1NWh5VHJ6MU1UWi9vMUZqL3pqbmcvTEZ6eXZtdTg0dUcyWWJ2TkxZMlhtdjhWZU9keHMxWUl2Wm9MQlZialAwbzlscnNGbGQ1VzI3YnY4VWZpMStKNTVwNm0yYWF2dEIwcC9sSzg0MldreTFmYVZscitiRDFaNjEzMnQ3WS9pL3Q1M2ZNN0hBN1loM3pIUzkxL0xRejBYbXlzOUM1M3ZrV3N0NjFyK09semtMWHExMXZkZzkyRnJwUGRsL2JlV1JuTGpHVVNDWCtNWkZML0hQaXg0bk41aXM5elQwTDhTczlQK3BNeEs5MEpucGU2L2xGNzJ4dnVqZmQ4MXJ2SzcwLzJIVnkxM2QyL1hEWHRiN1p2bE45NS90eWZXN2Z1N3RIZHAvZS9VcC9yUDltL3djRDNRT1BEY3dPL1BuQTl3ZHlBK3NEMXdmS0EvY0dkd3crTmpnNW1CNjhNbmgxOEdlREh5UW5rNmVUWDAxK08vbkQ1TFdCZThsM2tzRlE2OURnMEdEeW5hRjlRNmVHL25xNEdTNW1oeDhaZm5YNEozdjJJSCtaK0hGUDg1NWJuMmpGQS8xaEFIUDd3NndjREZkbE1zekpvWEFaL3o4U2V2SW9zamNzeWVPMFR5REhrT05JQ3BrTmZma2NIcHZuL2pTeVFMK0x0T3VJaCt5UTBYQ2MwV21aWVlaajlENU9qeFR0TE8wODdXbmFCZDQ5U3dTczBQY3E5eDdQaDJVbmZ4TlkxRS83U09oaWg0c05MamE0V0RvdUJ4aDVNR3pGMm5FNXRGbTIyZ090L1FUdlpybi9ISHJNTE13UUZ1Vk1PQzludzR5a1FYZ1JQZXNJc3puN1E5ZVpSQmpuS011Nm1ObVRYa2IxMDJOVXo1aGlOcGZaOGpLRlZZZkFORTJmTS9RK1M3L251VTl6L3dMM0x5TXI5QjE2S0JnZWJQL3l4OXIvYWVuZXpETjdIbFlUMG9NR2hXVlhPQzE5M08vbXVmTDRBRDBIK1R5S0JSWHI5bUpGeGNKOVlKcm0vVXk0aEdWcExNdGdXUnJMaWxpV2tWTWdld3FaNTluVHRLZDU5Z3p0QWxZK3k3am51RCtEbkVXZVI5TElDMWl1K0ZIV3J6RHZWWFFiRkdtc0wySjlrY3pUd2VndXBGc2hDTXNnQ0t3M2lvd3VpZVBNU0lZY3RZdjcvckRNcHlWeVNEYzkrdWl0MkI3VVQ2ZjFVK1VEbjZjZVR3UDl0RWsvTlZyTDlrMFp6V3JNbUg0Yk1LWXlwMklwc0crbmlZME92TlhKbUM3YTdzMlM4YkxtdWNRSUg2dm1zYU1Jeno0Y0I0d3VLY3dPcThlWlFHYkNZVlpidjM1VG1YVmVXdEFib0ROZzltS0UyT0RSTVVXdlliMUtBMkxHSjJaS1JLRXJuNUoyYlk4ckkzQTdxaU10aHk5eitER0hIM1A0TWREeGV3QzlCK2s3eWYwVS9RNWh4MkY4Y0l6bng1RVVja0t2elNJK0xlTFBJbjcwOEdPQUh6UDRjVlg3OEFKOUxxSjNoWGFkMXNOdnhBdllYR2NmZnR5UEhFUW1rU05FNS9Gd0hOLzZqc29XcmVBY3h0SnlIUTVqalZwTmdWNU5hWVVjVEFGWWZMRDRZUEhCNGpPaXpJZ3lJd0pHcUp3UzJCVVQyTlVTNk5WUzBmUzgxWFpSMitwanEvSkRnSzE0V0xZelp3Zk1kU0hkbWtHMUdySmtMTmV5NWpKampobGRabHhseGlWV2hBdHJyanhKWDZYOUhPMUttSFhVcytZNmUrWnI3RWpydkliSHBRVzhLb0owOU1EcUNIYU1zb0wyNG8xcGVzekErakg2R0MyVkhGRFNxQmEweHBMVnFMSk5TUzRqSzR5L3lqaVA5YjlmeHB4SjVEQ3NIK1ZkRzZnQ3kzWVJKTDdsemdORlNXYVkvUXg4cHBHcjNNZXhqZnlIak5KN3I4WldkRlRQVWZ5UnRmRzFpazlXOGNrcVBsbTFUQVUybTNuTTRXbjlKdWQ3TnJhOG10anliR3dWaVMyZitaZDFqcWpHMXFxT0xiVVhySFBQVG9MUHN2Z3NxK09wRWt1alJINDZpdndINTFjVk1Za292NXBvVng0cWF3OFppOG8yYXNvNmExV3RxYzJ4UVUyRXV6cmZIclE1OTNpWWlpemFLcUp5TU9uQms0cDZyeWFpc25xZm5TYkxWU09xYkNNcXB5TnFxQ1pXMU9yT29Ha2NEWUZkQlo1ZUJkUEtrNXB0aGFzc0ovUytCeDdhNTFoelo3RHNMSkpHTHVpZE5tTjMybkpkdkJ5UmhNTllaNVp4Y2JBRTJ2NWFtOVVLNk1DR2NrME9LdFp6aXY0NlR2bXMrT001ZWxXZVZQRTR5a2dUTjVXWUtZS21xT05HcllMRGVnZFVIaW5YN0xFbEcvVmxFSlJndmV5b21aNWdUZVZzVms1WnJsS1NaTVNRbmlsVlU4Y01SM1hNUGpTWjlUYUcvV1BZUDQzOVk4eXE2cHBwbVZQMUEvSjVaamdGOTA4aDg3eC9tdlkwNzUraFhVQjMvVTduMXV4MGFhSTVwZXVoeS9DOXd2MVZ4cHZhYUl4NFNoRlBLY003N2RFd0F5SVBSSjdlQzh3cTdLNVppVk9hZzNLMElnK0EyNlZucTE0RFhiVGRTSktlUXpycXhxT2RZQy9QcTd0QjBjWlBZUE91YjNuSXdFTUdIcGJnSVdOMytTVjRvTVpEUGsrZlU4enpGRExQKzZkcFQvUCtHZG9GdURBOHVQRGd3a1BlOHVEQ3d5bzhMT3NkNDdMZTlWV1ZsN0U3UnlaYVY2eE5lRmlHQnplcUJCUkN6M28yYnowN0RzSVNDRXZXczdadWdkbHEzZUxYSUN6ZGgzQUpoTXNnWExLZVhnWmhDWVFsaXpBUHdqd0lsMENZQitFeUNQTVdvY3BYZVJEbUxVSVhoSG1MTUt1enhXVStHMDluYk9aWUFtRWVoSG5yNlN3STg1R25Qd1hDUUdmV0VZMUlaZGNzaU5RZUZJQW9DNktzcnNRTzFPMzdsZXlhQTQwTG1wek5aVzVOM0twOUl3Y0MxL3JHajJKVStjVlluTVZpdnliYlpyRTRWNU50bGJYVmpLdjhzU29kWk5KT29ydUx0cHNWbFZSNVN0Zkp3MWkvalBYTHRvNWN4dnBsck05YnkzMmJzU3IrR0FmQk1BakdRREFNQWhjRVkvZEYzQ0wrV0FUSk1QNVlCTTBZL2xqRUgrTzJObG0wR1hzVmY1aksyS3k4Y2RBdGcyNFJkTU9nNC9USVp5OGNCbDBhZEdubjhHWVpoR3FYWEFTaDZ5ajIrblZsOXdnV1A0bzhqdUE5bmFtbU5kK3FVdkp0cFJUbzg0K3BsQlMzUGxhWURHVjJzVHd6NW0xMVpDby9zM3NGanRyVGU2TGF4bmphMURmVmM1S3ZUd0htZE9YckdkVHB5c3ppMTlVMXhuTytQamZ0Zk1BK21Lby9aMmltQTYzNVdWMXpxY3B1dVhhL2kyeHNZb2N0RVpscWYxcTB1ZGpNbjFiVnVkN3QyblU5WXlwWDB6T2pkN0l6OEdJc1ZTZWpvcTVWenVsNnBjd2VHckIvQnF5SUFQYkwwb3Vta2w0QmFzL2JxdnBSZGNwWnhHQXZ3M0lnbC9YdVVuTDJzYnZzWitjNlNEdEplMFJwNXQwT2E2TmZZNk9xMzlJMU5oYnZzMUhiSlFPeUhZYmFrUTVXVVJmU2pZeElTZzd6N0VuT0NUUDAzcXIrVk9mQWMvUzdRSityaU5vQjk4azBOcWF3Y1JvYlZlYlBZV2ZKT1U3MTcyQlRsajNYOE8xcHZtc2pxcGU0OURVN00xRWNtb3E5dmxvUGJMVmU4WktKeGNzOE0vdTlpa1dmV1BSMUxCNVZwNDBhaHN5cGF3UkxxZ3g1bHFFODJqeHcrZGFMNEVFRDZ4b2NSbE12YkkyaFJlM0JLZGhhUkl2M3NmV3NZdW1DdHExb3ZUaG1HUnF6REtXVUo2VVRHLzBvRHArc2ZHY1FJUzFoWHpFNmY1OHpXcU1vVXhxMjEwUld5ZHBSc25hVXRBMm1kbGJSazlBalZPVTFEK3RxSDU0M2xicXVTN0thRjRPcVd0dlcxclVMbXJlU3RTdUlhaFpqbDZjcmRvTlkxYlVsdkZFQzZUeXplcnBpVnpObjlPbW5pMWJWZmZVeiszVjVxRFlIbVF4UnFqdjVWR2V1eElGdjQwQ2ZncGc1RThWQ244NStaaDJxMlFJYjQzbjdqVTllMUo0MXIvZEZ6K0tzbm0vTUxEbUxUOFY4dmliejVTSnMvMWRXSDRUdGYyYTFsVmx5SHhNQkpSMEJyTWN0TW5QOVNKVS9VOUhvaFFlY09GK29PM1dXV09HNzdGOWZmK05XSWxmdkIzLzFXeVZWaXkzVzFkSzFkZlQ5VmJBNlRiNU9iTHlCdklzMDJHOUNwdEdyNm9qS3FmOGc3eWJoMTV3Mnh2Vlo0WVE5UzVvVjVOazhuWXRXK01vRDk2a0tFL3ZSYUhhVWltWjFuc3pvcytRSnJWVkZZVTdYU0tvKzBuc1U3OVpydE1Zc1grV0lyMFo1ejU2czFEbGptRGlKRXljVHhFbWNDbU9OQ21NTkg1K1htMkI0RXp0THlDMmtUS1h4SWZJUmNoZTVoL3dPMldSM2Q1QUdwQkdKSVhHa0JXbER0aU5VTUU0M2trQjZrS2t3VHF5Y3g3cWJZVUhlQ2plWVljTnA1ejRPeDVldzBKUDMrZlFmK2p1M1MxaDZTVlQxdlNadmcrQVdYTnhHZm9YOWQ0bTZHTktFTkNNdHV0WXptTllzcGdLWUNyb212c2xuaGVsdGpTdUxKamZTOUJ2WUt6UFBiNmx3UGtUK0MvbUl6M2VSZTl6L2puWXpYSFVFY2JDcGdiWVJpWEcvalRhT05ISGZUTnRLMjBhN0hXbm5mZ2R0QjdLVCt3UnREMkk0Y01tNXI3TUgvSnk3TjJodllPbmJXR0lzYzJFakJSc0ZMUFJndzBXN0MwYlhHZEUrbklPWk9jMmlENHNCdlRmZ0xlQmNjNTIvTjNocTN2aWdOVy9mNC81OTVBNzY5bXpwKyt1OC9mL3d2eU52c281aW9GZUlmUkQ3SVBYaFJIbFBjWEsvdjMvTjU5L1M0eTZSRVVPcWZuZWRYajd2NWw1VkhnMFJKenUyMUdWMDFNVU9PanlyUTMyci9qcC9mMG5QNitoNmcvc2JPb1pjZUFuUW5iVng1TUdzcDFZVnpHYXgwR01YVk13cVZxL3oxUGdodzZpS0w5eklENy9HQnRpUVpzM0JUY2ErVmVWQ1c5V09xTjNpRDlBNUFaYno2SjJvaWVwbFJpcHZwYlNYYmlNcVZzcjArWkRZdUV1N1Nad0k0b1FUUk8wY21DZUkxamx3VDRCNWdraWRJRUxuaU5BNVpwcHp1cER1OER6Uk9rRzB6aEd0YzNBeTRRd2hVOGhSZGQ3WWNvMHBwbis1V2RUSUg4SjZrL0FocnJsZTd2dG9kOU1PSVorc1dZZE4yc3MzTkplZTlwSHhxc3BFNnEySm9td1VRY3B6TFlqNjVxWUpyM2w2ZHpEOXZick1GZC95VFp1T01MWGFUSFI1ZGRGVmpTeFBSMWFUN3ExNnZzbEtyc1RmdS9adEl5d0VOUlo5aEpaN3hJNmo0OGpZT21UZk52TG12YWl2K2haa0RqL080USt6c3B5d29GZFhyeDVUZ0tNNTF1cEhhcTN5THRENjJ0Q3R2dmRwaHBrQ0k0TzZOZGxxUjZ2djVodVlLWEJHSHREWHErbnI2YjR0RmJ2eC8zdDF0cmV4d29jaWkwMHZaZW1HN2VGcGkzYUd0K20xb2RkdnM1cUZYb0cxeXRkMldLdTBQYTBndndUeVN4SHlTcy9XcU9jRzZDL3BYeU1xUFQxaU5zQUNOVUxaNldzN3EyaVVGVDd4RmtUWlpNaHFpVnRFZ2JXM2dzaVRiWllacGRORmw4cG1McEZ6VCtOekxRTUZJbWRaUjA2VHhsVjlvM21KM2lwK05oUS9XTGRSdzJMQnpxbjRLZWdZOFMzWEc5cm56UkhQQlhIMFh0cTBaV3hNNlozbnJwN25OazlVUE4yT0xGNnpDS3NXeDJ0ODc5WDZuano3ditGVzhmbHgxVXVTVlZKZ0RSVllzV3RvVHBKbGttaU9vem1KbFVtMEo4a3dTV2FJazFtU1pKWWtNeVhKS2ttc1QySjlrbXlTSkI4bXlZZEpza2lTbVpQUjdsWEx6WVppd25KajFrdXYvdDZzK3B2c2crdGg4NXZzc0s1aXZ4VjlwNlZQU2VTRk5YRE1nV0VOdXd0YXUvSk11LzIxZDl5ZVViWTZOWlRzZDRDcUxzNUwvKy85MTkzS3I2SzdIaHB5NDhGNjlMdC9yNy93VmpDMFVFY3ZVWk1uOE9NOFo0bEZ6bXhqY0RndEE3U0R5TXZZN3RqL3AvZ2pZcUZKaEZFdFBHdmphc0JMN2VUWkRrNWlNUm1WUittNVZ6N042TWZsTU05bTVKajhJU2Viei9Mc0pOZTRuSkl2c0t1cS84ZzRxdjhqWTBiK2xPc3pjb0hyR0xPOUxNZmxJbGRLTG5PZGtHOXh6Y29LMTJmbG43am1xUDJ2NHF0MThkRDN1dndjamRmbGhqd3ROK1Z0ZVU3K25ldWMzT0w2b3J3ajc4dDV1Y1AxRmZsUCtZQjVxT1hrUmYzUEtkOTBZazVNL3N5Sk8yM3lpdFBwZE1wZk9OMU9RaTQ3dmM1dWVkVVpja2JrMjg2bzgwbjVLK2NKNTZEOGpUUGxUTW5mT29lZHcvSmQ1d2dubysvcC94UDUvbjhEVzluMnV3QjQyclZQT3dyQ1VCQ2NUWjRpS1ZJa3dTS0lCQXV4RUF0SlpXY1pEWGdGZzZBSXdTTFllQWRQNUVHOFRweTNpWkxDU3JCNHM1K1puZDBIQWVBaHhSSE80VmFWOE12aWVzRUlobjNVTlJ3R3AxTUpYSmhqVlJ3UUt5YmwrVlJncWppbnlQSVdIVVZSQlByd01jUVlNeXl4VWpmaHppYnV5ZG9kZHp6YTdDbW00U1JwWTByZGdtL0Eya09BR0luazNKUmhKMXVOdVd3NHVaT01tT3ZtN0tjWmU3M2hyU05NZUcxenZWRXVWQXc2ZWFocUY1SDFiclc5TDlwL2VBcjk3TjhFUnRaMEM5Z0xQMXowNW9pdWNzcThBSDVPSHlBQUFBQjQybU5nWXBGazJzUEF5c0RDT292Vm1JR0JVUjVDTTE5a1NHTmlZR0JnWXVCZ1pnWlJMQTBNWE9zREdCUzhHS0RBeFJGSUtERHcvbVpodmY1dkIwTW5leW5qTEFVR0JudVFISXNYNnl5d0xBc0FUQzROVFFBQWVOcWRrVmRQbEVFVWhwK3pmS0tzaUtDb2dJQUR5dG9GbGJaVUtkSmNSY0F1c3RZWWExQVRSYU1tVnV4Q3hCSXNzVmRzc2RkRXBQd0g5V0svbUhpanR5WW1MdmtjZHcwaDhjTEVTZWJNZXliem5qUHpEQkNBZjBZak9pTGhPaE5mYnZCRHJ4a29yYUswNnNkT0xLbVNPbHVIN1lQdGt4RnNsQnZWaHR0b1ZIWVZycUpVcklwWERwV2tNbFNoY3F1V3VQZ0U3MC9Ec241WDFWN0ZSYW5zOW9vUllsUVlOVWFEUW9XcUNCV3RsUFltS21jUHIyaXZXTit0ejFhclZXdTV1cXl1YjExZnZaM2VEbSs3dDgzYlpEck1PRFBXakRHanpVZ3p6QXd5OFh6eE5Ic1NQcm9DUy94ditjOFJhTFA3U1BCWEZjSDJSOW4rVWNQdkRORGtlaEZJYi9vUWhKMitCR3NTSWZRbmxEQUdNSkJ3QmpHWUlVUVFxUmtQMWRSamlHV1lwaFZIUE1NWlFRSU9SaktLMFl4aExPTVl6d1FTU1dJaWs1aE1NaW1ra2tZNlR2MVRtV1NSVFE2NVRDR1BmQW9vWkNwRkZGTkNLV1ZNdzhWMFpsRE9UQ3FvcElwWnpHWU9jNW5IZkJhd2tHb1dVWU9ieFN6Ujk5OVBQUWM1ekFuT2NJRXJYT1lxMTduR0RXNXhoOXUwY0pmNzNPTUJEM25FRXg3emxPYzg0eld2ZU1OYnlXSWp5MW5CS3NtaGprdlVza2FLMmN4cVhmc0F6VHB1OG5GYXlaWWU3TmF5WGNlYnZHUVh5MWpmdmIrT0haTExVbmF6ajlPMDhsNlNKVVdja2lHcGtzWUxmZUlkYlZJb1JaSXZCVklxWlpMTlZrbVhUTWxqTDBmWXcxRU9jWndHR2puR1NVNXBSeFBuT005WnJkcnBaSU92VHdmYi9BMS9BZFl3alNrQUFBUktCWm9CSXdEOEFRZ0JEQUVVQVJrQkh3RTNBVklCTFFFekFUY0JPd0ZBQVVRQlNRRVlBUW9BMFFFd0FRSUFxd0JFQlJFQUFIamFYVkc3VGx0QkVOME5Ed09CeE5nZ09kb1VzNW1ReG51aEJRbkUxWTFpWkR1RjVRaHBOM0tSaTNFQkgwQ0JSQTNhcnhtZ29hUkltd1loRjBoOFFqNGhFak5yaUtJME96dXpjODZaTTB2S2thcDM2V3ZQVStja2tNTGRCczAyL1U1SXRiTUE5NlRyNjQyTXRJTUhXbXhtOU1wMSsvNExCcHZSbER0cUFPVTlieWtQR1UwN2dWcTBwLzdSL0FxRysvd2Y4enNZdERUVDlOUTZDZWtoQk9hYmNVdUQ3eG5OdXNzUCtvTFY0V0l3TUtTWXB1SXVQNlpTL3JjMDUyckxzTFdSMGJ5RE14SDV5VFJBVTJ0dEJKcisxQ0hWODNFVVM1RExwckUybUppeS9pUVR3WVhKZEZWVHRjejQyc0Zkc3JQb1lJTXF6WUVIMk1OV2VRd2VEZzhtRk5LM0pNb3NEUkgyWXF2RUNCR1RIQW81NWR6Si9xUkErVWdTeHJ4SlNqdmpoclVHeHBIWHdLQTJUN1AvUEp0TmJXOGR3dmhaSE1GM3Z4bExPdmpJaHRvWUVXSTdZaW1BQ1VSQ1JsWDVoaHJQdlN3RzVGTDd6MENVZ09YeGozK2RDTFR1MkVROGw3VjFEakZXQ0hwKzI5enl5NHE3VnJuT2kwSjNiNnBxcU5JcHpmdGV6cjdIQTU0ZUM4TkJZOEdiei92K1NvSDZQQ3l1TkdnT0JFTjZOM3Ivb3JYcWlLdThGejZ5SjlPL3NWb0FBQUFBQVFBQi8vOEFEM2phN0wwSmZGVFZ2VGgrejExbTM1ZE05akJaQ1FGQ1pnaGoyRVZBUklxSUVKR3lnNEFzc2drSWlFZ3BJaUp1Q0ZWRVZJcElrZUtkeVlEVVVoV1Y3VkdrU0lFcVVrU3JPQzVvWFNoQzV2RC9mcys1c3lRRXNPKzlUOS9yLy9lTU01bVpEUGQrei9kOHozZGZCRkhvTGdqaUdHV2dJQWw2b1hXWUNKVWRJM281NjZ0QVdLZDgwREVpaWZCU0NFdjRzWUlmUi9TNjdQcU9FWUtmQjUxK1o0bmY2ZTh1TnFQRjVFazZYaGw0L3FYdThnRUJMaW1zZ2lkUldTMG9nbEZvSjBSMGdsQVIxVXRDcVZ3Qi8xaW9JS3FwVXRVZERSdGRzYkNaVklTTk9xY3JyTWcxTlVLWTZKMHVWYTVwVStXdTludWxJZ251c29wTUdyRzVIK21qVENzdnI1OUZzMGd2dWgzdU1WT3lTRWZnSGpMY0kxOWcxMVYxd1NpdVJhNVFsUURlQks4dXRLbktJWEF0dnh1ZVpwYVFRUitTbnZCOFVyS0lENXZqODlrVHd0eExFSlQrY0wwY29ZRFVDcEZzZ0RuaXpjZ0tCb01SUFZ3N1lqQmI0SFZVSU5sNmEwV2Q2TXpOSy9ZRnc0SVNxL1A0TW5PS2ZZR29Jck0vU1k3OEF2eVRBbi9TR1UxVytCTlJtMVdxK3FOaGd6c1cwUnRNRlhWZDliS3hvaTdMb0RkVWhMUGRNVFc3TXB3RnZ3eU9jQWJnd3d0ZjgyYmcxN3h1K0pyWm13RmZzN2hqWVQrcFVOdGx2OXJGODBNcndWdGhlcldMNzRkTytFTE5kdFNKMlhvMzNKdzk2L0JaelhMVUdiTU04Q0xEVVdmS01NTUxyNlBPNnJYQUZ4enMyY21lUGZpTTMvR3g3OEMveW1UL0NxNlprN2hPYnVJNmVmaWR1dnpFTnd2d2M2bXJRNVJ3cFE0bm9pSTNMNytnZGFQLzFLN1pzQTl1WjlCZEJBOC9ib1lVZEJheGg1KzlKL0NyMTk2Mld6OEtFbHVRbE9Qem1uM0I2S2xxK3ZkMjlGZzcrbTAxNlFnZjAyTWtTSFNra3VoSkJUMkNEL29qUFVUUDB3TWtpQS84RzVBZ1VNSGdpeUY1bDg0aEZBaWxRa3RocEtEbVY2bzV3YkNreE5ReTJKQldsYXJ4YUxpWkphWTJjNFFsVWhHeDVCVUZBb0ZvbVZzd0FabmFQRG53VGkxemhNdGhRekl0c1hCcitOM01DTlJKYXNLWjVVQ3dMaWNTckpRUEh3bEFzRjFJaHMvWldxcHUyeTVVSGZSbStQU2xaYzU4NHZYbzlONmk2bUszQi81cUk2UmRkZHZTc3NIUHFXdG5ySjFSL2ZuYlJ3Nm9TMzg1OTR0M3Y5cDloSDZ6dk5QTnZYcVN2bzkzN2I4dnR0aFBlaGIwSHZmZ2tJMUh2TFBtNXQ3enpTQS8zZC9sVDcvZGVEUmovOEZpNmF0QU43aTJzWHY5VnUvMDZoNzVRTHJDa0l2ZjZCWXJtd1N6WUFjYUxoT0N3aVloWWtFcUxzSGpWeUVMWmxpWEZVbFpncWRvRnZzZ1dsVlFJbG5oRjMvbk5ySjNidmFPcUcwclZlRm8xT0VXbkhDa0hJdzRvenIrVHVjSTU4Szc1dnhkY3dmaUoxckkzb1dyQVZVWkRxY3JZclJMTlRVMTRkYk40YlcxcEtBR0VWWmxBZHpsRnNMSFdXNTRwUk5xOExTM2JSY01aQUN5aWdwTDNiQ0xraWNqR0VCY0ZSWHFTTnJmUW1tZkQzbDc5Vk03OGZHb25QSDloZGptR3p0MjdvRVBjWFhpRDhjU0g4a2Rudjd6NFRXci8veHUvVWhsOWZteGNvZmVFOGIzdVhIQytQcWoydWRyOElQZUU4WUIzZlM4K0xFeVNJa0FEb3VFU21HdUVNa0M5SVVMNUZqRUNHZ0x0NVpqUkcxVHFjcEh3eVh1V0YxdWlReG5VN0RIVktFeW5BdS9TaHpoQ3NKUGF4WDh6cFdCUE1RYXRjU3BGdGFvRmE2b01hdkFieXYyMWFnV1o5anVRNFFVWkFFYXZQQlNiZTNjS3NnV1QyRnorRHZneEZGU1d0MjJzNGlMZHlpK2RpR2ZUdS9UbHdFYWlrc1FEU0dpYzNtQnJEb1RobytlSkdOTWgwa3Zqb21lcElkZjczNzlaM2NNT0h4Nnc1c2Z2VXYvVGpwTkd6VDJEdnJWNGxXbHJVY042ZDJwQzFsT3pBc2VXdFg3Z1RzNkgzeUdYcHoxK3NSbEMxNmZlbmpkeG1jLzNuUGowSnVKcjRjNHVIdnJmbTFMYnV2ZUNkZ2lRVjVMempKZTI0SnpXbzNORWxWaEZDS1pCUWZzdXc0V0xBbHN3UW11Q3d4M1NJTFY0cmtrd2h4NlVxcFJ0Z09kdWdXaVdpcFZjalNzTjhYQ1ZzYXFYUTZoeEtjVEhTNmZ2bmdPeVNMNVM5LzkzZS9lWFVvL0lzM0ZYdVMzVHg5Y1FmOUlCOUQ5S3c0K0RkZXFoV3Y1MHE4bGdWQkpYc3ZYenVVUXkwS3k0QkNVV25ZWmtrK3k2YWYwby80clNEWFpUTnJDVmVndDhlMjAvOU1jdHZIaWVjbWdyQldjUWtDSUtMaE91N1pPRjY1VEZRTlJzNW5KRjJNZzdJYlZtbUcxWVdLcXdmVzZRMlVoWDFsUUgvTGhOdm1LUXZyeG4zNWF1OGUvc2RudTJrOCtxZDNkYktOL2ovVGxpQkVyZm5YMjdLOVdqQmp4eEpObnp6N0o3N3RNT0N5dmtBL0NPdm9MUUVpcVBoZ21oaGdJc1loQVVBd0lKaU5JVGdGZkVzbFl3WlpxUW5EQ1JtQmdjaUJpTk9IZmpIcjRtc21JTDAyQ3NVSkRneHRrYU9KbkdabEJpc2gwK2pBOUlYWW4yV1FhZlFUdzhRaVp4dUdvcGxHeW4vUVNUTERQSUQ2amdzWUh6SXplOWE2WXFuZEVSY1loVmJFeWJOSFEzSWtVd2JXQjAxWHZXMEQ2dkw1anYvZFpIMGpwTDNhOUl2SHJqaVdmaUNja0J4Qk5JYTR2VEtRWVBvZ3FWNFlGNEJzU1EycFlTY0k3VnB4TlBrSHV6di85QW5oQ3VFQVZFU0lDc2pQQ3RZbTAxM2d4MktPd0JFb0ZQdmpGVUUwQm1Kak9RQzd1b2VmbHdicFJjQjFCSW41U0l5MGpodnFaOUx4Ky9Ma25VUWVZY3ZHME1oN092bDNJQXQySWNjK3cyeGlMeUhqeU13MEFjRGE3aDhNWlEzYm9CUW93T0dQaEhKVFp3Ty9DRnFiRFpDSmZNMmg4elZVY0RNaHdUa1VaenExWTRuRTFjMVczRlp1SlU1NGxKYjkvbFJROXM1YSsvL3NkOU1UVDVMcVhTZlltbFg3MmtuamdJTGw1MTF2MDVVTUg2WlpkYjVPYkQrMmhsQWo3ZGhINUlzZEhGUUM3WGxrdjZJUVNJU0lqaitkcWxaN3Rrd1Fud0lCSFVXYlNDbEZhZ25qUVY1RTF4K2krODByNXZQTkQ1REdkK0xYR0NJSzhWTmtDL080Nmp0dHdsaTRXc2VPS0RiamkzRXBWT1JwMk9XSVJ4WVdVcFNCbDVRRnl3MWtDdTc1cWNOWXBab3VMTWExZ05kSDRrVTVmMXBuQTJyMGVtMlFuZnVjWTh0ZUhKdDV4YTcrRkEwNU1PL1BLaDhUV3JIcnMrTnFZT1BVOFdYTFh3N1czamJ4dFhPVHBoNy9iZi8yY1VaTUhkOXRLdndIWStsNDhMUzlrT3RuMVhDTUx5d1lOTnB1T3d3WmFsUS9XQ3dDRmZhQTd3dGJnRnNqWlRDcXJObWVFdUlDMTFxaDJsK3BrVWpxZmNBbFNRY29BS3IrWDVFdGVqMURVck85N1AxdC94OCtuUHJGNFVSV3BqUitROXRKVk55MmMxcFdlL29MKyt1VEJXd2VPNkgvcjhIMWtFTEdmb1J1czdZYXNHdmtPL1JGcHBnc0kzenpZQzVOZ0ZYb0xFVU5pTjZJbXM0RllLMVFwR0RiSk1hYVEyaXBWdzFIVkVnanI0ZFRDNGJVRDBIb0QzNlN3MmNSQkprN1ZpcFFEd0lGMmhLY1dYbldSM01TMGN5YzlITzlPdXBENW9rZDZ0UDZ4aXdMZEQzeE1JSy9qUGc0Q1hEMEd1TW9WQmdpUkhJWXJvRnlVOTJHSFBoWjFtM0tzVnFCbVBhQXRqNkV0RTlDV2o4b05vczFtWjJqTDRUQ1lBRzNtVEVTYkc0amFXZE1BY1lYNk1qZEFwUWVwbkM4eTFBMTZ2ZmFGbjA5ZHNPelRlMTRwbDZiRjF6ckgzam94c3V4bjlDL242TjdYL3Zhem15YU0vUG00NmpuaVcvU0xjMW50Sm0yOSsyUDZuU0JvNTAxK0Q4NWJ2dEJjbUt6dGNDRlFudzZodGhvQjZySnNIVUt0QU5UbDdPZ1ZPR0pxZ1NOY2pQc05DMmdCdjRzTG5LNm96dXJPZHFCYzlUbkRKaU11cHF3UUZnTWZ1SjFod1FGTHNicFVVNDJxYzZwR2RqQTdTeUJZZmZyV0JFa1ZLUldWTlZoTVdhbW9lREw0U25WVDJveFpjZkRlWlg4YXU2SHZ3dHI3SG5OY3QyVDRZNmZ1cDN1L29QSFZ0OXhLcmwzeTZTTDRYMXgvLytkdlA5UzNiNy92T3JiYnVxcWlhdXlmVjd4UFAxOTlDeEhOUSsrZU5YTEl6THNZanhma0ZiQS9PdUNCRVNWQkpXRUJOMFJmaVFjV3JCODhVVklONDRGZVlGRExaRU44UGwwakxwU1hFdWVaQ3dQa3BWeTNIWEx4UzNrTG5Ga2ZYS3MxWERuaVJjemxLSnFPMGxLSlJVdjlYaU5ncmhUVmxVcG1iUlVCMFJVNTFNeG1Sd0VoVnFhd1pGcnhJNmJpV3VDditmZ25selVXYmdNZkZPa1lMR3E1TStyTmFlWTNNcDNGcGRvQnMzNGdrN0RnQXB5V2doSURLcDdhRWhRNWk2YkloVm9EQXlobUoxK25SNlRLQ1kyRjQ5U2Ryc1BObUhuYk1KSjE4a09TT2ZTMnUyYlEvZC8vbmU0bFZmZFBuN0g0d1E4ZXJKZzJaT2pVcVVPSFRTSExGN3pRTHJScTJvc2ZmZlRTbmF2YWRYcm1ucmMrK3VSUW43RmorL1VmTmtJMDlSa3orcVllbzBkeG1wb0JOSFdDNlcrbHdoUWhZa1hNZU9Ba29OSWJMdGJGb2xrRlZ0Qnh3MWxJVTJXTXBuSk5NVFhYRVM0RTY4b0hJdFVSQ3pkSDFVM1EySWxhNkt5emVxUXN3SUFROWxnQkxZNGFOY3NKL0VRdFlCUlc3QXdiTlhZdklGRmxhUHkrdEN6RURrMG9xYk8xWTZ1ZVFRSi9mK1QzdC9RZnRKeCt0SGZGcWRFYitqMTIyMzBySERPM2ZFbS9KRFgzM3pWajBRTjN6VmdvN1hpZjVQYTZwVCtOLy9GenVtN1BvUDdmWE50ZVhUWDYzS2NqWjkzOTV0dzV1RllnQjNKRTdzM3M5K3FHa2xFaDhGcldKS09CYVM5eUFBV2pxbU8vd3Nha2ZDVHdXRXI2Z094bmNsSVNtYlJrdkEwK3crdWJCSnZRRStRaFh0UE1ycG11SGRoUjZxam1BRk1RcklHR09vSUQ2WnFwU1lvT1VaU21MYUNnNzhJMWhrclNKMDFwa1B0eWVRMlUvWmc4UVhIQW1SSGNBS2FST0pkSkorTjl4Q2hUWGlMMFEvb3gvQnhuc0c0aU5mSk1lVHpEUlRiWE1rQ0ZBZ1ZEUVNsbXFOUVc3TllXdkVuYVgxOHQ3U2MxSklkK0lucFJMK1R5TUFyM1hNSHZHY0k3RW1kVWpNYjdTQ2NmZ3dPWkJ6L0Z0Qy8vcmlpVXc1bTJLWnZoSE9ZSXR3dVJUTVIvRnNlL2lPVG1CUlptdFdlS1lGSlpKU0VUa1FVaUsvTm9PQWN3bGVNSXU0RE1GRTE2NVdRQ0Z6T0xkcStOMFprZDZjeGNvM3FkWVFWdEE1RmJtZTUyL29SSUxaSkNtcWhsbUN6ZlIxcDlSS3d0cnI5alJrL2ZvVXJ6amsyamIzdHgrVVRTUno1NDR0VCtQdk52N2Q3Q05wLzBNZWxIRE9yUlozbTl3RGRaRkNiVHFINENuSmZyaEp1RVAyaGFiMHUyczJxbnltaUl2M0pYcXZaZzlIcFpjSUdSV013LysxbGxOSnQ5UU5SK3pBb0k4RTBQY0NkR2QzZE03ZTRJOXdiMXpzK05STDhqWEFidlRPeHI0WnZoTzcyN08xM2JuRzZsWmFoVE52SVh2ek9jbXdlTExYUFYyZlBiZDJDSWNJZUFkdHAzQUh2eCttSW5DbkgxWjg2dHBneC9XVURBZjVMdGl1VG01ZGRveWxZNzVEdDQvR3hpVVNHYVNtaEJ3UkgwaFh5U3pxc3hIckcwdUtqUUJsTGZsU0hqNmZUcC9JV3Q1WkkwdGpUNW9hL0p6MzczQ3VuNzViS3VVMVlNUERoaDZZdlBIMW40N3V5dFkzMS9INkhyMTJQYWluc08wME1iSDdpd2U4Vk45L3lGVkVkV2ZIRjNlWnorZGVIZjkyNlkza1ZjUEtGMjFPTVRCOXorcUZpMWxmVCs5dEVIVHRLL3JKbS9lMzYzZWZQK1VyZjh6Skpsazh2aTcrVVgxdlE2c1dzNU1lNmJlOHVxZmVjV3YwaVB2TC9ndXA3WHJyNzJyaGZlL25UYzBBa3YzWFBySFJzNG5ZRytwL09EanFHSGs5aVNuM1BRSzdpYW9UTUlvR2FFZFNoSHpGd25COHAzb3JDRDR3MDA2NWY4a3RzdlZZbmpTS0U0am01YkZGKzM2RHN5L3pWbC9ma2hwQnQ5VFJ4RURzR3AyUXg2ekJTUVR6WWhBK1R4YUUwWHRPdGpYRTdsZ3c3aHkyQzM4aUhuTEdDYzB3NEN4QmRRN1p5VXpXRC9acU1NMGRsajRXYndnYzRGY0JoZ0V6UHNuSnA5VG5pcjVydFVYUTNqUFFFZkdQYWFrQ0QrQUdJZlZBditlN080K2g4TFJ2OWg4UVAwd3gvcFVqTDc1SXhaZEFVcCtuakNHTHBYV2IxZzlNcjlFd0libHIreGozaWU2OTJmNk5aYzM0ZWQzOG1nd3o4SjlKd3JkTkpzZDVla2FmQm1pU3MvQ0xpTEtUOUMyQVhXdDVwUm81cWRFY0hnUlpWSGRxbjZwT3F1YVFnMmdOREZhWVhwOFpOM2tFSEhmaytuN3hpeWJzYnMxeWQ4c1hYNnh1SDc3cUpmN3dHTi9UWHh3SDdTZisvZDA5NjdwYy9kNzl5emcvN1l2L2JZUFhmdklyZXd2VVE4bzkvU0luaUZhelFiQTFTZEpNTWdhZ2FEMEFySXREckNUdFFSQVZnZkF1dEZwcURYVU1mb1hBUjRwSVJDdTFtczNFRHlkMCtkdXB0K3RPSDc3M2QrL2ZYTzc1WFZkNzVPLy9HclZmVGNHMU5JM3RjN1gvODc0QWhna0w4QkdNeW9WN045TmhxMGZRWUZPNnB3a21LTTA4S0FBYU9hbVpuTUJEV2FqY0RhQTl6ZTFJek1ZSnFSdVZtdWlZTjlFaDhpbVpYVjlEUTlRVCtqaCtucHRQc2FoYTc4dnRvOWdVMGFGSFpQQXlMQXhPOXBUNzhubUwzYURjMk5icmhaN2w3L0QzRnpmQURjN0JROVNFL0ZqeVRvNEMybVc5NnQ2Y011d0RLeXQ3QkZpa1V6ZkRrSzNDOURsNkpsNE1sQXlCNUFlSlkxRnZGazRYMDlHWEJISkdVUFVIQkVzZVFnaFdTQnZEZWdpdWxDZlRtckp1ekxBQjVsQnhWQXRhQjZxU3BJOVNtR3hHbElaQ1FVcWthWVpUOFMwZlJkSk92WlY0azRlL2ZQWDV6NTB0Ky9mMDJkUTk4U3A5RHY2WXZINll0L0VBLzhpamozemh3eDVwc2JlOUp6cis2aXRQWUFjY1FmLzlzYnBEK1hWVWhMNDlrK2R0RzRncDV6QlZVSlJpVVR3NmdrSlhjUno2Y1lVTTBPMURaUkhkRGJZMDN0SCtrZzlpUWQ2Szc0cThycStGN3htdk5qeFM3eG5YQy9WK0dtNkFlU0JIL2EvaVV0YjdnYVBsS1c5NnVrSS9yYkdLeDVGNytVenNDL3RhTU5iMlAyQ1p4TEEvdjNEbWFRbU1DVWRpS1p5elp1aGhpY1lCbWxUQS9VR3ZTNm9tWjV1NitkMzJ2STdhVDdBNHUvcGlmZk90R3IxOHc1MHByNjJuODhzRmpEeVM2R2t6YU5jQ0lIR3lLQ0xaM3AzR0hKV0ZPaktVTitJL0JNdllhRStmSHQ0bWk2bUY2M0FUQ3hYSndSZjdaK2p6aHFNKzJkeEw4Y1lYRU9qU3ZEaFdJYVRuUUpuRVFrUnNHU0FwU2tUME0yM21HL3N2ckNZbnBLdTVhdUorTUwzVFM0ZFdsd1c5blZMSEFNTFE2OENtT3hOdVFONkU0VmVleUVyY1NncmNTSTFxMlRGQkc0MFFBeUIzNEcwTjEwc29GT2hhVThMdzQvUDFiYUdGOGpEcXNmbHFLbERleHM5bXJpL3FZa0d6QXlkM2xZWjlKaU45emZGOVpKakRVMWhvSXdBeFpBS0JLZkl5SDZmZndHWlhYOWNta0czUDJSK21sTS83aDRXamNDenFsVHlFTWRrMUZHaHFTZDFGd2szbngyYnhjY1Q1Y2puSVgzQkg1WWdNZlVoWDVsbThMOHlybDRCaE5xT0Q5M25EODJLeTRWU3p4SVF0enpNbm5HWHBLLzdqMHk5TTI3OXRLUDZBNzY4ZTdwNUlZNzk5Nno0N3QvMEFlKzFVN2RidnJiUC82S2ZyMTMxc3c5eFBuVTNIZm1FZVcxM3hNOXJVL3c4QnlOaDJ1N2xWTDR6RllCRkw2dzJaQms1Ulk3MDRzdG5Kc3JqblJ1cm1qY1hFQ2RwWUpra1JRejcwMUoyZUJuRDgzOTV2eGQ5ejl3TjNCeSt0V3BPVy9lY3kzdEwrNlpOMnI4Tks0YlRMNTRSRGNUOE9jUmlvVkJRc1RCUERnSi9CVWgva29ZRUY3QW45ZkJlQm5pcnhUREdWN0FuODJCK0ZPTnpyRFppbmpNWW80c0czeFU1SXdZelVKTkk0d21mTkFKcEtMWHMxMGp4QzU0WXQvYTE3OVlsOFRzdU5yUDkzMVoxZ2k3ZjlzKy8rVHllUW4wbHUwNWRXVGdYUnFHRXpoZXhQUVJuM0NiUnBFbVRwRmhIOU9yR1h1em90NlR5VlpvQXpUYkE2ck53Vnl6T2tBekVvdmJ4bFVQWnZocmVyV1JhU0thRHRJTWRSQ2RIazU5VVJib0lPMDA1ZU1SNG5oODN2cEh5REQ2Q04zM1BlazYvYjVGTStsdVpmWGo4dzY5K0dFMUZjaCtXaTJlbWpwOHpCMzgvUFFHbTN3NzJPUXRoTEZDcERuakJhQTdlUkhjYklTeG9sSjFIUTNud1FuS2N6QlBlUW1jb0pid084L0YzV2c2NTFiSjdNMzJvL2RmTFhHRmZaa3N2dFNjODhKc1p4MXhaWmJnMzd4b2RMS0FFNk9WMXFTc3RRNHQ3bVkrUFNxdkdCTkFueFlxS3IxZi9mTmZSdDdaY3Y3ZDNVZFA2SFZkY3gvSk9rRUNINjAvOE9LZ2tYZS9OdVBadWUzcHlhODIwTGNQbmR4eVE3Y1cxNFR5blFVVnJhL3RlM3VuTjg5c08vTndyNW9ldmRyazk3ajlvV0dIdnJpTHJiRW44THNZN0lsZWFNK2p1cG9QUTRxcFVvQ1ptYnFqWVFWWW5xSmpya0lRMmhHZGdpOTE2RFUwTnZCSDk1Ui9UZnZRWGZKc1VrUlBYRmdxeitaNFhIVXhwc3lHZXppRWtNWU5kQkxucWFvUkdKRXp3VlpWaVlreDVPVk0rVFFnQTdMVmFEZndaRFJqQXNNaCtKc0pxMGlIZGFSMEhlbEk2K2hmNlB2MFZYR3MxTGIreUcrM3FSdWxkdlhINkU3NkN1bkIvS29YenlvSG1ZL0dyNjFQRUptcW5YTFJDRHJHNytBdVRGRDRxOGdRTWh0K0JzUjMwTStCdDlta2I4OFB3V3QxdW5qV3NFTlpDenlpSjlmeVZFT1FYUzRzNllKSmprN01NWlZ3ZWtBdER6bTZqcUQ3MklLYkx3QnpqNGlLaVo5QnZDRzdKengxSXYxSk9lbEdiUEFvSnpkUUh6MERuR3dIQlFrTFp1M0IraXBwLy9raDBxYjZXb1pUOUZHdVlUS3hWRHRKQUl2STlRU1VpVndTaXNpNVpSUGozUHhXN1A4dTVIdnFKOU5JSzFKSnhzS3I3K0ZBdkViL0lMNG43cVNWNUZEOHVuZ1IrWko2OEQ2Z2JpdnI0RDRHbEwzNkJ2Z3pNaEdQVXN1RWE5VHpLRkZZMERkQUoreFlGcGxLYWdHcDQrTHYwYmRCVkwwaGRxMS9QcjVMcklickw0VHJWekFaMVZxVHQzcTlwdHRMK2xneTRoL1djODgwYUJoT3pkU281cjVldjNPaDVJM0w4bVAxWDBxZWI2U1Z4UHROL1FUNkpjSytpWjZWdWpEYXJ1SCt1VERRdXFhZnlqSE5oeExWOC9BUEtBK0tKYWJGTGRDamtpUnRMOTVuazdpU3JpSVQ2Rm5kK3U4dlhJZk9Ubkx4WTNwZW5xM0ZIbUFQODRoUldrYlA2VWFkZXpJUkZ6c3IyZGo5dXlYV0ppZldwdDFmZnhTT1dWU24zZFFSSmhZZ0hqaHpqZ1FnVXNMTDRRTW9VTkdjQTBDc0VsZkdKL3JrUDN6L0k2UExzZEszMG1wRzQwV3BXQjdhN1hpQ0d6Z2lGZWFHRHBLaU12MVkwdWJQcE0xSHI3NHFmVXMyMGtGZmY4MWd2bGhQdDh1SExtNkFDL2dFdkRsZ0RCOHNyc08xUUQwZ1JKYVBYS2dZZkFidWZVcCtTenlpYXdYZmI0YmZSMStWTXhtNWlZcG13WmlLQXBXNGkwNFI2K2t6eXZhWmRCV1FFZkxYRG5LdGtBMDBmRGYzZUhLSFN6NXpRa1RzQk0wWUJUYWxPTk51clloS21uZUt1L2h5TE16aGdoRWJ4UjhJaEQwVzd1VExRWm8zdzJGVHZjQitqZmJNL0dMbWRaQXkwV09Wd1FRalNnKzdTN1VrNHRRKzduUmg0UTJRSFlCcGREUncvMEVuZ2l5NDk5ZjdIL3pGN0x1V3Irczc1dTFmbkpzM2l4Nis5OEM2WTZUVnNENlRsdHc2NWZicHBNdVdjQ3ZYcUhFZHo3UnNPVy9XWi9GRnM1ZlYvYWJ6OVJNSGhzcjdvZXhiZHZGTHhhSWNFMXlnRTQzVjlBczdVNHlVR1BQc2hYUHhSUzVqc2dRRGdwcU9CQ0pGZEFjQ0NVWEpaRW9wU25XS1BTT1hyUzFENEg2VVhDYzZ4Qlh1Y1VhZFZQUG9NOStKVjBwNWJKZVJheFlmR2hsNWFFRC9oeUtqRHl4VjFreVp1bWJOaDA4cngrSkhJbjBlK21ESjR1TVAzZmpyUjhTaSszK3phZW5pVFM5eGVxNjllRnJ1THcvamRqaHVWTmlwQTNwRzRNMjZwQjF1czJwMnVCTVFybm8xTzl4ek9UdGM4K0dFZkRaNDAxcXNmWnlZMXE5NDU1WlhPa3dkT09OWHErZjN2cXZ6dHRzT1BqWG42S3Bhc1dnTmtaOGVQZlIzb1hicWdvVmIycmZmUG1yYzROV0h1VzR4R0dqcGVBcS9ac1N2clFGKzBaZXU1REQ4R2xMNGRZUDBkanVZM3F2UEJDcEs0TmZzUnZ6YU1uSTRmczFPcEJZMXg0bUNXMGtzQXlQNVBwUjhTQzZ0UVh2S1NMaWJCdDhDZVAzamc2QWY3ME04THg5QVFzOTh1UHJwS1ZPZkVjc1F0K3ZGdlBQbGF4SFZpd0M5RHdDYVlRMkkzMldBWHg5WXVOMjBDSUJkMWpDY0s4ZWlsa3l2RE9mQW92bm9DaXBSOXdNRkNKUSsxYzBzVlZlTm1wbXVNL1B0MS91NTB4cmRZZ0x4TTdUWExqMi9adkdoQmRmS2NkbTMvSTYrODY2TnZFRC85aVBkUWFySUVkdWNFY1B2NGVnZXRmSHc3TXoyZDl4WjNYSHRBWkFiQXlmZU96OGhmOFJ2bFU5QVd3Wk56b1B5QitQcFFZUlhKUUVVUUhxRmE4c2VGdFZHUE5zQ0ViY0hOOER0TkdLOFBlSnhNNE1jRlFtbVBsdnN6TW1sNnJXSWpqTlkzVGFFeDlNSk9NMGpRUys2bWJ2OFlsRHRDd3VHMzlCamF2MDV1ay9xQWpwTVpGQnRQcVhac3l0by9VNnBDNmNIR3BXUEF5NHhEalZKaUJnQmhad015Z0JBZTJYWUk3TVVyVUk1RllZeXNUQVVPam9OeFVBSlppdVBSUlVnUDNGaWFDVERDU2ZPazgwb0l0c0RvTHBxd21WMkRKejRPRmN4SktraXd3ZTgycUhYK1p1VmhUS0N6WnpWbkxwTGttR293VGN2ZlhuNHJQVzlTR2paRS9UMzlOdS9US3g3ZzlUMDNqQnI1TXNQOUNPaEp6OTk2cWxQbnhTSHpkNjFvTWZBbXg2dDMwS1BMM3RpUm13TXFhaSs3YmFlOSsyK2E5cnlSNmRQZWVSUkxkZEFrT2NBN2J1Rm42VzBhaDB1MW02SVJYUjJwcTB4bnVKSjByd1lTSkE5VXJ4WG8zaVFyQUpJZEdlS2dTQkhSSWJvWkdUdGRRTGo2THB5a3JxTDdoczkrT2ZqZ0Y4YzZ6L3N2ZGZpTmVLWXlUTm1USTZ2UWR3L0JrQzlCL0NnMzc2RkZzMUczRE1QdnA0TFB2bW9LZ1F3UzRTbFBEVHc0ejlHZXRHZEpDUy9SVHoweXd1ZDVONFh0ckV6ZmpGR0kreTZtQThGMWptN3BMRVNUT1VZVTNqd3lnNTJaUXUvc2kzQW5BOGdzb0RETU5YUlgxaUdkL0dWNUUyQm8vbmM5ZGR1SkwzNjZoYklCUmYyMHVjc09nWHZLQ1J4R21IM2FwWHlPZUJCVERvY1RDbUhnOXkwd3dGd1JTYVJtWFFZVWVrYWVtcVNjcXorWS9JbzdSY2ZTM2JPb0JGMm45WHdkSWpoS3BmZkorbDZnVzNCUjhyMXNwcUVsR1BueTVQdzZYMUEzMzVoZk1Ldm14a0VXd3JwSExkZU5RZkRlWWFZNmdFVm9KQmQwTTkzM2MvbFNDYTh5M1JnTENkc2g3c1VvVWp4TXdKUU01bkR5NEVtRnFnTmVlbEw4ekp5OExWclNCTU5pT05Ya3lZK1cvSEVrWmZmcG51SERicHROSCtXZTYvcFAyendnQzBIMzQ1WGkyUHVuSTZVa3ZpZHd2Y2NXSTg3NGI5a2xtRmlOVWpJUDVGNlNScjFlcTlNdlF5cUJzVExlZkI1Z01NQis5RTlFV3ZVYVNJa095WGxuTmFZNm5RZzJ3b2J1Y0FMKzV5QUtxdFNvM0dISkJkR2ZwQ2VMNUlLU3RUKy9KbS8zdnNpY1R5MW1wN1orQ0w5NWlrUy9QVzl2M2dhSDJMUnpIZFhEMzZTWGxpN2hwNWYvU1RSclowZjJiSVFIcWhMME8yS0JXQkVXVGRNU0trUkpNbmtRSmVBdy9aUDZoRDJkQjJDcEtMVzZUcUU4K282QkFEMytOcVVFa0hMcFlsSkxRTDU4bmJHbHpYWWt5TGFrSVFkNUxScXJ2d241Yk10WFQ0YkdzaG41cDM5cCtYem8rZnZKSjgya00rTVJpVS93RzVOK0daVEdJOGF0Ymlzalh2NkdZMEM5U0RydFlLNmdZa2hRSnZHTk5vRXRBYWRDYW9jODZuSjVIeDJpOXo3eE4vcDc5L2NTU2V3M0syTFgwcXFQRmlveGpNZUZMalpFTWxFSk9XajNHcFhxWHJoWEx0amVLaUJUNFRidUdQaEVQejJlekhPVFVBb0thQUNnd2JjUEloZWhqYXVjRTR1ODBBRXVRY2kzMWxIdkxsdDhHK1pMalVuNFlHb2J0dGFYOVphcm1aWm1na1BSRDd4NVl1K2ZJVm5iVll2M3ZyQ0wvVU9aMEZtZVc2VnZWMi9vUjJiZjdKNS9IdTN6VmJuWE5PaHBrZFh2Y0dxdExwdVFFMTE5bWM3NXZ6dzJJRkZ0V2FQMDJZejJReDIyVkVRdW01c2wzV3ZYdGZ4Mk5pSzR1eFdPUm1pSkl2Mm5QS3FyZ01DTDlmMVoveWd3OFV6NGpsbEZPZ1hvNFdJRTlkdTBYTUtCd01YVFBhWXFnOGs4dWRrRkcxSlRTTVIyUEFrOHVkUTcvQVlHMmthY0ZaVmU0MHFPRlViMXpRMEZ3Wkx3L1N5SlRvN0xBSUdMbExhcHUyQW5oT1hyZDRBdW9hWlpOTFA2QSswb2wzYnN2TmRWa1pGQThDNkNIVFBhWEp2enJ1UVkzQ0FkUVlOWUZNd3didUFvYU9UQTRRR3BodGFOTjVsbGRqSkE4bHJaUTZQaEw5RDg1RDdtZkpRdW9pRWtHbVJhK2hleHNQSUluRlAvT25KMDJkTUVtKy9zQTA1R2VLdC9PSTVlVDNBa3VidklKZjNkK1NnNzZHYzlQN2hIT2xPKzlGUDVON3hadUtIRjdab09Xa1h6K2tpY3Q5Ry9nN1MyTjloVC9rN1RGZnpkOEFOMlQzTjZHYnBxQjRrbGtOUlVrMDMwYzhPSDZNeHVQMVljVzE4aExqbXdoWnhYWHdZM0tzUzVNSjhXRTlEUHdlNXNwOGpoMGxnTTZra0MrbHkwdmZBUWRJVGZpK2lrUk1ueEZaaUhuMkRkSTNINGdkSUxkM0VjRVlqOG5Od0R3Zm1pR3Jvd3ZRQ0t4NHlKMHRCbFozTUpTV0VyVHdPQzRRVEZzM0pOUkhjSWRUMFFNa0dkSjcvR3RBNXVPdXpENjVZT1A3NnpzMnJQTEF3ai9qbGhhZC84MkNmVXhVRjVXaXp3N3I4Y004MHYwZEMwMmUrZ1N2NlBhclI3K0VkSzE0VFB5NXRqTzhXMng4WFo5UWZqeSt2MS9MLzZFbHBtYkpkYUFNL1RPZkNDMVpWcWkyT3Frb2dYQUQ4d2gwSUIxQzFiY0dDWFpweklJdlZhSER1amxuS1lKSkpZSndsY242UUI0aGdzMkUrUERMUk1lM21qdE8xbXJoaldlam0wZFZPL1lTSkV5YnFuZFdqYnc0dDJ6R3hsVzdjWEhMa3pOQlpya24yL25QSDljNDg2R3ZWc1d2UWMyZkc1RjhVRlMyYW5ESFpFK3phcVpYdllHYnY4WFA3MnllNVpnMEZ1TCtrNThrcDVrL0pFeEllQk1rdCtPUUs3VmN5blRUby9QS0hSSTRuRVViQWVwY2sxbHVpS2ZWVm1PU0lLbUFGckRlWHI3ZENjWEt0cHJDRXZXaFQ1ZXNzc2RYeUZDZDB2WXBsSVhTMW9sbmFnWGk1ZllyQ1R6OENsNm1EVlU3UTRUS3YwWlpaWGEyaG9iK3ZWU2RZSXF4dFVWSFJMeVpuM0FsTDdNaVdPRTViWWdJZjQzdG44bjBpK3lWVmFnVThycVVBNWhOdXZHckRZTHRlWnFZVFoxVXVIam9MUzNvTlpqZFBiVXNaelN6ZmJVelo5TnZielJ1YjE3Sk41Z1o4T1JkZVZtVVN1dnpoNXMxYnR3dnlYMEpUdFR4TWt1bFo0b0VteEpxbzVaRkVQTTA2UVdNZHdXcDMwTzFGYlgzVmlNMGo2SHJTcDF4YVdqKzdYTzZ2MWZLTXVQaTlYS3RzRURLRkF1RUN0MlZWVDVDbEFZSW1IWFhidkN3TEVCV3Fab3lOWkZtU3hUQ2REMyszajlYQWVGdXIrdFlZNHZCNGYxVDF3R084UDc3YStVL2YvUTcrYU1iS0Y4V3JjOE5sSFhVR0Q5YklXUEZacWJPeE4yNThidkR0RFB4MlhTNTd6c1BuQ0h6UzdNRm1EeGJwQU1XZytOU29lU0F4YXlKd0hYeHZxQkcyS2daclJtNGVyM2doWFMyS0RnU2J6ZTN4Smo5TUZzTVFJV3h6Y3cxSzU2eVRCYk9EcC95M2RSVjNJS0dnbnBXUFNHaURLL3FpRUlaYU1ueHVHeG14Z2hoK2JjazdValIzOVBacldrMjljNHBhUitQK0kyVXYvSkcwNnQ1bHloMUx4V05yaUxMNmlXaUxPL2Rja3hIZlp4MWJ0MC9adUxjVEtmbmRyY3RLeFpCeE16L3o4NENmN0ZPMndNbVpwdkdUSE5CYXpTSlBsb2pLaW1DMlZxaStZRmdHOVNvcndOUXI4U2o2T1hNY01UVWpFTWtSVVVMbTVHRlFQaWZMV0JFUm1hOUVCSkdKY2VVQ0pNVWNMVExvVXJqME5IUHBHYXdPT1lzU3Rycm0xdEhyOGdpWHFQUFdyRmt6ZDlGbno3L2YvNXZRNkM2OVdsV1R3N1NWT09VZ0pyTElHLzQyZDlFOVUzWmUzN1ZWOWFpMXRKNStSYi9SZU5qRjB3ckd3Rm9LaTRWSU9jc2lCWEZxd2ZWNERMR29RTW90c0o2OElLYXN1ZVFLdFNBUU5lalpaNW5CcUlGL2xzR0xndVNqdU1aSWpzd1dXR0RFbE1DSXpGWW40K3IwQVZZSmxDT2p6dDZTQ2ExQ2VGbFNXbE1EOTNMeUxHTmdqTUFtUWtYVlFZeWFnVExFVituMytvRkIrT0JYeW9sVlhEWm10U2l1M25rdHVlYjQzTGZ1NjNDbTgveUJkYmVRdWJSV0ZNa211cWovV3dObTMvRFJxSzllL0lUdTZreDJIUFMwcnNwNjUxRDk5WlA3UjIrNWFlczd2bUJyejhFZGZRZHZlUEN4K0Y5NG5GMFFsQkZ3WGpPd2RzV1c1b09QT3B3MndZcFJsS2lETDlrY2lIcTg3RE1sR1BYd3ovU0FCbCtsYWp1cXVzQmV0Y1JVQTJpbU5xYVpZdHFITGhDeFdmR2R6UUh2UElGd0pxb2t0b1EzMzlzd09PTFZmcXExbnp3eWdYUWtuY2dJMnBPVTB5VmtEbDFDRC9IZnBFUlpIZjlLZE1lSG5GancxeDA3L3JyZ0JJRGQvMkp2TWxQaCtZM0k1Vk41akJhZXgyaEo1REg2TkhkQWZ3d21rYUp0b2tCaHIvRVplZGcwMExuV0FyMlhDelhDUTBJa2oxRUlTRkE5eXdaQi90bWVzWlVXd1AxbDVLbDJ1SDRMQnhNRFhqZkdUWGxlVXdsOERDSWpHMjdiQVcxaElJSTZzVm56RUl2WU9iZnFMYTY4d2pLZWxWYm5OdmtxbWJsUkNFYXhXb0FPdDYyeUtidFpKZnUyM3FXbElZZFFualFJM1JFdEkwcFgxSXdyQ1cxTHkxb1Q1QUNhTVZXR1g1MjJyZmJEdDBsRlpPTVRUM1c5L3RZSGYzem5sZkpXSjNiVFArTUgxL1VZdXZnZkI0bGo1SjJQZGF6cUFzOGRxcnFLYjIzcTBXUHVpazF2Ymx4U1hsTFVKaiswWlBaTFBacmRYdlA0Uy9CSmkxNlZlYUVIMTVhMnl5a0p0R1RQblBjL0lyOGxUZE44TTVXc01rVU9vbE1HTllPRWJ3WVZWUXRUVkdXV2poQkxjOUNnbnZ3SXFYaUlWSEQvRFBlWVNDem1IMkl4L3lLaG83Q1MwMm5VeDB2VVdBWmlNMTZQMWo1b1U2endpNzhyYThYZWxXbWUvVTVNNXJ0NDFxR0w1WVJIMi9CM2JYaDFtcEduR25iR2JONDJUbGRYbzZ6NGJNM0tXb1RhczUwSnRvZWRDZFdvclp6YmpDNGh0N2lpSFc1Tm1VdHRrUWg1TjBzbVdZRXhIZ0tWSmhqb0xGYTNGWXVMQ21WUmFXRHlwSTUwNmVTN2RoTVBDUkQzMnpQdTJrMi9mT3FQOUtVM2E4ZHMvbjdwZ3ovODl2YmYwTU92YktlSE5oSDVkR1RDWTUybWpicDk1SDBMUm5VYTNIWkd0MVdUTnA4V0Q2d2t6cjJ6WisyaFgvOXFKZjE2Myt5OVpPQ3UrNzlWeDk4UitlR0JPdEpTamRBL3ZmalNWNTA3TEJyMDhQZ3hEN2Vxbkg3OTlWOGdUc2VJSVhHdDhoelRoOHFGcFVMRWhYaTA4bHhOb1RKSytLdWN5cWlmdnlxcmpPbzFUTGJRWEd6UmZJNitmQWM3MThiaVFDRHE0empFb3JaOFpIcDJ6S1hQQkdLM3VuTDhaUXlQTEIvY2w0V0ptMDVWMW9oYnRUcUI2L05DWHBJZU5tbkhveVpGMWFtQ1BoNDFHU08yai8veGwxTjc5NzZ1YTk5QkZSUHZYZHE5MjRidU13YlAzQkJzMGZIR0RtMURvR1F1V1VKZUdUNHkwMVJkMDJ4aFZmZHU5OUxudS9VZE03U3dlY2ZXQmI2V25HWUhDUDNsUGRJNXNHbkF1SEpYRTUrUjZMVmZBOGlnTS9RSFlqNXpKUEZDekhPUS9UUG9PcnB1TnRtZmZNbjQ2SFBrRzNtZVBBcjBIazB2Qm90U3E4WmlKcVNPMTlwWVFBK1hFdEpCeSsvaEVlN25wT1AwaE5TSFpNUWZKa1ArTytxZzVBYm5KaUIwRUg1MytaTlR4VThPcit1TVZBVVJ4S3BpNE5tdEE5R1NEdXh2SmRydWQyemlIR201dk1FQXB2T0c0SU1XL0lNV0RRNVdKeUNLUURHcjJGWkR6aWdjcnNwbWVJUmF1TlJXekRmVUdrOVpsZE1WTlFxNXJiQkNTTzNnL0ltbmkyalpvVHE5dTZpc3lPdE01TVg4dE1NMWpBeGJXM3Z0ejIvYXVYL3o0aTNYOXJ5aDI2YWZjckRpNzB2ZTJtdW5EcG1iUnoraGxEelJ1ZDAxSFhEZkhwRVBBQjljRC90V25JaVo4cUJqMnV1MG9DZVMvQ1BpUi9LQlk4YzRUUzRWdjVYNmduNXJBUTIzcjhDQ3V0RU1mZ3BObFNpTjJUNWtzWDJ3Y2tSYldSWkxWTThSblkySkxHRHZoMDBzMHd1TGE4T0NYdk1Za2liTFk1ZU9YajlrK1pHakR5MC91bUZ5djVzblR1cDM4eVM1NzgrZkczcHcrYklEQjVmMm5UYjk1cjVUcHdGc3k0VWllYmtpTUQvNWJRSXprcGsva0JVaDZxOVVoT2hJRmlHNnIxQ0U2THlrQ0JIbDlISXlBeFNFU2ZRSmVwSStKNTBVOTVFTTRvZlhuOU9UeEI4ZlRBejBISnc4UnZRczMxQUgxb2NGSUJ5c1ZUbHd6cVVWV21uNGN6RDh5Ungvc2dPZEMyZ0tJdjR3NzhvRzNHdXJvamVZTEZiR3RVeWd0Mi9WeVVhenpjNlU3eXJzYUdBa29Mb29UbG1vSDBPR0EzY1J0OUgxZEFNWlRJWUFZTU14bVhHWGFCQU5GeDRSemVMYjhiT2lLYjQ2Zms1Mi9GdkJTbEFjU3dXSk9MeHd4VGc4Y1Z2aCs2ZUpsWjRIR1Q1aDVnL00vMDYzQTIvc0RiWm9EKzV2VXkzQnNFNUplckNZTzVubnZubTVBOTdid0kvRlRGVWRlc0J0bnByTGVMREswTk41eDgxRDdpQTFkRS9yeHdhWHROZWpzemkrY3NqaStYZUtJeTlzVzNmamNMZVJya2Q0ZWdIdUxTeS9KYVQ1c1NReEdYeUp5anc1QXJDc3M4Y1kzM1pFQmY2WlVKa29rbTBybENOZFltSmJMOUpPdUVnZW9idXFYcVkvckpXMm55VFMrYkhrMlBnUGVDMHFPUWFXZUFIZ3Jua0NkMkFHWDdFSTFhMFZvUjdqTlJkRStKYXVGWmNMbnN2blFkaVQrUGU1ZzlLMzJ6NzUxVmxpb2c4Sy8xWjBKZ2tEUUNmWkQzelRDTExZSjB3VWVPZUJGT2N6ODFlR3lxaFRnNWRsOGtWdEhGNmV5UmRWT0x3WWpMQ2g2ODVreHNKRVo1MGtHdlFvVWhSWDJNSlNGek9Rb3BSRVE0Rm15QlNibFRMOUl4bEpIZkFLc1VTMzArL3JQR0pmMnZPV1gvWWI4TXViNUFtTFh0bDIvNkp0VytrdFM1YUlWZDFIanJpKys2aVJ5TGRIZ1M1eEpLRkxoSXdrUkx5a2hQOGFSY3owaHpOa0VOMUl1aVJmN2tLNU01dFdPMmoxak5STDNMTC80MlgvQjZzbzlMbDRScTRDV0RPRlhJeFVaTENzR0dNc2tpMG1DOGVpQmxOR05paG5CcTFlVEV1VHdRQTFqOGZsOHNxVmNHNFdWcjJhbkJsR0Jxa3pBOVF3RDVidVluS0hnYnQvM2VpWjdVS0NicjJONUJFV3JjQ3NqbUxrZEgwNnpYandOdCtoU3RPT2w4YmM5c0xETy9iUnc2Zm90MlE2OEtsVjhyREhobmR3emFkUmszN1lRTG5Ieng0K2VPS2t0RmdyQ3dSTXMzb2svVXl3Q3MyQzdkS0tKRXVxSXNtdVZRQVNpeGFzU0ZZa2xiaUxwRVpWU1QwdzMydFFXbW1TWHBoSlY5YjNaZlZKcVh1YW1ycW5vWWw3WGxvRlpVWnhka2tsMUFJVWJ6K20xME9SVTJUaXpMTnBhKzBEOXdYbWMrbDk3YW43dWlxUlhXbEJaV2ZhZlhPSUgzUllmZVBsbHRXVDB2cXYxNjByU0Z1eHpvVFBTNWF3UmFmZGZ4RHpnRFJMNXVZbjc1K2Z1RDhtcUpqbG1KckIvQmZvMC9CWFlra3J3SU10YXBwaFJncTZMTzI4TmlXSmt5Yjl3NDNyeFJ3cEozR2F2N2hUT3VEbERYekg5YU00L0xJR2Y0RkdLeTVoM0dXcEJiMEo5bURZQ0s4Y0FZSTFoNGFqWWJNbGhnVXJXQ3J2c3NSWWRZNFo5aldpSXhaVzFvOU9SZFhsQXR2SHlzb0FMaVUwb0hYdFZ5TmlxNWdQOFBjbUZXbTQ5OUl2RVBPdy9mQXFIZjlGc1BjZXdMK1dqYWRhZzhCS3dpNEFOVDlsUnZzeCtoUDFjdVlDR2s5MnF0cXhFRDFKRWpZTHdkeWdiR2RFcjJOSmJpYVFYVzZFT3gvRDZ4Ymk4ZkUyQ3FTMEV4ak5nUXc0dGZvazdhSVVnNDlCakhtcnhOcmFsYnRYMW9xMUtUS2VkK1A0RytGL1pVR2ZzZktJaHg4ZUlZL3RjMzVoZ3FKRlE3QjM3NkNNVDl3bWNRbUMvaHRXaitNV2ZxNUY3SVJnZzBJdzFSV0kyaHdXM0I2YkhzdkNMTW15TUUrbGFqMnFPZ1BKS2kzcnBaVmhYcDZNUXZ4cHVyOWZncmRGTGttUjM0bTNGYWZHSHhXUFhmaWFGbXdpblVqZmt2UnFNUTYzV01Wcit1aGFWdE5YZ1BaWG9vUXJFUXR3dUZnc1FBZ3JGcWRXZDFYTjIyNW9kVmVBUTVkRzMzcXBKRlFxc09xOTE0aHA4dDVCNnJpNnIzajEzcFFmWDE1TTY5ZWZvL3ZFZlRJVzhFMmZlUHFtL2pUK2U1bFY4TzJmZmErUmJwMzBiUTFabnF4UGtMOEJmb1IyMDAxWHE2SnpYSzJLenBrb3BiSFVOS3JHSXNBbzB5cnE2bGNReTJkbjBqSEZtT1NsTUYzLzN3RlRZMWlBZTZiQkVtOTFtbGpvK1hSZzRBd3h4cG1BcFEvQTRybzZmdHhYZzhWemVmeTRHWE5OUjFHUGVsSlcvODN6NnhvQnhoZ3JPOU1jdGdLR0o3ZHd4NVdoUXl2Q0VjU01NYUQzUkd6KzhxRFdXWXlDb1lKNWtJMDhaY3B0aVNYT1FpTXJPTml3V2hMMGlZcGx3SThhZ2cyY2lITWo4ZUpwckwrRC9VVi9iSGtpVjQ1Wk9nYmVvY2ZPdks5aFBhZ3hFWUpST01TV2hLS1daZFpiVDMvVmxuUmtCUFBqV1ZhWkoySk5uN2d2ZGMyMHFqNURzcXJQcURWMmlzaUtubDh6cUZIRHE2UWpQY21zUTd4Y1l2Y1IxbjN3ZEJyMlh3Znl1bHlyQnVEVmZtWmU3UWZYdFdCK2tSNWova1RSWU9XN2lkdzZCTHQ0QWNTampuUk1iSjRHTk80aDRnTGdMbUJ3bTlFT1RXSURuUmNHN3J3d0JwZ1J5RkZUSitsWnN5NEw2MzBoV1dKMUJ2WUJpQmpOQ2tRc0pSNmdhdzBpSFFlUkNyNEYvTmI4TlR0ci9VQXV1QmovekVXWnhuSy9ITWxlUWNaWWxBaFcyVnFCUGVjUUVveWk1Ykc0aWhnSU96Q2ZMaEJ4c0xpS0k4ZFlFYkU1V0ZBRkkwd09Yb05xU0ZRb3M0STZnMlluczhKZnpXa0dPNUJ3aWlGRjlYdEtiSE9DREgxOTZtNzY4WWI0bjhnMTU3QUErQnhtTFlrOVNZYlllUWQ5ZFQrckF4WjcwbU5ZQ1l6K2xtU3QxUWJRTVl6QVllZGNVdjJuNXJMc0J0NDV4Q2tuR1cramFrQy9ka1REb2drRW00UTlNeklMMEQ3VHVjSjZiNE1DUmN3YUxLaFJjMUU5QzF1ZExQTTd2VnhRYWxJcFNTc2lITkdrUHBKZVd0aElIK0d5bk5VYUFxMWpyYUVmZGFrbXFnMExtNm8yTE5JUzRLSldtNUxmakNuY1A3bmVFRFhkcTlRY1ZxRGllN1hDUTJtbXh1Zi9oOWFCeC8wcTZ5RGRtQ1o5dFpXSUN4aWJTS3lqRDF0SDhXWFdVZExVT2tyVDErSC81OWFoYWVOWFdZcWZ5WkIxei8rRXRhVGtDbC9QSUxhZUlPcUtsNnhIYlZNWjlzTlphc25DaVhpVzJqYTF2dXIwOVpVM1hGKzRKUWJVZzZ5bllQN1ZxYS9KbzNTVnhadkxwaldSSG5KVlZLeHRlT1JrRFI4RkdwMldDTE9id2toK3BWb1lEQmNBanl3Q0hsbWFqZzYwYy8wV2xyR0lDalFMdjZhUVZJWi96VWNuWWk1cjBoUE9BQ0dDbFpQV25IK3FJRGdScWJ3S1Vyb3k0ZndUNkNFaHNJa3dVOWdtYjVSUGczd1MzRVlTTXJJb2xKSE1KUDJvK2gra0wrbTNuNnJzaVViSUF0S1A5TnRMNjhqUDlzSjdkUi9waTBuZjJPdnB0RzRhNkw0KzRNMWx3bDJhaFBhd0VMYVJGOUJyNmR0RWJjN1N6ektkTEZ1N0JDUFV6aGh2WU1wTUR5dzhLSEZ1TlhreUREa3NUbU4zYVVXL2hheVBJWlk3NVRucjdGSTJDMkliWEdHVGxmWHNDWlU2T1FaOUliOCt3OGxETmlDbFBUNE0zSW51REliS3NpSDd0ak1Vbm5pNUgybTFienRpY2QxeHRWOVpUN0ZtK0tRLy9PUE0wTWwvT05mVGRQb2RVc2h3T0hiUTUvdnBYeGtXeHcwU2p5MmRJYTRJMEgvRU4xWVI0eHRMWjdEY0k2d0YxVThRSEdCN2RXdXFHdFRiVkRWb1JxSU5wWlAxcHJPNTNCNDhRVTBVaHFKdWZVbHhLREVSeSttdm1pb1JWZmJlUlZmOTErRENLdFU2bTlPRkVHRkdqTHRwdUlEVlhnclh4NXk1TmdHWS9DNlpjTmRaTFYrTHdkWUhZUE1KTnpRRlcyWlRzR1Uxd0ZrVWNPYjFNUkRScWRRVWlCb1h2UVRLVTV4dnJtc1N6QS9TZUNXSHM0RGhNQk45dzQwaHhXUktiNURaMkppYms1VUF1ODRwb1lMdHNhUXZvQzdUYklBUHZmQ2h0NUwxNjhXUW1jZkp5aGhWTC9NU1pMS2MvNmJRclRHQVMxRXU4RFBmOUZvUzUxemtkYTlBRHdiQmduMjRHbGErV3BPVnJ6YXQ4clZPTkpvc2pLbGZXdjZhUTZ5a1FRbHN5V2ZjeGtvVndrcjcrVzZuK2hCZ3Y4cnIwblIzc05xWjlXSURRMGJLNG0xQWpNbnVsWFlBUlhRRUFvbHVKd1lIYTJISnRYcXZQeUNBd1l5OUNGak1GZjBORldRejZVRHNjZEs4UVR1Q1EvVHJrekkySkRoQnpzNGRMck9HQkVSWWRyRmVYcXQ4SWhSaFJ5eW41bFZ3Z2NncnFNUjBNcUlXTXlDS1RLejFYQzVhSzlaWUpGZVArbTh1bG5wbEJ0UmNoK3BGQVdtMXhoZ2J5eTFpTVdaUUk3V1V6QUtRamZEdmVLRUpOcHZEckV1aWw3MGV1WUpVczdaWVpkV0pScFNZTSsvNDdPaDM3VzVzRHdmb2I5OVZMRmp5Nkt5QkkyNjdzZDhZV1hlS25sSnZXZHkzK1YzbjMzdy9waHM1dU44NHh4K3I3N201ejZDcFF5K2NRVHBsZGFlNlZrSzJrQyswRU81TnJ6d3RiRng1MnJ4QjVXa0ZyeFN6c0VveFZubGFvbFdldHRRcXhTSm0zbERHNjhRR04vYk0zTHg4MXZ6M1AxTi95aHlxVjYxQjNZN2VnOGV1VkllcVpNMmtxK29YSjZ0UkcrS2dGSER3aTMraStyYmlzdFczTFJ0VjMzSU01QmVYTlcrQmpNZmpVc3YveTNXNGVKaXVWb3M3bUhIVksxWGtTbTE0M0RPQkJ4bnc0QmRhWWE1aENnOGxqZkZRMFFBUHJSa2VDZ0VQaFJvZW1tdDRxSVEzaFExcHdjUnBvY0JmVXFHaEl2OC9oWXFFMy9tcVZMRlFNN1c3WElrdzVHSnlMWDE5eVpJbWFjTUJPR2tqZEJSZVRzZEpXNDZUUXRUMHlvRURsRHZVVm5pczgrVllHcUxhTjBBVVMrb0tWd0dpcWpSRWhUUkVZUlpYRlNDcURoREZxbEFTbU1vdkxHL1Z0ajNIRkV2RUZNTHRzYVpGeUdCMktBb0FJMnNCWW5kaTJVKzVTMjJENmlJclliblNnV3JhTTM1VlpONlpacHVXemtpOHpMb2lhcnNsTk9mbFplZzhYNTNFc016eHF4elQrRTlyNFlXZnpJSFVuRXExSWhqT0JRSGFNc0M2Z09ZY0RlZGJZblVGK1RrcFB3anlwL3lHL0VtdHdGMXFiZUdOUVBOemtEZ2wxZzYyd2xsbnRHc3Nxdm5sY1h4bHZLS0RKUTJMS1BXYXh1U3pwT0taSk5wQWpiME1WWHJvbDBtYWhMUEtjZ3cxdk9uV01wNFZFRG9MdjAzSFc0dkdlR3VUanJlU3ltZzcvcXBqWmJSQUk4d3VqRERMQUgwNVphQi9SSVBjelYrbW9hNlZocnByQUhYWUJ4K2QvbUF4aElQWUlpeXpScjJHTWJqOGd1S1NGbTNzREg5dC9wUDR3OUlERmhqUUFTN1Q4T2hPQ3c5Y2h1bGxydHk5RXY3M0pwQTZoa2NNbWhRRFZoNURnS2NMOVJweTVhd0dNUVE4KzZmMVhlUmhRb1VRQWd3dkZ5TEZBaTgzWTBuWTBjcUdXSTY0OFVWSE9SYk51YWJZRGVqTzRTbkhFcUtzdWdHYVd3THRJZlphSmdTRUVLN0VtUXVGWlRWWXQxY24rRnRXNFlHL3hoWEpWSUk0WThBb09UWDhhUTJMRzJPd21hK0ordmJTc3FUSUNQRzgyaEplOE40QWdVU2EvdWo3Q3cvYzJ5MjkvUDJUK1gvNTJmRy92ZklwYVRYeWhoV0xDd3lESjl3K1hYeGJLNGRQeCtpeUZlbGw4YmZlOUh4MFk0ZWU0M3RmVjlidnMwUjlmQzFkeTNvbEZDUXFsY09XVksyRHc4cDlhdzVVejNOckxvMXpKSG9qOEFodktzN0IyeU9zL05QTnI3ZWYzamZSSHVHV1Z4YmRUK3MzMXIwdkZzaFlzai8wNXdjNmRYejVIcG0xU0JoOHU0RnVuWFMySFNubis4dDZESURjeC82bWhaZDJHV2lHWFFaeUczUVpLS3JFOU1IR1hRWnlyOUpsZ0FlRHI5aHBZRDBxTG5PdTBHMUFmaHowbHZoMmp0SUdzT2MzQlhzVEhSS2FodjBuZGtoQVZlT3FYUktHY1F2dWNyMFN5QWRNMFVqQUxqUFlTeTZGdlFoaEwyZ0FlMmtsdWtNYXcxNXdGZGlUZ2Vrcm9uNjVGazdwZFFYc1M4OXc1U0N4QVRKZkE4Z3RUanZKbmkxWG9CNjBUSXVDNFN5UVY4VUIxcmdsTTZrNm91T3lOTkd6QlJVaFN5N3JVRlpuOThyTWxWSHFDcnZ5a0Urd3RoQkljODZyMEJ5TEM3T0Zvd1M2M09JM2s0b05pVU9kRDZaZzAyc0htY05XRGp2SW13S3crQWM1eEhMczBtSTFKQzFXWTdwU3JDYUVQb2hxRW1MZGI3UzJCaUxXLzR2clV0ZE1WaFVuWXpXbUs4VnFWcE1RUGNHc1NieGNJcHNQWWQwQVQ3dUEzaHJFYWtoYXJNWjBsVmpOWU0zcU43Sk9ESXdTVXIwWXBJdTc0UG9idERxQ3RGZ051VnlzeHZSUHhtbzZrSXBhRXFwTmxCbndXL1BYekNlQ3RIaEVPYzNtNGt6VHV0RVVLRmpMZ1NMZnhaTFJtUGNNbTRGYkVzM0FXZUN1UE5FSjNHQmlUc1pYSkwzUmJMRm5La2gwYmxmWWFrT2lLeW1BYjdpRnBDdzN1YUk2dlVWTEdtSmR3WDFsK3JKUW1kK0gwMEd3dWdNTDVJdExHOVQzRS8wN3Y1Z2IrWHo2RjR2SXNNb0QwdzV0R0hsTHY4ZFBMbm1lWG5pTVZLNmVNMi9GcXJuelZvbnlFV0s2OXFzUnE0ZXAzUWM4TmVETHBhY1hUOS8vOU9CSC9yRjgrdXJWczZZK3lmeFRyRDhDNk9SdTJNMzdVaDBTY2tSZTl3STJpRnFLS3A1UGpqVnVtOURpTW0wVE1QL2ZqWGp3bE5lZzV5cXE4K1VVbGlJU1RLNXdma0ZOcWhVSW9NNkp4aHZXMTNzdTAxcWg2UUJQdzRZTEh6V3BSMS9TaGtFKzFVQjNUdkwrODNCT0hDeG5vNjhXbmN0TWRHYkkxN0hzR0phZWFtVmRFWE8wemd3c1RVTnpnK1U0bzFhWDRuRXpaUzAvODdJOUdsS0c5Mlg2TkJ4QjBiWHhzcjBhNUNBS3JoR0pqZzBONGM5Tmc3OWhad2wvVTUwbENyWE9FbEdya3NmaU8yZ3JGdnowSGhOTWlsMit6OFJHeGowdTIyMUNMRWlUWCtkMU12TkJGZ2tETmZoekV2RDdkVWszRUU0Z3lPU09mcVBtN01uVThKL3YzR3BGTnlRN2FVYm1oK1NWSmswdm80R3hlNW1kZU9zQ3NDbXdjK2RkZGpPQU1Ma2NhMkkvSExBZXRDWHUxdGJUQXRhVEtmTGhVR3FCUXkzQ0krV1J0VVcyd1VVR3VkRUFpd1E3b1pXMnlMYnd1MHhiWkN0WXBDZW5vRFN4U05UdjJyUklSSG9LTU5KVHlzS2x6cVlvcjhsVGRFVU1iRzd5VUJWY0hoOURHcHl1K013VVdqUVpmeDc0T2o5bnhjbDVDK2tuRGQyNGZ1N0dMUXdrbTVGYVkzVk9iOEtObXpxQWRjVkdORTFaekFlME1RdVA5UG1CZU91c1NtYitWWTlpMHJUVVJvZWhZRytNZ2xPazRyM0Vlc250S05JdnBRR1U1eU5TVk0zbGlDU3NFMmJMODVScVRZNjFGbGpKaHhSTERCdkFJUU5hdDJYNXFHb0lvR2RUTlFYUzVqQVI3YkZPZWk4K2sxVFJnNlJLN00yNlJMUWkxWFMvdEJTZnVmNGF1bmhheVdMOXZURHVNN05CM0VkcmdjTGlQa29xN21OSnhuMGNsbFRjSjBJeTJBU2NFbWZVNU5FQ1B3NndxbXlYQkg0Y2FZRWZteGI0NFJQSWZDRy9UcC9CMFp5TSsramNITk5sb2ZXTEVjblBMYTRoem42MVN4RFJ6endZcXZHVE9kVmQ3MzgyR3VwOC83TiswNDZuanlLZXIrODBaTlRxOXhEVHZXckVWamRjVDE3T3JLTS96Nmo3WmEvcmVmeUM5Y2NBM3VlR2xmZS9iSWVNek10MHlFakdNVHhZZ0FZMGx1RmpSSFBGWmhuSXdSczN6RmlMQ3RpbFhUUGs3N0FiNFg4UG5OakpvODdwNFlFV1VOZ3pyZ1luS25HWE5QWVl4WGp5cFpCS05LbmZhYkRLQUdzMmRtQzdES3c1bDRFMXR3Rk9vNERUekd4dEdzeFZVYXR4NWNaUVQ5UVljWk5nTXdiTXpnQ0RtL1VxUXl0aTFtVWd4NVNzekdEWXEyWFo1S1l0US9VeG5nd0h3MU1aOWxrYXJZeG50SUNGd2NkSGVUaEx6blR5eG1aWHBCZ3RZdFI0WFV0WnNXdVRxMHFXditMY0VPd2hvdWtuN1MvdEl1Sk5kaEhCa0NGcjV1R3UrU25kUkNRZ2tLWTZpb2k4ZnFkaFh4RjVqMFlnV284b2htZC9zb2UwTDlFS01aK1hnNUhLUkU2Skd6dEVlUUpNUGNRb20xbHJDWmJOdWl3NWZKeE4reHk4NTUyU241cHB4RHRNc3ZCU3FqMFV1cXhRS1d5eVE5VFVLV3ZvZG4xQi9Famt4b2VPTDViVG1rUnRYQ0l2M3ZTYit4bWRNSHhxY2loVHVMTXhSaStOSkRxUGNxTGcyVXVBNmJwTVdXbzZmbGhIckFZSGR6ZXpHdmVmc0FzYWNUUzFFNmRZUVBIU25VaFFoeWhNRmdSREsyVTE3RVd1TUVyYkM2c0J4Mnp3bElsc0kzWXppaG90RHB4ZllEUWttNHg1WEd4QnJDRGZ4T3YyTXhOMSsvQnNZOVg3UEtYTWlFM2pCVThxTlNJdFFaZHJoQjBJZHB1YVBIVTN5ZHNnL3lFZUZLZkZIeEdQWGFnNVFYLzlPcm5oNjUydnZQTG1HZkhBS21KNFkwb3FXWEVINmJuLzliOUxJNzdXZENiOWFaQmZ4VUliSVlROXFYQUdBMm9DWHRDUTJEeUc1bG8vVURqQzRkYUozcURWY2l6cXFzcEJyNEJMODIxY3c1WlhBcHBURFd0eDBweDdWS3ZBK0JkWWhJVE5MUXZyODJ2UzJvVXkxZWdTYngvcnVOQkE0MVUwMzhjYVludHUvcEViYnpnMHQ3RVg0SlBGSDkvVTUvaUMxZlRjMHlUNHpOejVLOWZNbmI5S0dweDBoanhOOUUrTnFLMGRrZTRVR0hYYm9ORlBFc01hcmtLb1pjd3BJbWx4NGdJV0ozWWdUdElqeGRnaTJSb0VHeHQ3RWJKV1FqeHNYR2ZSNFpoZ25QUm9yTVE1WFhWVzlnSEtlR3g4cmRlRzBsb3R2TitHZ3cvdWFpcTRuS0RNQmdIbWQ3V2swN1FBODVHMEhKWnA4bHZTSTh3M2tNODZBRWhCWHJKOFNhdGdqZFZQMDZvYUVuNEE0Qy9FSUw4bW50T3RCWjNKQjlZL1ZuN1p1WC9kV3htVkcxUitXYmhYbmJmS1QxUy9vckIwd3VycVpLTko0cWtjNlU3d1VKcmpteGk0aTN1T2xndS9PZW5GSHRIQWQwMkV3ZklXYVFQbzlGNmhTdUNOSUd6WVVjZWh1bEFvU1ArSnBqcURtelpZbTdCUC83Zm1INCs2WXY0eEVicGRqT21tc1JtRDAvbDU1dXErVzB2YUNBc0diQVFmMWZ1c0NMdGVHN2VUY3pTY3pjSE5abjFVc3JFdGZFNDJhN0NDQ2EvWlBJU0M0ei9RRHZSbWc4NnF0enBZT1ljZWk1NFZaNkpJbEVrUW1mVzJMeTF6cys1elJZVjYrTGliL0JvVm9vZU9FeWY5N21TbmV3dEQ3WXEvUGJ0OVB0MGpMeUkrR3FQYlpsNzQ2N2ZuTTZ3a3l4RFpNaU4rVmw2VXlGRmZwWi9KZWh1MWJUU1JKakh6Z3JXekZ4THQ3SmsvUkJHY1dpb0pSeWlLM2MzUzUvR2JLN1JjRGZyeGhVV3BYR2craTJhZEVoSHlrS096S1lkdWc1WXBiSUs5dGpxeVpSeGxvQ1NHWFVUdHZCRUE5aTYwdzgyMnlpYXJ3ODE3eWJxeitWaERCeXFNT05TUXpXdkVzVW9OR2liTHZDK0ZIdUJMTU1EVTVLSTZJazNlOHR2L2VQeURNdkdHZUxUNGd5ZG5SWWUvTloxK3NpODF2bWo2dVBlZWpENU16ei94NnNDQmgrZk54dWxGLzIvTU9QalB6N2o1bjg1Si8xZk4yQkdGbkl0bkRCdmhQdmxDS1ZaYk1xTzB3QmpqalhXUUpNekpLUjJsZVdZa2JSMGZ0bWhLV3FsNDRndnN3TndDbUIyRGZpdW5pYm4zaFhCcFFhSitEazk0WjhuRkZHODg5Z0pPQi9NNlJPUzVpWEZoT1o1Y2IrdHVYVnY0UWFTUXdGbVNRWS9YeHpmU1VjR1p2MWt3UWpHU3JDL256S1F4SXN1WjNlYnRKTG12azNLYVdYL2tyelF1ejU5TTk5TTd2aHROS3ZjT0daM0lnemZnREJ3WDJFbkRPUVl4ZThtdERmVmhVNVdjTnB6cW1zVW55V08zSkc0MnVmaHNKUmNyVmNNV1JXNnNOV2M2c2svTHNjdGxmYzdkbWd4SjhtTE96eGhMWnROSGl2emFBQ2JTODJ0aXBIKzdFRjhiZjFWYVNNcW1URHBCajRPY2pvbStlT3liUDc3L2xUZy92b2prM1RhVTlTWHNKZ2lNTjN2eGJMSWUyK1pnUTY3czhDUzVNdXQveWJ5OGNyTE5ObkxsVkk5dEJOeWlBZTVqQTgyMStUNTZSMkkwUUlvZmE0N2RORWI4QVhIUTNmUHUzbjF2R2dmKytpajFrVEZMSHRmWXI1YS90a3VyVjJwcVdwTWpmVnFUOHdyVG10QnYyWGhpMC8xYWNWS0R1VTJwK3FTU2l6SGxWZjB3bGpzWDRuTjdrVXlUMmxobVpkU3RLYURabFN3L3JpblYzNWl1K29la1VFWUFOWUptcFNWa0JGbE1CcFBhK0h0RFR6NzEvQlB6ZmpaMFF1L290cFpmdHR5V3NaVit1aFhBTW9sbkwyeiszZm9CbjFWT1Y0NzRseTcxUC9IclgrTWNKbnBFR2NSNkdmVGluZW14RVFlT2xUS3pOak5tMW9Vak5ib2p6V1EzY1I4YWluMVo2Ni9aMUhDdkdyRTlxYUhkNkRzNGUwcWVkMzRzUFFMZitoZk5HZVI3UHBqTlR2SUlOMnVhajlVWVMwMkNVenhjODFGaWlUeGFLNjh4MUJya0FwMG1CdU1aZVZhdE5wWFZtRGhWWHUxTUpjK1QzS2YrYXpJUFQ5TW5GK2l2eVZBOFNTK2dtRDZQeDBnN1F2OC9tb0hJOUpyMHVXUnBXbzJ1S2EybXdWd3kxR1M0RG9NMDRRRjZQTWR3NHNFc1hUYXYwRzZNZ1hVUkNFUXNyRjI4eGNZNzlEUDcxR1hrKzJhRGZYT3pFWVl5MTBHUm82QTZDbEpQMVR0VUl5TEpCTjh3VldJREdlYnFjR09ES1l1ZFJSZmR3WFl1WnpYb3FCSldqZnJaL0JhSDU0RmJlc3Z1emVYMFhQMENMLzJZSEJiTDZTQ1M5eFlKazVFYkx5eUtiOGRlU1dJdmFjUmpkTUwvNEp4REY4aVJVOHlHYjYvZDEyd1A4b2s3Y0xjZzcvRHJZSjNzN0V4TU1QMmNOYWF0ay9WV2JaUzZaclFsZUp6ZldVWmM0alh4RTJTMjJJVzBoOGZzK0FreFJKZlFpVHZvN3Rmb0pLbVZPRGsrU2x6TEhpdnFENHU5RDlCRlpQNkIrRGFraVJDTGdVWkFZay9WOG5SUVVHZXhMUU82TnB1S3MzQnFtVFlWV1hjMDdNZHhXcmhKdWFaWXhNNW1qZGdCSTN3Mk10cVlMQ214T0RFeFBFejhOU3hmUEw5R2RUbkRYb3pQWitGb1RhYkYrUk9GYWtuRFcxL1dqZytKVHM2SURtMzhIWEdNZi9EcFgyeFlOMy9SZmVQdi9WMmZEWk9JZCtjbnhIOTYzbVAwNkQvZXAwZU9IZDgycE4vQVc0aHU0TTI5YS92MTNUZHQ3bnNiUHgxVHR2RVhmL2gybGpiRGJzRlZadGhwekZLZk5zT09PVGVOTlh3cWtYekpERHNubjZTM21ZVEUyYVNFN29zdlYxYlhENUEybng4cmJhNGZrSkJqQzBDV0dPR01ETCswZnM1ZGlYM1ltQ2p4TmdWRG9tQUJ5SzhHNTFuVW1lMHV0MVk1Snp0cUxnZVF4R1FPRXpkcHNMbTJ0WncxcytVcm1wUkp3YW52bENaai9vVXpFa0ZYVkNiQXZiS3dRMzVtZ3U2MEl2b3dVVFJsMGFIbHA0T0c2TFN3bUNabXl3UG5aNkVocDRuN1FCdnBoTUFTUEtKTktpcE1Wd0xwTGpyS0YrZzFjY0hBRWVsYTMvbXhvUEQ5bWU3ODhwbmhaZjliNWkzKzYyWjMvanZPV2VRNEdzUm1ZbFUyMUViQ09tT3kreVNYSjB6S2FMWEthVGpaTEc4R1hQd0gya255ZkJCby81dG1OLzV2bjFYOHI1bjN4L1J3WnJPMnVsUUxSeE9BSy81WDFiMmIxTGdicXRsYUxIK1B2a0E1cE9YV1RSYXc5NEFqR000Qkk2a0FiQ0htb1hLN1FQTG5WcW9sb0hrYlVENUhKQ2IvSk5iNWtaY29hbFYycVBOSk9RRXdUOUFyVUJBSUlPdENjOWJzalBHVXZGeDBUZ3NjWm9lQTdkZ0RNc3NBSW5LUjExOWRXTXlhdXdhZGhUckNaV010V1VTNmt3N1BFOHUyTWFPajlOdDFkTmM2K20xME5PbCtaTXVXSStKcld3NGYzaUtlSkU0eWJOR2lZUzkrZXYrU3oxNGErZlRUSTEvNmZPRnpyNG12dmtibDE1NWIrOXEvZE80ZjJDdzZrZDJuWDJvT0xzNWNFS1JVNThCR05vczkxVE8yYVlXd0lYTkROUkNaV3p2U1lWTTVtblVYRnVHQlJvMlAwOUVqc05ZeVpydmZ3TFhVUkIxWjFLNnd2aVYyS2Rsb1FyczUyREFZcFVjVEYrdWdMQkpyVkMwQVJjTUxxMmJpT3ZBb09STmpRY2dqcE9QcEladmFJb3M5L3R6amY3NUhXaTVhNlUzMDg3Yk54WW5BYTMwVHh4eFA4bmZEa0hUK25zQUpPMEtLTVhoNVZDU3I4cHJrNzRTU2pxSkFPaVJRSU04L1A1YnZnVkhIenRIdzFQM0Nlbk1ndVFzMmJSZTBtenV1ZkhNUU5hb1Z0OFFHVzJLclJHVytpWTRnMnJZa1lFcmZtdVQyaU1EZEJKMGxaZk9aR3RoOEF2QmR5V05pOGs3SGJRY3p0L25FUU1UTStzcVlCVzd6T1RTek5tWHo2Uk9PaUlSN0tHRkJkUklmSjFYb0RmcWdQdjRpNlVneTBRMzB1VHlmNUNYZFAvWFBjYjhQcy92MDJFUE1CTlNUSWR6Q0lWVGR3YkE1NGZueGdFeDJwV0QwTlpMSk5nNFlvZzluejJiQTNtVXlqbTFPRFd4UHdKaUFrR2picWZtc3dKcmhyaXJwcjdpM0dwUWtEMkNNRDlGNmRhRHNLdEhnN0tiaE1RRmlBL2pjVGNPSFpINWxvSm9DcUNFd2ZON0thV1VhNjhjelN1dW1EZVpVeEMzeVVHWFVhTWh6VzFuS1A4dGhOeHlOWm5KL05xYXhaeHJRbjYwM1dkMTV6Sjh0NTZVNUlqRUZLbE5ySGF5Nlhhb2o1Wm9NQWF5c2l6cTNHMUtkWXp1OE5UdzY2OGtQaXVOUnNYZlpCeXYrNDdkYkpoT3BiaDNKZkd2SzFEZnBWMC92bzUrOGQzamd3RmVmSUxxSG8wKytOMjc2ekwzMG15ZFgwek83NzVxTk9MMTQycEFGYThrUWlvUVJtajdBZ3E3WkdtS1ovelRzbDRCS3ZRNERZdGlRVEYvTDRCak9jTEFNQW91VFo3RGxnWW9VTVRoOFRGK1NjTWl5eFpkWGs5Q2V3YTR0VGs5YUtpdHlzZ1pGTG5SekZ4V0tzQVY3OG45UG1vZjNrYTVxbUw3MkgxSDZsKzI1dTBUeDNSZldIeHoyMjBuckQ0SlVlM3NUc2ExNW0yNDVlSUJ1MmJPV09MZkVkNGdIZHRMelJIcDcvanR6TGdyY245TmQwM1dzc0xyRURHVmprRWU3UEhEc0xFNUJiMlhEY2hoSnkwZkROZ2RyTkdjQ3p1aGl6WjFZUEJuYjR1SHVtSnpBRmdVV2k4TzNIdXoyak00ZkhJZkJnOGhGQklQNkdFYldkU2ZESGxsUEN1TGlvL1R0Yy9TQTdyN3BwQXZkTStzWG90RHUxS2EvWGpnL0ZpY29TNXVIVENGckp2dy9OdDhUOUQ3UXE0NnhpcTZuaEVndVMrclN4ZFRtbGF4UzFsaVpMQjdsWXdaaE8rcE1KcCt0QXFQZzJJSGVaMlZ4RmJWZHRscWFUY0J1YkwxUENKdU1yZmZoUkF6enBwMHVuSWhoVTQwTzFmQ0dhbktvNWplRXNNSGN1alZoenppQWd0V2Z3bTZxSmM2d2k4MTVhbDZZR0U3b2NuTHAxN2F6RWlyeEtUcDlaeWs1MWF1WmtCNDluNnpQYk41eitJTzFZcCtxK0liekRtZlhrY3Y3alh2OTRRRzNyam8yajM1TzN5UFZUODJZOWZqcTZUTlhpTE52V3ZERXpKa0R1emttbjUwZFBKamZzWDNKemN0MjNUbjFqNnR1STdmOGVkYjY1K2ZjL2VJTHlJdVhhVE44VUQvUFIxODI4emhaNVJnYjVJUEZSZEVNcndXMGRPd2pxazIyWkU1Q0syWjNwSGtHdVJ0T01YRTNuT0xVL05kZWJRQjRoaFBlb2hzdW9jV2pGNDcxVVM1SnFQSFZpUmZMeE1Fdjd0MXk3UGpyOVBqWm5yMXV2UEhNQjEydjY5TDFRN24zaXZzMjkrbjI3ckxudnU4UXJPejRkdWVxaXByRWZEcHBNNndoemYrR3NNdTZsUC9OZEZuLzJ6TEpUMzF5Yi9wRC9VN1dwNDFTeFFUWHNnRStwbW41bFhZbEZpWUdrT3hXNW4rem9uZzBCWGdXdDB2SGJSZmxLRHJkNm14dUJlTkxiaFpmUWxHdWVlRU1tQ0xpVUUySUk3TWJoNmloN3NWYy9XNEZSOU5wWGpoa1Y1MUl3ZzNuUnBOYko3cG1kMmtwTFZ4WlFzL0grMlZzSWJQb0IySWhwYUpsQ1pueTViRDZOK0xmNHlBczBTSldaNzVJZi93M20xVUsvK245YkQ1WFE5OGRhY0ozWjdxYzc2NnFDZDhkZVk1T0l1UElRbElEanp2ZzlWcTZnY1lXMFQyTDZCZmlJcktIdHNKWkovQ29pYzhuMjU0QzhadjNGSE9pb0kxMFdqb3NEd0lKTlVPSUZBcDhKRFdmN1FiOEltbzJGV1lDOXN3YTlvcFpwSy9BcXJudmNxeXhpSjJaTlhiUXc1bUF5a0ZIVng0SzM4S1UrNjZBdSsveW1Qdk9rMVBER2laNFV3STQ3VVFrdUdQeXlEUXJlYVQ3YjIvck1YUms3Y0lGMTk5NmMrZnczWXR2UGZOZzNabU5iLzI0a3g1YXRidER0eDRqcm4yelcyVkZwK212OVJ1eWFjRnZiK3o1NnFOdkpHYzVMbVd6cmRKOWRxU2h6ODZTOHBkWi9obWYzVEt3WGphVEVucVlEcEI3eHhlSUN5OXNFeGZFRnlacUpKYnFUSmY0N01qbGZIWU5ZZml2Kyt6U1lKdjVTc3VaczFxK2tyR05mcm8xSFU0bGhqNjdGZXQvcmVIcEV6YmJMTjFuUnhyNjdFeFg5ZG5obU5HbFlNOU5KcnZwby9UNGNtQTBuY2hidEZOOERsbTNtcDdqdG92dTR2ZnlRcmhYQm1aRmVIa3NFZU9kYkRKdTJLWnB3TGFqUEVKbzBwUmQxSFNBbUxTb2ZXZlJ4WVlwK3JtSFR1Y3R6bXZlcGlyTEljMmcrMmpNMDdyVDhQRTNETkRWNjdLSGJ5TTFuMTdZSm5YWlNuLzQvYXh1bVh5dHlpQzIxbTVOMElTMlZpdHJESnJ3elZsUnd6VmYwVGRuSkxENmpxUWM4QTdXR3oxSTM0WEZCOGtCd1BVSzJwbnNpTTlJelJidDNjZ3Z4MmZJUlUwUzg4dVo1RmhEbEtmNzVab011eUhhRjJBck5ncDRwWVBKaGd2YnlIbzY1TjlpaGlqSENjNHNiT2lIUXdCMXVwUWZ6cFR5dzVrYSsrR1dTWi9TdmZSQnJNdVN1dFR2L0xlZVMvcS9lYlk1QVp0TWtENWhlNVgwMlNGY09BVHpuL2ZaRlVpNzZlL3AyeEpyY2E2TnkvNGZtWUVvNFN4WTNVbXdaZktFNWtKUVdLTGxrN3FDWVQrUVNVV0FHVFVSaWZCWkJLWHdXVlVBbUZTaXYxcStpWFU1d05Pakt3TDdJQU9veDFBZVlLWmJhMjJzTVRaZDgyRS9NUW1FWDdnMStya3RycHBFMVpFM0UvYXQxQm0yc3lvL1YxaG41QjQ5RjI2Z052dmE1WFNJYkhTQjM0bnJFM25MYlNjclJVa2VRdjNnZit6dHNhQ0kxQlRkMTJQdjJSLzJYTCt3a080cHZPLzZQV2RKNk83cDNhL3QyV1hxWEhIanRkMm4zejEzYXBlZVloRlJTT3VPTGNnbVd0dWlJMzJYWHFEbjZaRmdDYjJUUEY0U0pCVmcxRDViUmM1V3YwRG5WajM3OElNdlZBdi9vam1ZeTBBdjFiRjdKSDEreWlVK1A5SlVub0tjZEpiOEJKOGZNczVaNUJyVU5lWGU5VzlJWGJsNnFmblBZWjE5R1IzZXdITWwrQjBOd2FoTk1iTUdTQW9ueUpTakMzUUhuT0dHM1VkWnVGNWlXZjVDV09GRGdiVjBmOXcxemVWWE9wbDArTlhFQ2FROTNmM0VFNzg1S3E0bUt0MjR0UjA1Qmh4OFFhOGRDUjFHZHlaZFppUnd3WTVlQTE5Zll4UmN3ZGVIU3g5R1FtUUlhWjlZdXRUMXdqYU9lLzBpdUYrYXIwOXB3dGRIR3Z2NkxuZnpuKzdyUzRNcGZVdVMyeUlpLzJIMkN0cHZTVitmVm1jYUZ0Qis5M0kvRmMrd1piNCtVeE8rUHFmbXNrcUZXeEsrUG0zY1RWcjcwd0p4d0trOVgzKzRPMzZNWFBOMm43NDMzL2ltMUozbzZNcnRrUzE3cE83eHlIVmQyMStyMlphNklvRE54Q3BLRW40K1R4QWJwM1BTOFFhamtqc0ZYMllqR1c5UG9RNDl4ajVleVNPRTNla3VOUTIrc2dSMGhPOGxnL0R2R25qbEpBUjZBQVB3TEVKSExieGFtdXVsZ3pVWWt6NCtEYndHc0htYWhvMmJJMWNFcUJFd0RRRGhjUU9RYjkyWmZMdGR5MWVWUVRLN2NBZXRDdnIzc2wxZ2J4ZzEvVGlQdWZneXVJc1A5WktNaEl2UHhWTlc1ZXhHTHI2TWhJdlAxY2pGVjUxdzhhVVVtTkl1NGM3MzloM3phQzVkU09iblBqaGt6WjNydHRTdko2YkhWOUFmMTYwK3BrWTZkSmcyL05DUWFlTmYyL0kwclYvekREMy8xSGlHeDR1bmRXdGhEVmlabVBEcjJSUEZpVXpKMEdzVmlvQlZ1ejZCVlY1VzYrRlk5ZkRDUkxOV1dadmp3Y3hrdTVmNzlkellGc2ViaytiWFExbWVVTHVZVnkrbGVBSEtWNWFUa2tQUDB3ZVdYaFRXdlVzL0tGbEpkdnp5cnJ2bkxicnI3bnRRSlh6ejNKTzAvdGxuYVAzVDUzYlJJV0xSZlM5dldnd1BYaThFTkRGSU8xUERVaHlkMmZ0dU5BQWRnaTdOQU14Z0VoZzk2SENPUUtCam4zWURQMHFzNkN5TXZmTzU0MHNJTzh6Y21lZDI4bUhqaEEwa1pMNDh5WjBvQkNrbldaOStmbGpzUXZkdC9Fdy9jdURoSXdPSGt4V0R2dG00QjVqZ0NQcWN1UC9hWHNUVDYvLzZQc0Raa1M5K0k4K0I5VGNYNWdtUk1vSHhsSWhicTM5V0N5dkRGb00yWGd0SDh1SHlsWUFxZ2FKU1hxbVdzZTdRcGJCVk1ucDNTc3VRSVpiaVFLMnlVbnhaaHJ5eGxKZExPK0JiTGJBOVV5bjZsOTJaakNndGhWb2VuTHM2V00xR2J6SzloQlZLb0ZMSk5hNUV4UlVzWDE0Q0RMMEwzY21xMS83eWN1Vk5aWlg2b0sxZ3lCUXNhNk43NWZIdnIxejVQdjBlUys0L2YrMkV5ZXdRdjVMblRxNWdwZmRuNVBHY1gwbWJkYTBhNXRBbnZWMm1wcnhkbDh1aFo1NnZhYXhIQ3ZkL3BYcFVjSjE3TUp6blBPUkpQRmF1YUJTRlhtR0xQU3ZkZzhUVDZHMnBOSG9iUzZNM1d1eXVMTWFURXJGMHV4TTFjd3ZqVDBibUVwUzEyU2xNTjA5azBYdjk2ZVVlWERtL3NPWDVPNThaOG1BdW1VOFg1ajU2ZTkvL3I3bXJqNDNpT3VMNzl1UHVmSGY0ZHUvRFo5LzVJOFlZYy80NDQxMHVoMldFaVlCZ1RKb2lRbDBub2tKTlVnS29LRVV0b3FRcUxpRW9hcU1xc2ZwSEZiZUtVTkxRQ0NHNmV6N1NDamtKaUZoSkZCV0trb2FndEVKcGk2alZncERpRWxMc2RkL01lN3Yzd1lXNGFpc1ZjYjc5c04rK04yOTIzc3k4bWZudFgya09YeGdyS09qSFg5KytlOHY1cmJ2NytuSmYzKzdxNTVtNXYwdW0vSkNRZ2Z3ZlEyQVEzc3lYMHdnQzZPNXVNL2FCMVJ6QnFyY0s3ZmxTdWhobklRc2E2a1dwaExLL29wMlFRcldOU3d4NEFaYUdyU1Q2YnlXRFNkbEdiWnpFNnJGQ1dtMFlpNXloUFo1Wmx2YTJwZVZNQ1dobEk0azNpdkZHaGNISFpRNmRlUGtwcjZvMTFhYnFlMEozYi96YWlpV1hqMjIvK09CZWM5L3l2dDYxcTd5K0JVclg2czI5bWNSZkovYjlZL1MzQjRjQ1VhMjYybC90QzhscVUzYjF0djRYVDY1ZWNXRmJ4NkpFVjdKR2xHUXhsRXoxck5xcy8ycDhFOHF4VVVxQWk3d09TSHRwRlJBWFR4U0JLSEdSQldTNWtzenBVVEpnbjhZS0kyNlJqLytMK2lKelUzWU94d1Z4ekx5Q0UrUnFpZklVS3R0ZWhyWkFSeFprSTZ2V3VYcmxoWW1CVGVibWhXMHd5bmhydytNa2F4OWVkODhyWk9CK3o0amNkT3R0KzNEUW8vQkhVUnA2NXFhOWRYUXRhQkJhSVZlem5sdEJvSEEyNnN4QkU2TnJXcUMxdm1vQmFnNFlzRUJaQ2pZbXdRenk2MkFKd1ZZY0ZBTEZFQVdwbnJGT0t6VnZtbnRMUFRpdXRzVWRPUVJZaVNvUlJRNmRqOSs2RHJxWDQ5WFpLcStZZkg3amhqT3VjNGNyWW82RGg0Z0hVYzlBMmVGVjBkZUs4ZlloSG04ZmRiUXhpSVFLaDV4NGU3azQzcjVRb1VSamZwY29PbU5oeWNad2RUK1B0dzlIdVY3dkdoVTZBOWVGNDFZWUMrcEQ0Sno1K01uVDM3NzAxdXlIOWdIeDFUZkhmZzU2MFNIeVBmdlE0RXZmUGZZNitiUGRjR1BmZDlnN0xJT1BpTTUzRW5KTlFUOHlWUVB5Umo5UHROZDNtd2tVN1hXT2FLL0Q5S2M2RU8ySk9reUtBdEZleDlSZUVPMnduNmpWTWNBTEt4aXJMTmFMS3FxVWlYSldRcVZVZ004K0k0WmR3ZTNRWDc1TVpYZDUvRDBwamIvM3p5dit2dHl6bU9DbGhrcjhpNDVFZDNLZy9kUjJTNExmcXl4ak45SE5BYW1SZU55ZjBPQmtROGZubDRkYjhMVldjakZNbGpwZGk5ME55dFVpdjZ0dG8rOHJBSG1DbFExYURMd1Bma0hnUFRkazdaZnNQekNyNmRhcnRvMkdMSS9YOWt4UzZaVXRqdGYyd0E2MHB3QzRXUkx2aG9uTGtSSS9XNlJaT3lhZUpONFV4RytUanRuZlFBUzN1eCtsM0ZmVXZzaWRkemtSMnhlTDIvZmZvZjFueUEzaWFZWDlLU0xPZmdJN1ZLVzR0a0laYXUxL2NtOUtlazhLMG52eDI3Qnlpd0J5cFYxa0NnTEtlRCttUE85ODhkOTRIaW42bXoyU0t2cVZYMUI3cTQwanN5cDhaem1BNVBDSGVlMHJnVzBnUWh2TFVCR0lHOXFlTnlZU094N3pqVWdxaVUzK1dqcmczekhNTU5Lb0RTVjV5Tzh4VnFPZFlSWkIycXRRYUJyV0lkNDBsQUNEM0hKTUxLV0dRN01XOVhqN2QyejNqWkQ3M3BpUW5xYXQwcFh2Yi9RQm9EL1llZkl1R2FEdHRncnphVEplYURMak5QbHVVWXZ3TGxJYXlHR2tRUXpXRktDQ0dUSTRJVXhWWjlWR0l1ai9Yb3pBOFU1NEpLV082V2RWb21KaFptRndRcGtCalZxTnZaaktGeTRqbTNFN0JTY3FVYktVcUNMUVZQb2owalFtREhHcXFrWmVacjJxMWtIZHBCWThJNG5UUzBZVllHa0VFZU85NUFTQ2VwR0JXQzlhb2d2S1pxQzF3bVNRYTlESjhtazVVRVpQT2tmU2V6aEgyRS9RUnN4cVNrL1dUL1cvMGM5NHhYNjZNMHl1VnBqcjBtNkMvNHhjRVQvQ0dMVzBVSUJNRGNCU2xmZXhUR3hGSDQ4Ri9OVXU1RE92WlpPSlM0YVVqYlZGV2lLN1BrbE1KS2R2eEk1RnBabWpNVkpsZnhvN0dwMjlJS2JZTTJDejdUcm1wWDJUNWFYeGZFVGtIOXA4WG1OUXJBRWR4Z3Z4Qy8xL21Wbko0aGNrMVpSUFdhSGF6OHpxVThLNEpGZUgwdlFmY1k4d2tFRkR6Qm1FTWZEQkxvaWl3bXFRcFQyTWVOMXU4cjRlbUk1RXBxZVRyeVducDhOaGRrQzd2SWFzanJvOXQxK3pKK0RySnZGaC84K1J3MUlQZlNNQ2dQZEszemZLYkxTNy9BdWRxWURjN1dXV2hrT2RRbkw2dWZHWmNmcGZQQ2Z2dDZ6OThJTktweEZCOFBTUy9vSytLckFZS2dOejZ5MmxDaHg1Y0lrVUFzQWxyZUM4MHdyT082MTRyWEUrSTJUTnAyVE5UYklhOUFIblE1KzFaZTU2MWJQS1VXR0JvQWxOUXBmUUo2d1h2aXFjWmRIZ3VRNWcwM1VHeHd3M3Y2VG5RdUJUUjVsWXoxREZseS9xQUV5alZVWitPZnVselhvK0ZvQnIrUmlYUThNT21yakcwTVJyS1hWODdNeW53clorUHMzTzBpcFV3c292WVdkTFZHc0ZQUnRrWjRPcXRaR2VyY0V6NjBFSUc0TVk5SUFtUTYzWFpXbDZIT3BZQkRzcFN6UlQ3YlUyRHRLSlg3ZUtoU3d3RTRlWnZJc2p4Q0NsZFVaSXlmMXN5VDNsRHZlMnZEbjIvR240UENmWFROK2FPclpoeGNxMThCSEhuQnNYM0V2R2JaZmtyUHl6OTgrUHlXUHYvMjdtRVF4SDd4dmMrZGg2ZWNQT2JSdG1rKzY5Ri9EaTRNNXZiUEJWdUFiOHVGbllKSTRoSm0yekFGVVlnTnBLUVBCQklWMGRlUUpOYTVtUm9oVDN2Z2p1SG5uN1lkcldLNlZ0d2F2UG1pdTBSYUN0YkRudTdXUXh3aTJaZTN3dWkzWEFxV2p4VWoxc1ZEcEp3alAzdnVPNStGa2JQdXZSdVN2S0hpVkg3YU5EQXBZSHRoYjZwbkpCREVYelRlVUZrZ3BTem1vd09KeTYyVVJGa0JldjFScDVIN3NHMVZ1NlVGSW0xYWxjVXNZU0FrMVVjWTdyT1JsREhHUlFvNzA2N3Vra0ladXNxaE1FZ3dDeFRWQWFuRDZMSnhkVFZYcHhabG0ySllOK08yb0k0eVljV1ByVUxvN1RyOEptM0tLMlI4ZEVjZXowUFdUNVIwK2MrVUhmdFpYZi84cjRBK1FKZTBnVXlWSDc0S1l6bS9ldS85UERWMzk1Mlo1Y1NTYk9SZE05ZFdmUHo2emJ0U24vd0pkUG5JMGI2ZWk1aWZzZk92S2owZGtQMmZvZ3RTaTlHRmNmaGFySnFPeFZCUTBqNzBHcFl2bXFkWjFuWGVJRkYyYytnTE9NSVFtZUR6Z3djdVdOUEZOQkFaR1BNakVleFZXRkF5dGo4RUlJWktVZlN5c0xIZ2lTUTdFSmFNa3RXZ3MxdDQwa01laUIxQ0pwR2RFMzhTdzUvOU1qUjM3eTlQSGdjU1U1TW1MN3lFM2JKKzRGdHByOUlTVUMxSWdZNHZFejhvQThRUGtndzNGNENSdEQwYkdEZEMyaDFPUmZYRU1EaUYxbzRCYkhtdTJuN1YxUkx0UDFvNDdhdlB0NWJuUEN5Q1ZCaFNVaGc2RkxDRHFzS0g3RGludkJUTFNxNkxXNGFnVjVUWVVvbWw4UnRMMmRoR2VOWlMyVzVqd25DTEFaMWpDbzFkRnpCR1dOTEcvUUNZZWlQQU14Z3JDcDEwQ01XRXRSVmJmK0o0ZUhYaDdadW43dHQyWUFSdklTV1FmdUNxbWZDUGZtaG9jYWJUdXh0OE9HWFZUeVZMRUhROFF4WHVKajNNTkhXR09ZNFc2d2hrTjBKRVNIaGNhcnNCeXBlUThHNWhsTVRuQmkxN2pEWUs1U1AwU3Q1S3FnQWtQdm5RWldOcWdyRlFjMGMxcTU4TThVK24vcFdMdzNjQ3dkUXJkZ0NHL3orZ0NwcFlhUjY2RnpOazVDOGRaRmNaeTJuRkRUcHVzd09NQ0FvdU96R3Jyb0tWM2NPcjFUbHY4dWV0eXA0bHcyNmJpVk8rK2h0eE5BRXJGU2ZuQXE1MUx0Y0MvVlZnVnlKZGVlZ3JQMkducVdVcUhHdmRtcFd3Yjl6YlNPbThEdERxbXNwVkIwdkdIaEhlYSsrZC9oaUI4ZkdCNDZzbi9yK2pXN09ZTU0yS2ZJOGtvTWNtZU80ZStGOTVwTDUxTU9sVHNONEJ1Z3EyRWc3K1JJdkxXRXhHYURqbUYvNWwyR1M5bWwveFBLUXVXUGJzcCtQU1UwN1hScGlxV0xySzcwNXpOZzgzelpzb3l5VitaSFZaZHQvd1gyS2E4MmVOcGpZR1JnWUdCa2NEclgvak0wbnQvbUs0TThCd01Jbkx1eCt6R00vcC8vYng1blAzc3BVQjBIQXhOSUZBQ29uZzlmQUhqYVkyQmtZR0M5L204SFF5Zm42Ly81LytkdzlqTUFSWkFCb3c4QXhDTUlBQUFBQUhqYWJWUk5TSlJSRkQxKzMzdnYrd3h4SVVNUW9yYklVRnpJRUNJeTJGQ2Fta1ZsaU1nd2hJZ01JUXdhTmFCa2lZaUVEQ0Z1REd2VER3WEpFQkl0UkZvRm1zWkEwRVlpSk1URkVGcFFFaEVHMDduUHNVUmNITTZkTy9lK2Q5ODk5MzdPSmhwOUFBSW5SdHpEbEtwQVFrK2pSVmNoWXRZUTFaTm9jczRpNFU1Z2tPaHcrM0ZWbHlKSlg0M2JnQmg1V05WbjMrb1Y5TGxkQ0twdDlLaGZ1S0JIRWRhSDBLblBvVTl0SVVrN1N2dTZjd1hqUkZqT0lHYUlWeXFDU204RmNkT0dvRjVFU21kb255SkhpVEJTNWd4L0I1Qnlaakd2UmxIQ3UxSThNMlcrRTIxRUduSGRtZU1sNXBTaVZWZWp5UlJneWdCQi96ZnE5U2ZlT1k4aitqbEczRG5Nc09aMThxQUNZaXFkL1VOZVU2K1pGME5TVGFLREhGRVp2cmVRZVdKdjg4MjltSFI2czE4WUovWjliNXF4OU91TE5qNHBjVzRuZllxOWFVT0kvNDJxTkNyTk92dVNRclhZYWdReGR3TTlUaHFiNUM0Vm9MM2IrNmZvMHNkeFU3OUJqeDVDU2Q0aUx1dENYR050RStZSjRtNHAvUlZvNS9zZVN1L0ZKLys1S3hpbjd5NXQ3Q0N2U2h2V01ZY1dxdy93US96TWIyZCs5Lzg0SW9MejB2ZUQ0RWRSSkZwWUhmYkFtYzFtUkF2eXN0am1OaTd0NnJBZnJDdEJqbG90OXNCcTBVMGRmN0pPOXYwZ2VBL0kxRUowMkF0cXNDejlKejhqRnFoMXh6OGQ5cU1VajhtMVZvdTlvQlpXYTdJL2piamZ3RmpXeEo2dzMzaytPU0p2NVl5ZFZqSlRxL1l0cmJsM1oyUU8vYThvOWpkMlltUW05V2VVRzJWbk1xaGY4amRuV1hKTkJRSnlsci9GZm9aUWE2cm9JeVRISEVheG5lTkFybi9NbDFtMmZlY015NW5lRGRiRytUVW42UCtBaVh3ZnFmeGFlMCs5bDZLdjE5WVg4c2ZJUzJpMGN4emliS1NSZE4reEx4VW9rcjU1UjZsM05jcDFnRDVDclpNTFlMU3cydW1mN1dOdUJ6akhaZElmcjQ3enovblZ4K2ovaUxnM2dLVDNpSEZCbEprWDlJMFEwNnh2eTU1WmFYWGFocEs3NlpkemFuSzdzeUQ3NDRWaHZGcTdPMHBxc0h2QmU2VlhrdVBPQTE2Qzg1cGpad2pJV3lWTzdnRGZ5TGZJdll6aEh1eEMxU0htVmR0dlVvSUl5emRLdFNGQmhJa2F0NWs3MUk4UmF2dmV6R0ZZenNqZlFOVFpSanZSN2E1aysrUWV1MzlqekcybVBjRDlKL3c3Q0NQOEYvcHlQRWw0Mm1OZ1lOQ0J3amlHTnNZOHhtZE1YY3dpekZiTUNjd2R6RWRZT0ZoTVdFSllLbGc2V082d01yRUdzQzVpZmNibXdMYU43UTU3RnZzRERnR09BSTQwamk2T0JaeE1uRmU0MkxpeXVIWngvZUcyNE03amZzQWp3V1BHazhXemdPY1lMeHV2RSs4YzNrZDhmbnpMK0NYNHZmZzcrTmZ4ZnhIUUVJZ1FhQlBZSm5CTTRKZWdncUNGWUpqZ0dTRTlvUnFoZThJbXdpM0N2MFNjUlBKRWxvamNFUGtpR2lPNlFQU1RXSURZT3JGbjRpbml1eVFZSk5Ra01pUm1TVnlSWkpLTWs2eVN2Q1lsQklRdVVuK2tVNlJmeVFUSWxNZ0t5TnJJUHBQTGt1dVQyeUYzUTM2Sy9CWUZKb1VBaFdVS2Z4UmxGRk1VWnludVVieWxaS0EwUVdtYk1vOXlrdklPRlJtVk1KVkpLcGRValZRbnFmNVRDMUdicC9aQ1hVKzlSdjJHQnBPR25rYWN4anhORnMwS3pUdGFEbG9ydEEyME4yaGYwZ25RbWFQelN0ZE9kNG51QXowdHZVbjZJdm96REpRTUxobm1HU2tZSFRFV01NNHpQbU9pWjdMTzVJWXBpNm1KYVlucEc3TWNzelBtT3VaVExCUXNabGljcy9TeW5HZjV4U3JBYW84MWkzV0s5U2tiUFpzZHRrSzJKcloxdG52c0pPd2E3TGJZUzloMzJhK3dmK0VnNDlEaDhNelJ3YkhPOFpRVGg1T1ZVNGZURzJjaDV3TG5OYzdmWERKY2xyajhjVFZ5clhQZDUvck5MY0N0eXUyQXU0QzdrM3VWK3djUEZZODBqM1Vlenp4TlBGczhiM2pKZURWNWZmQjI4OTdqNCtXenh1ZVNyNGx2bCs4VlB5ZS9PcjlyL2p6K1B2NWQvb2NDUkFMc0F1WUV2QXFVQ1F3TGZCTWtGNVFRdENUb1RyQldjRVh3cVJDZWtMeVFLNkZhb2F2Q2xNTEN3bmFGVzRTbmhDOEp2eFhoRURFbmtpSFNMbkpTNUpISUwxRXFPS0JSbEVPVVgxUkdWRlBVdXFoYjBTelJFZEZyWWhoaWpHSW14ZXlKK1JIekkvWldIRU9jV3B3WkVPNkoxNG9QaWorU29KVndMN0VOQUc1dDNJWUFBQUVBQUFGTkFGZ0FCd0FBQUFBQUFnQUJBQUlBRmdBQUFRQUJWZ0FBQUFCNDJwMlFPMC9EUUJDRTV4SVRoWTVJaUZkMUZRSUpJaHNrSkVKRlFBUm9pQkRDdFY4aFNINGd4MEZ5NVQ5SEFTMDlCUVcvQStiT2g1V0NDbHUzKyszTTd0M1pBSHA0aDRCNkZtTkw1NXJibW1xMnNONXdoM21EcnJDV1diMWcwN0JnMTRmaEZwMVB3KzBGdHZqKzhoSzI4R1c0dzRsdncxME1oREM4Z2xWeFlyaUhycmd4L0lvMTRScCtneTJTYXBRVlV5K1I0enlUd3l3T3BSdjVreXd0S3B3aHd4Tks1SGpFQTZZb0lMR0RBTHZNQjdEMUszRkhKMksrWkhlRUNXTEdYT3NscDVWelFXZU9GQ0gxRW50VXJsZ0Y2R3NPNGNQN1kzNWJUK2E2aXJDUGEvb3BhY1k1aVZQMnhjeTN6ZDFtdWxLK21uaG1ETm5aUjZYWHZWWm43RmE3U0RoVTFmMGRldi8vZ2hIMWd0TWVFbXBqdWhtR1hERTdYVTc2M0UyZFZ6UW5xclBtck03cEJsbzkxdEhHZ091STBlRy9yZit2ZzhNZmFXZFQvSGphYlpOVmJCeFhHRWJQbHhoaWg1bVplUWQySUd6YW9NUE1Ua3liT0xaalo1TTRVR1pTcTBwOWExVjZhYXN5cWlpVkdWUlFXNmw5THFzUGJWL2JUWGI4NzB0SEduM2Z6T3FlODkrckhmcHcrZnEzbERuOHo2WDYvTjFIZmVsTENhV1VVVTQvS3Fpa1B3TVl5Q0FHTTRTaERHTTRJeGpKS0VZemhyR01ZendUbU1na0pqT0ZxVXhqT2pPWXlTeG01ejF6bWNkOEZyQ1FSU3dtaFlPTGgwK2FnSkNJbUNVc1pSbkxXY0ZLVmxGRk5UWFVVa2VHMWF4aExldFl6d2JxMmNnbU5yT0ZyV3hqT3p2WXlTNTJzNGU5N0dNL0J6aklJUTdUb0JJZTRqcXU1elh1NFNkdTRBNXU1VjRlNFdHVmNndmZjeTEzcTB6bDNLNSszTVJiL0tnSzd1TlIvdVl2L3VGQkh1Y0QzdU1Kam5DVU8ybmtJNXA0bncvNWpJLzVoRS81bVdhKzVITys0RWxhK0pPNytJYXYrSnBXZnVWM2J1WVlXWTV6Z2piYXVaOE9UdEpKRjkza09NVnB6dkFMWnpsSEQrZTV5QVZlNGdHdTVBcXU0bXArNHc5ZTVpbWU1aFcrNVFlK1U2WDZhNEFHYXBBR2E0aUdhcGlHYTRSR2FwUkdhNHpHYXB6R2E0SW1hcEltYTRxbWFwcW1hNFptYXBabWE0N21hcDdtYTRFV2FwRVdLeVZIcmp6NVNpdFFxRWl4bG1pcGxtbTVWbWlsVnFsSzFhcFJyZXFVMFdxdDBWcXQwM3B0VUwwMmFwTTJhNHUyYXB1MmE0ZDJhcGQyYTQvMmFwLzI2NEFPNnBBT3EwRkhkRlNOYWxLeld0U3FySTdwdU5wMFF1M3FVS2RPcWt2ZE9xVWN6L0FzTC9BaWIvTWN6L01PMS9BbU4vS1lUdk11ci9NR3IrcU16bktiZW5STzUzVkJGOHRhMm5vNlc1M3lYSHMybFVyVkZySXFsV1R5WE8wbTZTV1pUakt1YUdqT1pwMVV5dlY2VzlxeDVsb3IvdXBiUzFzTHJJWFdJbXZtQ0ZMV3pCSDBPaHpmZUk1UkhLTTR4VW1ONGhyRnRVbGRtODgxbm12enVVWjJqZXdhMlRPeVoyVFB5SjZkZ1djT3p4eWVPVHh6ZU9id3pPR2J3emVIYnc3ZkhMNDVpdWZpbThNM2gyOE92M2pPdGlLd0ZZR3RDR3hGWUN0Q215cTBXVUtiSmJSWlFpT0hSZzZOSEJvNU5ISms1TWoyRzVrak1rZGtqc2dja1RraWMwVG1pTXdSbXlNMlIyeU8yQnl4T1dKenhPYUlpL3NvVW5vZCtXN05zV2IvM1pSbnpiZVd0aFpZQzYxRjFzemhtS000YzdxNHQralNOK3ZtUC9Ja25TVGRKTDBrL1NUVFNRWkpoa24yY3VJa3F3cnBKRnpIcVd6T3R1UzZtaG9idWxzTHI5eE1JZE9aa3JwY1Y4ZmxoM1NtNWxKbXFndHo1Tk5OMGt2Uy93OHJuYlA4QUhqYVBjeXREc0l3RkliaGRtVmQ5Ly9ETEVuUlRVZ1FTNEE1d2lhWUlhZzFRV1B3YUF3U3J1VU1SYmc1T0lGUzl6MmZlSi8wZlFWNkl4MklYVDlRZXRkRHkxVS9oVXgzVU81eFhQUUV1RHIwQkpoc2dLa04rTEo1RVVZRmNkVFhRallQLzJqZ0ljVFdnQ084eXNCRjhKbkJDT0hLSHlnRXBoemlHOHdkTmJEMmpJeVFZV1VaSTZPVFpZS00xNVlwTXFrdE0yUzZzc3lSMmRLeVFPWUx5ekd5VUg5cUtOVUhrOGxOL1FBQUFWS3pDMlFBQUE9PSkgZm9ybWF0KCJ3b2ZmIik7Zm9udC13ZWlnaHQ6NzAwO2ZvbnQtc3R5bGU6bm9ybWFsfS5mZi1nb3RoYW17Zm9udC1mYW1pbHk6R290aGFtUHJvLEFyaWFsLHNhbnMtc2VyaWZ9LyohIG5vcm1hbGl6ZS5jc3MgdjMuMC4xIHwgTUlUIExpY2Vuc2UgfCBnaXQuaW8vbm9ybWFsaXplICovaHRtbHtmb250LWZhbWlseTpzYW5zLXNlcmlmOy1tcy10ZXh0LXNpemUtYWRqdXN0OjEwMCU7LXdlYmtpdC10ZXh0LXNpemUtYWRqdXN0OjEwMCV9Ym9keXttYXJnaW46MH1hcnRpY2xlLGFzaWRlLGRldGFpbHMsZmlnY2FwdGlvbixmaWd1cmUsZm9vdGVyLGhlYWRlcixoZ3JvdXAsbWFpbixuYXYsc2VjdGlvbixzdW1tYXJ5e2Rpc3BsYXk6YmxvY2t9YXVkaW8sY2FudmFzLHByb2dyZXNzLHZpZGVve2Rpc3BsYXk6aW5saW5lLWJsb2NrO3ZlcnRpY2FsLWFsaWduOmJhc2VsaW5lfWF1ZGlvOm5vdChbY29udHJvbHNdKXtkaXNwbGF5Om5vbmU7aGVpZ2h0OjB9W2hpZGRlbl0sdGVtcGxhdGV7ZGlzcGxheTpub25lfWF7YmFja2dyb3VuZDowIDB9YTphY3RpdmUsYTpob3ZlcntvdXRsaW5lOjB9YWJiclt0aXRsZV17Ym9yZGVyLWJvdHRvbToxcHggZG90dGVkfWIsc3Ryb25ne2ZvbnQtd2VpZ2h0OjcwMH1kZm57Zm9udC1zdHlsZTppdGFsaWN9aDF7Zm9udC1zaXplOjJlbTttYXJnaW46LjY3ZW0gMH1tYXJre2JhY2tncm91bmQ6I2ZmMDtjb2xvcjojMDAwfXNtYWxse2ZvbnQtc2l6ZTo4MCV9c3ViLHN1cHtmb250LXNpemU6NzUlO2xpbmUtaGVpZ2h0OjA7cG9zaXRpb246cmVsYXRpdmU7dmVydGljYWwtYWxpZ246YmFzZWxpbmV9c3Vwe3RvcDotLjVlbX1zdWJ7Ym90dG9tOi0uMjVlbX1pbWd7Ym9yZGVyOjB9c3ZnOm5vdCg6cm9vdCl7b3ZlcmZsb3c6aGlkZGVufWZpZ3VyZXttYXJnaW46MWVtIDQwcHh9aHJ7Ym94LXNpemluZzpjb250ZW50LWJveDtoZWlnaHQ6MH1wcmV7b3ZlcmZsb3c6YXV0b31jb2RlLGtiZCxwcmUsc2FtcHtmb250LWZhbWlseTptb25vc3BhY2UsbW9ub3NwYWNlO2ZvbnQtc2l6ZToxZW19YnV0dG9uLGlucHV0LG9wdGdyb3VwLHNlbGVjdCx0ZXh0YXJlYXtjb2xvcjppbmhlcml0O2ZvbnQ6aW5oZXJpdDttYXJnaW46MH1idXR0b257b3ZlcmZsb3c6dmlzaWJsZX1idXR0b24sc2VsZWN0e3RleHQtdHJhbnNmb3JtOm5vbmV9YnV0dG9uLGh0bWwgaW5wdXRbdHlwZT1idXR0b25dLGlucHV0W3R5cGU9cmVzZXRdLGlucHV0W3R5cGU9c3VibWl0XXstd2Via2l0LWFwcGVhcmFuY2U6YnV0dG9uO2N1cnNvcjpwb2ludGVyfWJ1dHRvbltkaXNhYmxlZF0saHRtbCBpbnB1dFtkaXNhYmxlZF17Y3Vyc29yOmRlZmF1bHR9YnV0dG9uOjotbW96LWZvY3VzLWlubmVyLGlucHV0OjotbW96LWZvY3VzLWlubmVye2JvcmRlcjowO3BhZGRpbmc6MH1pbnB1dHtsaW5lLWhlaWdodDpub3JtYWx9aW5wdXRbdHlwZT1jaGVja2JveF0saW5wdXRbdHlwZT1yYWRpb117Ym94LXNpemluZzpib3JkZXItYm94O3BhZGRpbmc6MH1pbnB1dFt0eXBlPW51bWJlcl06Oi13ZWJraXQtaW5uZXItc3Bpbi1idXR0b24saW5wdXRbdHlwZT1udW1iZXJdOjotd2Via2l0LW91dGVyLXNwaW4tYnV0dG9ue2hlaWdodDphdXRvfWlucHV0W3R5cGU9c2VhcmNoXXstd2Via2l0LWFwcGVhcmFuY2U6dGV4dGZpZWxkO2JveC1zaXppbmc6Y29udGVudC1ib3h9aW5wdXRbdHlwZT1zZWFyY2hdOjotd2Via2l0LXNlYXJjaC1jYW5jZWwtYnV0dG9uLGlucHV0W3R5cGU9c2VhcmNoXTo6LXdlYmtpdC1zZWFyY2gtZGVjb3JhdGlvbnstd2Via2l0LWFwcGVhcmFuY2U6bm9uZX1maWVsZHNldHtib3JkZXI6MXB4IHNvbGlkIHNpbHZlcjttYXJnaW46MCAycHg7cGFkZGluZzouMzVlbSAuNjI1ZW0gLjc1ZW19bGVnZW5ke2JvcmRlcjowO3BhZGRpbmc6MH10ZXh0YXJlYXtvdmVyZmxvdzphdXRvfW9wdGdyb3Vwe2ZvbnQtd2VpZ2h0OjcwMH10YWJsZXtib3JkZXItY29sbGFwc2U6Y29sbGFwc2U7Ym9yZGVyLXNwYWNpbmc6MH10ZCx0aHtwYWRkaW5nOjB9Kntib3gtc2l6aW5nOmJvcmRlci1ib3h9OmFmdGVyLDpiZWZvcmV7Ym94LXNpemluZzpib3JkZXItYm94fWh0bWx7aGVpZ2h0OjEwMCU7Zm9udC1zaXplOjEwcHg7LXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOnRyYW5zcGFyZW50fWJvZHl7cG9zaXRpb246cmVsYXRpdmU7Zm9udC1mYW1pbHk6R290aGFtUHJvLEFyaWFsLHNhbnMtc2VyaWY7Zm9udC1zaXplOjE0cHg7bGluZS1oZWlnaHQ6MS41NzE0Mjg1Nztjb2xvcjojMzMzO2JhY2tncm91bmQ6MCAwO292ZXJmbG93LXk6aGlkZGVufWJ1dHRvbixpbnB1dCxzZWxlY3QsdGV4dGFyZWF7Zm9udC1mYW1pbHk6aW5oZXJpdDtmb250LXNpemU6aW5oZXJpdDtsaW5lLWhlaWdodDppbmhlcml0O291dGxpbmU6MDtib3JkZXItcmFkaXVzOjA7Ym94LXNoYWRvdzpub25lfWF7Y29sb3I6IzM2YmE1Mzt0ZXh0LWRlY29yYXRpb246dW5kZXJsaW5lO291dGxpbmU6MH1hOmhvdmVye2NvbG9yOiMyNTdmMzk7dGV4dC1kZWNvcmF0aW9uOnVuZGVybGluZX1maWd1cmV7bWFyZ2luOjB9aW1ne3ZlcnRpY2FsLWFsaWduOm1pZGRsZTttYXgtd2lkdGg6MTAwJX1ocnttYXJnaW4tdG9wOjEuNTcxNDI4NTc7bWFyZ2luLWJvdHRvbToxLjU3MTQyODU3O2JvcmRlcjowO2JvcmRlci10b3A6MXB4IHNvbGlkICNlZWV9LnNyLW9ubHl7cG9zaXRpb246YWJzb2x1dGU7d2lkdGg6MXB4O2hlaWdodDoxcHg7bWFyZ2luOi0xcHg7cGFkZGluZzowO292ZXJmbG93OmhpZGRlbjtjbGlwOnJlY3QoMCwwLDAsMCk7Ym9yZGVyOjB9LnNyLW9ubHktZm9jdXNhYmxlOmFjdGl2ZSwuc3Itb25seS1mb2N1c2FibGU6Zm9jdXN7cG9zaXRpb246c3RhdGljO3dpZHRoOmF1dG87aGVpZ2h0OmF1dG87bWFyZ2luOjA7b3ZlcmZsb3c6dmlzaWJsZTtjbGlwOmF1dG99cHttYXJnaW46MCAwIC43ODU3MTQyOX0udGV4dC1sZWZ0e3RleHQtYWxpZ246bGVmdCFpbXBvcnRhbnR9LnRleHQtcmlnaHR7dGV4dC1hbGlnbjpyaWdodCFpbXBvcnRhbnR9LnRleHQtY2VudGVye3RleHQtYWxpZ246Y2VudGVyIWltcG9ydGFudH0udGV4dC1qdXN0aWZ5e3RleHQtYWxpZ246anVzdGlmeSFpbXBvcnRhbnR9LnRleHQtbm93cmFwe3doaXRlLXNwYWNlOm5vd3JhcCFpbXBvcnRhbnR9LnRleHQtbG93ZXJjYXNle3RleHQtdHJhbnNmb3JtOmxvd2VyY2FzZSFpbXBvcnRhbnR9LnRleHQtdXBwZXJjYXNle3RleHQtdHJhbnNmb3JtOnVwcGVyY2FzZSFpbXBvcnRhbnR9LnRleHQtY2FwaXRhbGl6ZXt0ZXh0LXRyYW5zZm9ybTpjYXBpdGFsaXplIWltcG9ydGFudH0udGV4dC1tdXRlZHtjb2xvcjojNzc3IWltcG9ydGFudH1vbCx1bHttYXJnaW4tdG9wOjA7bWFyZ2luLWJvdHRvbTouNzg1NzE0Mjl9b2wgb2wsb2wgdWwsdWwgb2wsdWwgdWx7bWFyZ2luLWJvdHRvbTowfWNvZGUsa2JkLHByZSxzYW1we2ZvbnQtZmFtaWx5Ok1lbmxvLE1vbmFjbyxDb25zb2xhcywiQ291cmllciBOZXciLG1vbm9zcGFjZX1jb2Rle3BhZGRpbmc6MnB4IDRweDtmb250LXNpemU6OTAlO2NvbG9yOiNjNzI1NGU7YmFja2dyb3VuZC1jb2xvcjojZjlmMmY0fWtiZHtwYWRkaW5nOjJweCA0cHg7Zm9udC1zaXplOjkwJTtjb2xvcjojZmZmO2JhY2tncm91bmQtY29sb3I6IzMzMztib3gtc2hhZG93Omluc2V0IDAgLTFweCAwIHJnYmEoMCwwLDAsLjI1KX1rYmQga2Jke3BhZGRpbmc6MDtmb250LXNpemU6MTAwJTtib3gtc2hhZG93Om5vbmV9cHJle2Rpc3BsYXk6YmxvY2s7cGFkZGluZzouMjg1NzE0Mjk7bWFyZ2luOjAgMCAuNzg1NzE0Mjk7Zm9udC1zaXplOjEzcHg7bGluZS1oZWlnaHQ6MjJweDt3b3JkLWJyZWFrOmJyZWFrLWFsbDt3b3JkLXdyYXA6YnJlYWstd29yZDtjb2xvcjojMzMzO2JhY2tncm91bmQtY29sb3I6I2Y1ZjVmNTtib3JkZXI6MXB4IHNvbGlkICNjY2N9cHJlIGNvZGV7cGFkZGluZzowO2ZvbnQtc2l6ZTppbmhlcml0O2NvbG9yOmluaGVyaXQ7d2hpdGUtc3BhY2U6cHJlLXdyYXA7YmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudDtib3JkZXItcmFkaXVzOjB9LnByZS1zY3JvbGxhYmxle21heC1oZWlnaHQ6MzQwcHg7b3ZlcmZsb3cteTpzY3JvbGx9Zm9ybXttYXJnaW46MH1maWVsZHNldHtwYWRkaW5nOjA7bWFyZ2luOjA7Ym9yZGVyOjA7bWluLXdpZHRoOjB9bGVnZW5ke2Rpc3BsYXk6YmxvY2s7d2lkdGg6MTAwJTtwYWRkaW5nOjA7bWFyZ2luLWJvdHRvbToxLjU3MTQyODU3O2ZvbnQtc2l6ZToyMXB4O2xpbmUtaGVpZ2h0OmluaGVyaXQ7Ym9yZGVyOjB9bGFiZWx7ZGlzcGxheTppbmxpbmUtYmxvY2s7bWF4LXdpZHRoOjEwMCU7bWFyZ2luLWJvdHRvbTo1cHg7Zm9udC13ZWlnaHQ6NzAwfWlucHV0W3R5cGU9c2VhcmNoXXtib3gtc2l6aW5nOmJvcmRlci1ib3h9aW5wdXRbdHlwZT1jaGVja2JveF0saW5wdXRbdHlwZT1yYWRpb117bWFyZ2luOjRweCAwIDA7bGluZS1oZWlnaHQ6bm9ybWFsfWlucHV0W3R5cGU9ZmlsZV17ZGlzcGxheTpibG9ja31pbnB1dFt0eXBlPXJhbmdlXXtkaXNwbGF5OmJsb2NrO3dpZHRoOjEwMCV9c2VsZWN0W211bHRpcGxlXSxzZWxlY3Rbc2l6ZV17aGVpZ2h0OmF1dG99aW5wdXRbdHlwZT1jaGVja2JveF06Zm9jdXMsaW5wdXRbdHlwZT1maWxlXTpmb2N1cyxpbnB1dFt0eXBlPXJhZGlvXTpmb2N1c3tvdXRsaW5lOnRoaW4gZG90dGVkO291dGxpbmU6NXB4IGF1dG8gLXdlYmtpdC1mb2N1cy1yaW5nLWNvbG9yO291dGxpbmUtb2Zmc2V0Oi0ycHh9LmZvcm0tY29udHJvbHtkaXNwbGF5OmJsb2NrO3dpZHRoOjEwMCU7aGVpZ2h0OjQwcHg7cGFkZGluZzo2cHggMTVweCA0cHg7Zm9udC1zaXplOjE0cHg7bGluZS1oZWlnaHQ6MjJweDtjb2xvcjojMzMzO2JhY2tncm91bmQ6I2ZmZjtib3JkZXI6MXB4IHNvbGlkICNlNmU2ZTY7Ym94LXNoYWRvdzppbnNldCAwIDNweCAzcHggcmdiYSgwLDAsMCwuMDQpfS5mb3JtLWNvbnRyb2w6Zm9jdXN7Ym9yZGVyLWNvbG9yOiM4YzhjOGM7b3V0bGluZTowfS5mb3JtLWNvbnRyb2w6Oi1tb3otcGxhY2Vob2xkZXJ7Y29sb3I6Izc3NztvcGFjaXR5OjF9LmZvcm0tY29udHJvbDotbXMtaW5wdXQtcGxhY2Vob2xkZXJ7Y29sb3I6Izc3N30uZm9ybS1jb250cm9sOjotd2Via2l0LWlucHV0LXBsYWNlaG9sZGVye2NvbG9yOiM3Nzd9LmZvcm0tY29udHJvbFtkaXNhYmxlZF0sLmZvcm0tY29udHJvbFtyZWFkb25seV0sZmllbGRzZXRbZGlzYWJsZWRdIC5mb3JtLWNvbnRyb2x7Y3Vyc29yOm5vdC1hbGxvd2VkO2JhY2tncm91bmQtY29sb3I6I2ZmZjtvcGFjaXR5OjF9dGV4dGFyZWEuZm9ybS1jb250cm9se2hlaWdodDphdXRvfWlucHV0W3R5cGU9c2VhcmNoXXstd2Via2l0LWFwcGVhcmFuY2U6bm9uZX1pbnB1dFt0eXBlPWRhdGVdLGlucHV0W3R5cGU9ZGF0ZXRpbWUtbG9jYWxdLGlucHV0W3R5cGU9bW9udGhdLGlucHV0W3R5cGU9dGltZV17bGluZS1oZWlnaHQ6MjJweH0uZm9ybS1ncm91cHttYXJnaW46MjNweCAwIDB9LmZvcm0tZ3JvdXA6Zmlyc3QtY2hpbGR7bWFyZ2luLXRvcDowfWZpZWxkc2V0W2Rpc2FibGVkXSBpbnB1dFt0eXBlPWNoZWNrYm94XSxmaWVsZHNldFtkaXNhYmxlZF0gaW5wdXRbdHlwZT1yYWRpb10saW5wdXRbdHlwZT1jaGVja2JveF0uZGlzYWJsZWQsaW5wdXRbdHlwZT1jaGVja2JveF1bZGlzYWJsZWRdLGlucHV0W3R5cGU9cmFkaW9dLmRpc2FibGVkLGlucHV0W3R5cGU9cmFkaW9dW2Rpc2FibGVkXXtjdXJzb3I6bm90LWFsbG93ZWR9LmZvcm0tdWl7cG9zaXRpb246cmVsYXRpdmU7ZGlzcGxheTppbmxpbmUtYmxvY2s7dmVydGljYWwtYWxpZ246dG9wO21hcmdpbjowO2xpbmUtaGVpZ2h0OjIwcHg7Zm9udC13ZWlnaHQ6NDAwO2N1cnNvcjpwb2ludGVyfS5jaGFuZ2UtcG9zaXRpb25faW5wdXQsLmZvcm0tdWktY29udHJvbCwubWVudS1maWx0ZXJfaW5wdXR7cG9zaXRpb246YWJzb2x1dGU7dG9wOi05OTk5cHg7bGVmdDotOTk5OXB4O3dpZHRoOjA7aGVpZ2h0OjA7b3ZlcmZsb3c6aGlkZGVuO2NsaXA6cmVjdCgwLDAsMCwwKTtvdXRsaW5lOjAgbm9uZX0uZm9ybS11aS10eHR7cG9zaXRpb246cmVsYXRpdmU7ZGlzcGxheTppbmxpbmUtYmxvY2s7dmVydGljYWwtYWxpZ246dG9wO3BhZGRpbmc6MnB4IDAgMCAzMHB4fS5mb3JtLXVpLXR4dDpiZWZvcmV7Y29udGVudDonJztwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjA7d2lkdGg6MjJweDtoZWlnaHQ6MjJweH0uZm9ybS11aS10eHQ6YWZ0ZXJ7Y29udGVudDonJztwb3NpdGlvbjphYnNvbHV0ZX1pbnB1dFt0eXBlPXJhZGlvXSsuZm9ybS11aSAuZm9ybS11aS10eHQ6YmVmb3Jle2JvcmRlcjoxcHggc29saWQgI2NmY2ZjZjtib3JkZXItcmFkaXVzOjUwJTtiYWNrZ3JvdW5kOiNmZmZ9aW5wdXRbdHlwZT1yYWRpb10rLmZvcm0tdWkgLmZvcm0tdWktdHh0OmFmdGVye3RvcDo3cHg7bGVmdDo3cHg7d2lkdGg6OHB4O2hlaWdodDo4cHg7Ym9yZGVyLXJhZGl1czo1MCV9aW5wdXRbdHlwZT1yYWRpb106Y2hlY2tlZCsuZm9ybS11aSAuZm9ybS11aS10eHQ6YWZ0ZXJ7YmFja2dyb3VuZDojMzZiYTUzfWlucHV0W3R5cGU9cmFkaW9dOmRpc2FibGVkKy5mb3JtLXVpIC5mb3JtLXVpLXR4dDpiZWZvcmV7YmFja2dyb3VuZDojZjJmMmYyO29wYWNpdHk6LjZ9aW5wdXRbdHlwZT1yYWRpb106ZGlzYWJsZWQrLmZvcm0tdWkgLmZvcm0tdWktdHh0OmFmdGVye29wYWNpdHk6LjZ9aW5wdXRbdHlwZT1jaGVja2JveF0rLmZvcm0tdWkgLmZvcm0tdWktdHh0OmJlZm9yZXtib3JkZXI6MXB4IHNvbGlkICNjZmNmY2Y7YmFja2dyb3VuZDojZmZmfWlucHV0W3R5cGU9Y2hlY2tib3hdKy5mb3JtLXVpIC5mb3JtLXVpLXR4dDphZnRlcnt0b3A6N3B4O2xlZnQ6NXB4O3dpZHRoOjEzcHg7aGVpZ2h0OjZweDtib3JkZXItYm90dG9tOjJweCBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItbGVmdDoycHggc29saWQgdHJhbnNwYXJlbnQ7LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKC00NWRlZyk7LW1zLXRyYW5zZm9ybTpyb3RhdGUoLTQ1ZGVnKTt0cmFuc2Zvcm06cm90YXRlKC00NWRlZyl9aW5wdXRbdHlwZT1jaGVja2JveF06Y2hlY2tlZCsuZm9ybS11aSAuZm9ybS11aS10eHQ6YmVmb3Jle2JvcmRlcjoxcHggc29saWQgIzM2YmE1MztiYWNrZ3JvdW5kOiMzNmJhNTN9aW5wdXRbdHlwZT1jaGVja2JveF06Y2hlY2tlZCsuZm9ybS11aSAuZm9ybS11aS10eHQ6YWZ0ZXJ7Ym9yZGVyLWJvdHRvbS1jb2xvcjojZmZmO2JvcmRlci1sZWZ0LWNvbG9yOiNmZmZ9aW5wdXRbdHlwZT1jaGVja2JveF06ZGlzYWJsZWQrLmZvcm0tdWkgLmZvcm0tdWktdHh0OmJlZm9yZXtvcGFjaXR5Oi42fWlucHV0W3R5cGU9Y2hlY2tib3hdOmRpc2FibGVkKy5mb3JtLXVpIC5mb3JtLXVpLXR4dDphZnRlcntvcGFjaXR5Oi42fS5idG57ZGlzcGxheTppbmxpbmUtYmxvY2s7bWFyZ2luLWJvdHRvbTowO3BhZGRpbmc6MTFweCAxN3B4IDlweDtmb250OjEzcHgvMThweCBHb3RoYW1Qcm8sQXJpYWwsc2Fucy1zZXJpZjt0ZXh0LWFsaWduOmNlbnRlcjt0ZXh0LWRlY29yYXRpb246bm9uZTt2ZXJ0aWNhbC1hbGlnbjptaWRkbGU7Y3Vyc29yOnBvaW50ZXI7YmFja2dyb3VuZC1pbWFnZTpub25lO2JvcmRlcjoxcHggc29saWQgdHJhbnNwYXJlbnQ7d2hpdGUtc3BhY2U6bm93cmFwOy13ZWJraXQtdXNlci1zZWxlY3Q6bm9uZTstbW96LXVzZXItc2VsZWN0Om5vbmU7LW1zLXVzZXItc2VsZWN0Om5vbmU7dXNlci1zZWxlY3Q6bm9uZX0uYnRuOmhvdmVye2NvbG9yOiMwMDA7dGV4dC1kZWNvcmF0aW9uOm5vbmV9LmJ0bi5hY3RpdmUsLmJ0bjphY3RpdmV7b3V0bGluZTowfS5idG46Zm9jdXN7b3V0bGluZTowO2JveC1zaGFkb3c6aW5zZXQgMCAwIDAgMXB4ICNmZmZ9LmJ0bi5kaXNhYmxlZCwuYnRuW2Rpc2FibGVkXXtjdXJzb3I6ZGVmYXVsdDtib3gtc2hhZG93Om5vbmU7b3BhY2l0eTouNTtwb2ludGVyLWV2ZW50czpub25lfS5idG4tZGVmYXVsdHtib3JkZXItY29sb3I6IzU4NTk1YjtiYWNrZ3JvdW5kOiM1ODU5NWI7Y29sb3I6I2ZmZn0uYnRuLWRlZmF1bHQ6aG92ZXJ7Ym9yZGVyLWNvbG9yOiM3MTcyNzU7YmFja2dyb3VuZDojNzE3Mjc1O2NvbG9yOiNmZmZ9LmJ0bi1kZWZhdWx0LmFjdGl2ZSwuYnRuLWRlZmF1bHQ6YWN0aXZle2JvcmRlci1jb2xvcjojNzE3Mjc1O2JhY2tncm91bmQ6IzcxNzI3NX0uYnRuLWRlZmF1bHQuZGlzYWJsZWQsLmJ0bi1kZWZhdWx0W2Rpc2FibGVkXXtib3JkZXItY29sb3I6IzU4NTk1YjtiYWNrZ3JvdW5kOiM1ODU5NWJ9LmJ0bi1wcmltYXJ5e2JvcmRlci1jb2xvcjojMzZiYTUzO2JhY2tncm91bmQ6IzM2YmE1Mztjb2xvcjojZmZmfS5idG4tcHJpbWFyeTpob3Zlcntib3JkZXItY29sb3I6IzMwYTY0YTtiYWNrZ3JvdW5kOiMzMGE2NGE7Y29sb3I6I2ZmZn0uYnRuLXByaW1hcnkuYWN0aXZlLC5idG4tcHJpbWFyeTphY3RpdmV7Ym9yZGVyLWNvbG9yOiMzMGE2NGE7YmFja2dyb3VuZDojMzBhNjRhfS5idG4tcHJpbWFyeS5kaXNhYmxlZCwuYnRuLXByaW1hcnlbZGlzYWJsZWRde2JvcmRlci1jb2xvcjojMzZiYTUzO2JhY2tncm91bmQ6IzM2YmE1M30uYnRuLWNhbmNlbHtib3JkZXItY29sb3I6I2YzNTIzZDtiYWNrZ3JvdW5kOiNmMzUyM2Q7Y29sb3I6I2ZmZn0uYnRuLWNhbmNlbDpob3Zlcntib3JkZXItY29sb3I6I2VlMjkwZjtiYWNrZ3JvdW5kOiNlZTI5MGY7Y29sb3I6I2ZmZn0uYnRuLWNhbmNlbC5hY3RpdmUsLmJ0bi1jYW5jZWw6YWN0aXZle2JvcmRlci1jb2xvcjojZWUyOTBmO2JhY2tncm91bmQ6I2VlMjkwZn0uYnRuLWNhbmNlbC5kaXNhYmxlZCwuYnRuLWNhbmNlbFtkaXNhYmxlZF17Ym9yZGVyLWNvbG9yOiNmMzUyM2Q7YmFja2dyb3VuZDojZjM1MjNkfS5idG4tbGd7Zm9udC1zaXplOjIwcHg7cGFkZGluZzoxNHB4IDI0cHggMTJweH0uYnRuLXNte2ZvbnQtc2l6ZToxNnB4O3BhZGRpbmctdG9wOjE0cHg7cGFkZGluZy1ib3R0b206MTRweH0uYnRuLXhze2ZvbnQtc2l6ZToxNHB4O3BhZGRpbmctdG9wOjEycHg7cGFkZGluZy1ib3R0b206MTJweH0uYnRuLWJsb2Nre2Rpc3BsYXk6YmxvY2s7d2lkdGg6MTAwJTtwYWRkaW5nLWxlZnQ6MDtwYWRkaW5nLXJpZ2h0OjB9LmJ0bi1ibG9jaysuYnRuLWJsb2Nre21hcmdpbi10b3A6NXB4fWlucHV0W3R5cGU9YnV0dG9uXS5idG4tYmxvY2ssaW5wdXRbdHlwZT1yZXNldF0uYnRuLWJsb2NrLGlucHV0W3R5cGU9c3VibWl0XS5idG4tYmxvY2t7d2lkdGg6MTAwJX0uYnRuLXVwbG9hZHtwb3NpdGlvbjpyZWxhdGl2ZTtvdmVyZmxvdzpoaWRkZW59LmJ0bi11cGxvYWQgaW5wdXRbdHlwZT1maWxlXXtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtyaWdodDowO21hcmdpbjowO2ZvbnQtc2l6ZTo2MDAlO2xpbmUtaGVpZ2h0OjYwMCU7d2lkdGg6YXV0bztoZWlnaHQ6YXV0bztvcGFjaXR5OjA7Y3Vyc29yOnBvaW50ZXJ9dGFibGV7Ym9yZGVyLXNwYWNpbmc6MDtib3JkZXItY29sbGFwc2U6Y29sbGFwc2V9Lm1haW57bWFyZ2luOjE5cHggMjRweCAzMHB4O2JvcmRlci1yYWRpdXM6NHB4O2JhY2tncm91bmQ6I2ZmZjtib3gtc2hhZG93OjAgNXB4IDI1cHggcmdiYSgwLDAsMCwuMzUpfS5jbG9zZXtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MTBweDtyaWdodDoxMHB4O2Rpc3BsYXk6aW5saW5lLWJsb2NrO3ZlcnRpY2FsLWFsaWduOnRvcDt3aWR0aDoxZW07Zm9udC1zaXplOjEycHg7bGluZS1oZWlnaHQ6MTtiYWNrZ3JvdW5kOnVybChkYXRhOmltYWdlL3N2Zyt4bWwsJTNDJTNGeG1sJTIwdmVyc2lvbiUzRCUyMjEuMCUyMiUyMGVuY29kaW5nJTNEJTIydXRmLTglMjIlM0YlM0UlMEElM0NzdmclMjB2ZXJzaW9uJTNEJTIyMS4xJTIyJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB2aWV3Qm94JTNEJTIyMCUyMDAlMjAxMDAlMjAxMDAlMjIlM0UlMEElM0NsaW5lJTIwZmlsbCUzRCUyMm5vbmUlMjIlMjBzdHJva2UlM0QlMjIlMjMwMDAwMDAlMjIlMjBzdHJva2Utd2lkdGglM0QlMjIyMCUyMiUyMHgxJTNEJTIyNSUyMiUyMHkxJTNEJTIyNSUyMiUyMHgyJTNEJTIyOTUlMjIlMjB5MiUzRCUyMjk1JTIyJTJGJTNFJTBBJTNDbGluZSUyMGZpbGwlM0QlMjJub25lJTIyJTIwc3Ryb2tlJTNEJTIyJTIzMDAwMDAwJTIyJTIwc3Ryb2tlLXdpZHRoJTNEJTIyMjAlMjIlMjB4MSUzRCUyMjk1JTIyJTIweTElM0QlMjI1JTIyJTIweDIlM0QlMjI1JTIyJTIweTIlM0QlMjI5NSUyMiUyRiUzRSUwQSUzQyUyRnN2ZyUzRSUwQSkgbm8tcmVwZWF0IDAgMC9jb3ZlcjtvcGFjaXR5Oi4yO2N1cnNvcjpwb2ludGVyfS5jbG9zZTpiZWZvcmV7Y29udGVudDoiXDAwYTAifS5jbG9zZTpob3ZlcntvcGFjaXR5Oi41fS5sb2dve2Rpc3BsYXk6aW5saW5lLWJsb2NrO3ZlcnRpY2FsLWFsaWduOnRvcDt3aWR0aDoxZW07bGluZS1oZWlnaHQ6MTtiYWNrZ3JvdW5kOnVybChkYXRhOmltYWdlL3N2Zyt4bWwsJTNDJTNGeG1sJTIwdmVyc2lvbiUzRCUyMjEuMCUyMiUyMGVuY29kaW5nJTNEJTIyVVRGLTglMjIlM0YlM0UlMEElM0MhRE9DVFlQRSUyMHN2ZyUyMFBVQkxJQyUyMCUyMi0lMkYlMkZXM0MlMkYlMkZEVEQlMjBTVkclMjAxLjElMkYlMkZFTiUyMiUyMCUyMmh0dHAlM0ElMkYlMkZ3d3cudzMub3JnJTJGR3JhcGhpY3MlMkZTVkclMkYxLjElMkZEVEQlMkZzdmcxMS5kdGQlMjIlM0UlMEElM0MhLS0lMjBDcmVhdG9yJTNBJTIwQ29yZWxEUkFXJTIwWDclMjAtLSUzRSUwQSUzQ3N2ZyUyMHhtbG5zJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYyMDAwJTJGc3ZnJTIyJTIweG1sJTNBc3BhY2UlM0QlMjJwcmVzZXJ2ZSUyMiUyMHdpZHRoJTNEJTIyMTAwcHglMjIlMjBoZWlnaHQlM0QlMjIxMDBweCUyMiUyMHZlcnNpb24lM0QlMjIxLjElMjIlMjBzdHlsZSUzRCUyMnNoYXBlLXJlbmRlcmluZyUzQWdlb21ldHJpY1ByZWNpc2lvbiUzQiUyMHRleHQtcmVuZGVyaW5nJTNBZ2VvbWV0cmljUHJlY2lzaW9uJTNCJTIwaW1hZ2UtcmVuZGVyaW5nJTNBb3B0aW1pemVRdWFsaXR5JTNCJTIwZmlsbC1ydWxlJTNBZXZlbm9kZCUzQiUyMGNsaXAtcnVsZSUzQWV2ZW5vZGQlMjIlMEF2aWV3Qm94JTNEJTIyMCUyMDAlMjAxMDAlMjAxMDAlMjIlMEElMjB4bWxucyUzQXhsaW5rJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYxOTk5JTJGeGxpbmslMjIlM0UlMEElMjAlM0NkZWZzJTNFJTBBJTIwJTIwJTNDc3R5bGUlMjB0eXBlJTNEJTIydGV4dCUyRmNzcyUyMiUzRSUwQSUyMCUyMCUyMCUzQyElNUJDREFUQSU1QiUwQSUyMCUyMCUyMCUyMC5maWwwJTIwJTdCZmlsbCUzQSUyMzRGQkU4NSU3RCUwQSUyMCUyMCUyMCU1RCU1RCUzRSUwQSUyMCUyMCUzQyUyRnN0eWxlJTNFJTBBJTIwJTNDJTJGZGVmcyUzRSUwQSUyMCUzQ2clMjBpZCUzRCUyMiVEMCVBMSVEMCVCQiVEMCVCRSVEMCVCOV94MDAyMF8xJTIyJTNFJTBBJTIwJTIwJTNDbWV0YWRhdGElMjBpZCUzRCUyMkNvcmVsQ29ycElEXzBDb3JlbC1MYXllciUyMiUyRiUzRSUwQSUyMCUyMCUzQ3BhdGglMjBjbGFzcyUzRCUyMmZpbDAlMjIlMjBkJTNEJTIyTTUwJTIwMWMxNiUyQzAlMjAzNSUyQzMlMjA1MCUyQzExJTIwMCUyQzE3JTIwMSUyQzYwJTIwLTUwJTJDODklMjAtNTAlMkMtMjklMjAtNTAlMkMtNzIlMjAtNTAlMkMtODklMjAxNiUyQy04JTIwMzUlMkMtMTElMjA1MCUyQy0xMXptMCUyMDhjLTE0JTJDMCUyMC0yOSUyQzMlMjAtNDElMkM4JTIwMCUyQzE4JTIwNCUyQzUwJTIwNDElMkM3NCUyMDM4JTJDLTI0JTIwNDElMkMtNTYlMjA0MiUyQy03MyUyMC0xMyUyQy02JTIwLTI4JTJDLTklMjAtNDIlMkMtOXolMjIlMkYlM0UlMEElMjAlMjAlM0NwYXRoJTIwY2xhc3MlM0QlMjJmaWwwJTIyJTIwZCUzRCUyMk03NyUyMDI1YzIlMkMwJTIwMSUyQzAlMjAyJTJDMWwtMzIlMjA0MWMwJTJDMCUyMC0yMiUyQy0yNiUyMC0yMyUyQy0yNiUyMDIlMkMtMSUyMDglMkMtNSUyMDEzJTJDMGwxMCUyMDEyJTIwMjclMjAtMjdjMSUyQy0xJTIwMiUyQy0xJTIwMyUyQy0xbDAlMjAweiUyMiUyRiUzRSUwQSUyMCUzQyUyRmclM0UlMEElM0MlMkZzdmclM0UlMEEpIG5vLXJlcGVhdCAwIDA7YmFja2dyb3VuZC1zaXplOjEwMCV9LmxvZ286YmVmb3Jle2NvbnRlbnQ6IlwwMGEwIn0ubG9nb19fd2hpdGV7YmFja2dyb3VuZC1pbWFnZTp1cmwoZGF0YTppbWFnZS9zdmcreG1sLCUzQyUzRnhtbCUyMHZlcnNpb24lM0QlMjIxLjAlMjIlMjBlbmNvZGluZyUzRCUyMlVURi04JTIyJTNGJTNFJTBBJTNDc3ZnJTIwdmVyc2lvbiUzRCUyMjEuMSUyMiUyMHhtbG5zJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYyMDAwJTJGc3ZnJTIyJTIwdmlld0JveCUzRCUyMjAlMjAwJTIwMTAwJTIwMTAwJTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNNTAlMkMwJTIwQzY1JTJDMCUyMDgzLjIlMkMzLjYlMjA5OC4xJTJDMTEuNCUyMEM5OC4xJTJDMjguNSUyMDk4LjMlMkM3MSUyMDUwJTJDMTAwJTIwQzEuNyUyQzcxJTIwMS45JTJDMjguNSUyMDEuOSUyQzExLjQlMjBDMTYuOCUyQzMuNiUyMDM1JTJDMCUyMDUwJTJDMCUyMHolMjBNNTAlMkM4LjQlMjBDMzYuNSUyQzguNCUyMDIyJTJDMTEuNCUyMDEwLjMlMkMxNi42JTIwQzEwLjYlMkMzNC4yJTIwMTMuOSUyQzY2LjQlMjA1MCUyQzkwLjIlMjBDODYuMSUyQzY2LjMlMjA4OS40JTJDMzQuMiUyMDg5LjclMkMxNi44JTIwQzc4JTJDMTEuNSUyMDYzLjUlMkM4LjQlMjA1MCUyQzguNCUyMHolMjBNNzYuNDQ2JTJDMjMuNTc3JTIwQzc4LjMwMiUyQzI0LjAzOCUyMDc3LjU0NSUyQzIzLjY2NyUyMDc4LjglMkMyNC41JTIwTDQ4LjIlMkM2Ni40JTIwQzQ4LjIlMkM2Ni40JTIwMjYuMSUyQzQwJTIwMjYlMkM0MCUyMEMyNy41JTJDMzguOSUyMDMzLjclMkMzNC44JTIwMzguMyUyQzQwLjIlMjBMNDcuOSUyQzUxLjklMjBMNzMuNSUyQzI1JTIwQzc0LjM4OCUyQzI0LjAzMSUyMDc1LjIxOSUyQzIzLjg1MyUyMDc2LjQ0NiUyQzIzLjU3NyUyMHolMjIlMjBmaWxsJTNEJTIyJTIzZmZmJTIyJTJGJTNFJTBBJTNDJTJGc3ZnJTNFJTBBKX0uYS1sb2dve2Rpc3BsYXk6aW5saW5lLWJsb2NrO3ZlcnRpY2FsLWFsaWduOnRvcDt3aWR0aDo0MHB4O2hlaWdodDo0MHB4O3BhZGRpbmc6MTBweCAwIDA7Zm9udC1zaXplOjIwcHg7dGV4dC1hbGlnbjpjZW50ZXI7Ym9yZGVyOjFweCBzb2xpZCAjY2RjZGNkO2JvcmRlci1yYWRpdXM6NTAlO2JhY2tncm91bmQ6I2ZmZn0uYS1sb2dvX19zbWFsbHt3aWR0aDoyNHB4O2hlaWdodDoyNHB4O2ZvbnQtc2l6ZToxMnB4O3BhZGRpbmc6NnB4IDAgMH0udG9vbHRpcHtwb3NpdGlvbjpyZWxhdGl2ZX0udG9vbHRpcDpiZWZvcmV7ZGlzcGxheTpub25lO2NvbnRlbnQ6YXR0cihkYXRhLXRpdGxlKTtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MTAwJTtsZWZ0OjUwJTt3aWR0aDoxNzBweDttYXJnaW46N3B4IDAgMCAtODVweDtwYWRkaW5nOjZweCAwIDVweDtmb250LXNpemU6MTBweDtmb250LXN0eWxlOm5vcm1hbDtmb250LXdlaWdodDo1MDA7Y29sb3I6I2ZmZjt0ZXh0LWFsaWduOmNlbnRlcjt3aGl0ZS1zcGFjZTpub3dyYXA7Ym9yZGVyLXJhZGl1czo0cHg7YmFja2dyb3VuZDpyZ2JhKDAsMCwwLC44KX0udG9vbHRpcDphZnRlcntkaXNwbGF5Om5vbmU7Y29udGVudDonJztwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MTAwJTtsZWZ0OjUwJTttYXJnaW46M3B4IDAgMCAtNHB4O2JvcmRlci1ib3R0b206NHB4IHNvbGlkIHJnYmEoMCwwLDAsLjgpO2JvcmRlci1sZWZ0OjRweCBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItcmlnaHQ6NHB4IHNvbGlkIHRyYW5zcGFyZW50fS50b29sdGlwOmhvdmVyOmFmdGVyLC50b29sdGlwOmhvdmVyOmJlZm9yZXtkaXNwbGF5OmJsb2NrfS5tYWlue3Bvc2l0aW9uOnJlbGF0aXZlfS5oZWFke3BhZGRpbmc6MThweCAyMHB4O2N1cnNvcjptb3ZlfS5oZWFkX3RpdGxle2ZvbnQtc2l6ZToxNnB4O2ZvbnQtd2VpZ2h0OjcwMDtjb2xvcjojMzQzNDM0fS5oZWFkX3RleHR7bWFyZ2luOjRweCAwIDA7Zm9udC1zaXplOjEycHg7Y29sb3I6IzM0MzQzNH0uY29udGVudHtib3JkZXItdG9wOjFweCBzb2xpZCAjZTBkZmRifS5mb290e3BhZGRpbmc6MjBweDtib3JkZXItdG9wOjFweCBzb2xpZCAjZTBkZmRifS5mb290X2FjdGlvbntmbG9hdDpyaWdodH0uZm9vdF9hY3Rpb25fYnRue2ZvbnQtc2l6ZTowfS5mb290X2FjdGlvbl9idG4gLmJ0bisuYnRue21hcmdpbi1sZWZ0OjEwcHh9LmVsZW1lbnQtcnVsZXtwYWRkaW5nOjIwcHh9LmVsZW1lbnQtcnVsZV9zbGlkZXJ7bWFyZ2luOjVweCAwIDdweDstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7LW1vei11c2VyLXNlbGVjdDpub25lOy1tcy11c2VyLXNlbGVjdDpub25lO3VzZXItc2VsZWN0Om5vbmV9LmVsZW1lbnQtcnVsZV9leHBhbmQtbGlua3tmb250LXNpemU6MTJweDtsaW5lLWhlaWdodDoxNXB4O2ZvbnQtd2VpZ2h0OjUwMDtjdXJzb3I6cG9pbnRlcn0uZWxlbWVudC1ydWxlX2V4cGFuZC1saW5rX3R4dHtkaXNwbGF5OmlubGluZS1ibG9jazt2ZXJ0aWNhbC1hbGlnbjp0b3A7Y29sb3I6IzM2YmE1Mztib3JkZXItYm90dG9tOjFweCBzb2xpZCAjY2NmMGQ0fS5lbGVtZW50LXJ1bGVfZXhwYW5kLWxpbmtfYXJye2Rpc3BsYXk6aW5saW5lLWJsb2NrO3ZlcnRpY2FsLWFsaWduOnRvcDt3aWR0aDo1cHg7aGVpZ2h0OjVweDttYXJnaW46M3B4IDAgMCAzcHg7Ym9yZGVyLWJvdHRvbToxcHggc29saWQgIzkxYTc5NTtib3JkZXItbGVmdDoxcHggc29saWQgIzkxYTc5NTstd2Via2l0LXRyYW5zZm9ybTpyb3RhdGUoLTQ1ZGVnKTstbXMtdHJhbnNmb3JtOnJvdGF0ZSgtNDVkZWcpO3RyYW5zZm9ybTpyb3RhdGUoLTQ1ZGVnKTt0cmFuc2l0aW9uOi4yc30uZWxlbWVudC1ydWxlX2V4cGFuZC1saW5rOmhvdmVyIC5lbGVtZW50LXJ1bGVfZXhwYW5kLWxpbmtfdHh0e2NvbG9yOiMyNTdmMzk7Ym9yZGVyLWJvdHRvbS1jb2xvcjojOTFkZmEyfS5lbGVtZW50LXJ1bGVfZXhwYW5kLWxpbmsuYWN0aXZlIC5lbGVtZW50LXJ1bGVfZXhwYW5kLWxpbmtfYXJye21hcmdpbi10b3A6NXB4Oy13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgtMjI1ZGVnKTstbXMtdHJhbnNmb3JtOnJvdGF0ZSgtMjI1ZGVnKTt0cmFuc2Zvcm06cm90YXRlKC0yMjVkZWcpfS5lbGVtZW50LXJ1bGVfZm9ybXtoZWlnaHQ6MDttYXJnaW46MCAtMjBweDt0cmFuc2l0aW9uOi4ycztvdmVyZmxvdzpoaWRkZW59LmVsZW1lbnQtcnVsZV9mb3JtLm9wZW57aGVpZ2h0OmF1dG87bWFyZ2luLWJvdHRvbTotMjBweH0uZWxlbWVudC1ydWxlX2Zvcm0tY29udHttYXJnaW46NHB4IDAgMDtwYWRkaW5nOjIwcHg7Ym9yZGVyLXRvcDoxcHggc29saWQgI2UwZGZkYjtiYWNrZ3JvdW5kOiNmNGY0ZWZ9LmVsZW1lbnQtcnVsZV9maWVsZHNldHttYXJnaW46MTBweCAwIDB9LmVsZW1lbnQtcnVsZV9maWVsZHNldDpmaXJzdC1jaGlsZHttYXJnaW46MH0uYWRnLXNsaWRle3Bvc2l0aW9uOnJlbGF0aXZlO3dpZHRoOjUwMHB4O2hlaWdodDo0NHB4O21hcmdpbjphdXRvOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsMCwwKTt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCwwLDApfS5hZGctc2xpZGUtY2x1ZS1tYXgsLmFkZy1zbGlkZS1jbHVlLW1pbntwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MTRweDtsZWZ0Oi0zNXB4O3dpZHRoOjMwcHg7Zm9udC1zaXplOjEycHg7Zm9udC13ZWlnaHQ6NTAwO2NvbG9yOiM4ZjliOTI7Y3Vyc29yOnBvaW50ZXJ9LmFkZy1zbGlkZS1jbHVlLW1pbntsZWZ0OmF1dG87cmlnaHQ6LTQwcHg7dGV4dC1hbGlnbjpyaWdodH0udWktc2xpZGVyLWhhbmRsZXtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MjJweDt6LWluZGV4OjI7Y3Vyc29yOnBvaW50ZXJ9LnVpLXNsaWRlci1oYW5kbGU6YmVmb3Jle2NvbnRlbnQ6Jyc7cG9zaXRpb246YWJzb2x1dGU7dG9wOjUwJTtsZWZ0OjUwJTt3aWR0aDozMHB4O2hlaWdodDozMHB4O21hcmdpbjotMTVweCAwIDAgLTE1cHg7YmFja2dyb3VuZDpyZ2JhKDAsMCwwLC4xKTtib3JkZXItcmFkaXVzOjUwJTt0cmFuc2l0aW9uOi4yc30udWktc2xpZGVyLWhhbmRsZTphZnRlcntjb250ZW50OicnO3Bvc2l0aW9uOmFic29sdXRlO3RvcDo1MCU7bGVmdDo1MCU7d2lkdGg6MjBweDtoZWlnaHQ6MjBweDttYXJnaW46LTEwcHggMCAwIC0xMHB4O2JhY2tncm91bmQ6IzM2YmE1Mztib3JkZXItcmFkaXVzOjUwJX0udWktc2xpZGVyLWhhbmRsZTpob3ZlcjphY3RpdmUsLnVpLXNsaWRlci1oYW5kbGU6aG92ZXI6YmVmb3Jle2JhY2tncm91bmQ6cmdiYSgwLDAsMCwuMTUpfS50aWNre3Bvc2l0aW9uOmFic29sdXRlO2hlaWdodDo0NHB4O2JvcmRlcjoyMHB4IHNvbGlkICNmZmY7Ym9yZGVyLWxlZnQ6MXB4IHNvbGlkICNmZmY7Ym9yZGVyLXJpZ2h0OjFweCBzb2xpZCAjZmZmfS5zZXR0aW5nc19maWVsZHNldHtwYWRkaW5nOjIwcHg7Ym9yZGVyLXRvcDoxcHggc29saWQgI2UwZGZkYn0uc2V0dGluZ3NfZmllbGRzZXQ6Zmlyc3QtY2hpbGR7Ym9yZGVyOjB9LnNldHRpbmdzX2ZpZWxkc2V0X2xibHtmbG9hdDpsZWZ0O3dpZHRoOjEyNnB4O21hcmdpbjoxcHggMCAwO2ZvbnQtc2l6ZToxNHB4O2ZvbnQtd2VpZ2h0OjUwMDtjb2xvcjojOGY5YjkyfS5zZXR0aW5nc19maWVsZHNldF9sYmxfX3Bvc3ttYXJnaW4tdG9wOjIxcHh9LnNldHRpbmdzX2ZpZWxkc2V0X3ZhbHttYXJnaW46MCAwIDAgMTI2cHh9LmNob2ljZS1zaXple3Bvc2l0aW9uOnJlbGF0aXZlO2ZvbnQtc2l6ZToxNHB4fS5jaG9pY2Utc2l6ZV9maWVsZHttYXJnaW46OHB4IDAgMH0uY2hvaWNlLXNpemVfZmllbGQ6Zmlyc3QtY2hpbGR7bWFyZ2luOjB9LmNob2ljZS1zaXplX2xvZ297ZGlzcGxheTpub25lO3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO3JpZ2h0OjB9LmNob2ljZS1zaXplX2xvZ28gLmEtbG9nb3ttYXJnaW46NnB4IDAgMH0uY2hvaWNlLXNpemVfbG9nbyAuYS1sb2dvX19zbWFsbHttYXJnaW46MTRweCA4cHggMCAwfS5jaG9pY2Utc2l6ZV9pbnB1dDpjaGVja2Vkfi5jaG9pY2Utc2l6ZV9sb2dve2Rpc3BsYXk6YmxvY2t9W2NsYXNzXj1zLXBvc2l0aW9uLWFyci1de2Rpc3BsYXk6YmxvY2s7d2lkdGg6MTFweDtoZWlnaHQ6MTFweDtiYWNrZ3JvdW5kOnVybCgiZGF0YTppbWFnZS9zdmcreG1sLCUzQyUzRnhtbCUyMHZlcnNpb24lM0QlMjIxLjAlMjIlMjBlbmNvZGluZyUzRCUyMnV0Zi04JTIyJTNGJTNFJTBBJTNDc3ZnJTIwdmVyc2lvbiUzRCUyMjEuMSUyMiUyMHhtbG5zJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYyMDAwJTJGc3ZnJTIyJTIweG1sbnMlM0F4bGluayUzRCUyMmh0dHAlM0ElMkYlMkZ3d3cudzMub3JnJTJGMTk5OSUyRnhsaW5rJTIyJTBBJTIwJTIwJTIwJTIwJTIwd2lkdGglM0QlMjI0MDAlMjIlMjBoZWlnaHQlM0QlMjIyMDAlMjIlMjB2aWV3Qm94JTNEJTIyMCUyMDAlMjA0MDAlMjAyMDAlMjIlM0UlMEElMjAlMjAlMjAlMjAlM0NkZWZzJTNFJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTNDZyUyMGlkJTNEJTIyYXJyJTIyJTNFJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTNDcG9seWdvbiUyMHBvaW50cyUzRCUyMjE4LjglMkM4NC41JTIwMTguOCUyQzMyJTIwODYuNyUyQzEwMCUyMDEwMCUyQzg2LjclMjAzMiUyQzE4LjglMjA4NC41JTJDMTguOCUyMDg0LjUlMkMwJTIwMTguOCUyQzAlMjAwJTJDMCUyMDAlMkMxOC44JTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwMCUyQzg0LjUlMjAlMDklMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlM0MlMkZnJTNFJTBBJTIwJTIwJTIwJTIwJTNDJTJGZGVmcyUzRSUwQSUwQSUyMCUyMCUyMCUyMCUzQ3VzZSUyMHhsaW5rJTNBaHJlZiUzRCUyMiUyM2FyciUyMiUyMGZpbGwlM0QlMjIlMjNhYmFiYWIlMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0N1c2UlMjB4bGluayUzQWhyZWYlM0QlMjIlMjNhcnIlMjIlMjBmaWxsJTNEJTIyJTIzYWJhYmFiJTIyJTIwdHJhbnNmb3JtJTNEJTIycm90YXRlKDkwJTIwMTAwJTIwMTAwKSUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3VzZSUyMHhsaW5rJTNBaHJlZiUzRCUyMiUyM2FyciUyMiUyMGZpbGwlM0QlMjIlMjNhYmFiYWIlMjIlMjB0cmFuc2Zvcm0lM0QlMjJyb3RhdGUoMTgwJTIwMTAwJTIwMTAwKSUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3VzZSUyMHhsaW5rJTNBaHJlZiUzRCUyMiUyM2FyciUyMiUyMGZpbGwlM0QlMjIlMjNhYmFiYWIlMjIlMjB0cmFuc2Zvcm0lM0QlMjJyb3RhdGUoMjcwJTIwMTAwJTIwMTAwKSUyMiUyRiUzRSUwQSUwQSUyMCUyMCUyMCUyMCUzQ3VzZSUyMHhsaW5rJTNBaHJlZiUzRCUyMiUyM2FyciUyMiUyMGZpbGwlM0QlMjIlMjNmZmYlMjIlMjB4JTNEJTIyMjAwJTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDdXNlJTIweGxpbmslM0FocmVmJTNEJTIyJTIzYXJyJTIyJTIwZmlsbCUzRCUyMiUyM2ZmZiUyMiUyMHklM0QlMjItMjAwJTIyJTIwdHJhbnNmb3JtJTNEJTIycm90YXRlKDkwJTIwMTAwJTIwMTAwKSUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3VzZSUyMHhsaW5rJTNBaHJlZiUzRCUyMiUyM2FyciUyMiUyMGZpbGwlM0QlMjIlMjNmZmYlMjIlMjB4JTNEJTIyLTIwMCUyMiUyMHRyYW5zZm9ybSUzRCUyMnJvdGF0ZSgxODAlMjAxMDAlMjAxMDApJTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDdXNlJTIweGxpbmslM0FocmVmJTNEJTIyJTIzYXJyJTIyJTIwZmlsbCUzRCUyMiUyM2ZmZiUyMiUyMHklM0QlMjIyMDAlMjIlMjB0cmFuc2Zvcm0lM0QlMjJyb3RhdGUoMjcwJTIwMTAwJTIwMTAwKSUyMiUyRiUzRSUwQSUzQyUyRnN2ZyUzRSUwQSIpIG5vLXJlcGVhdDtiYWNrZ3JvdW5kLXNpemU6NDRweCAyMnB4fS5zLXBvc2l0aW9uLWFyci10b3AtbGVmdHtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgMH0ucy1wb3NpdGlvbi1hcnItdG9wLXJpZ2h0e2JhY2tncm91bmQtcG9zaXRpb246LTExcHggMH0ucy1wb3NpdGlvbi1hcnItYm90dG9tLWxlZnR7YmFja2dyb3VuZC1wb3NpdGlvbjowIC0xMXB4fS5zLXBvc2l0aW9uLWFyci1ib3R0b20tcmlnaHR7YmFja2dyb3VuZC1wb3NpdGlvbjotMTFweCAtMTFweH0uY2hhbmdlLXBvc2l0aW9ue3Bvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6aW5saW5lLWJsb2NrO3ZlcnRpY2FsLWFsaWduOnRvcDt3aWR0aDo3MHB4O21hcmdpbjotM3B4IDAgMCAtM3B4fS5jaGFuZ2UtcG9zaXRpb25faXtmbG9hdDpsZWZ0O21hcmdpbjozcHggMCAwIDNweH0uY2hhbmdlLXBvc2l0aW9uX2lucHV0OmNoZWNrZWQrLmNoYW5nZS1wb3NpdGlvbl9sYWJlbHtib3JkZXItY29sb3I6IzM2YmE1MztiYWNrZ3JvdW5kOiMzNmJhNTN9LmNoYW5nZS1wb3NpdGlvbl9pbnB1dDpjaGVja2VkKy5jaGFuZ2UtcG9zaXRpb25fbGFiZWwgLnMtcG9zaXRpb24tYXJyLXRvcC1sZWZ0e2JhY2tncm91bmQtcG9zaXRpb246LTIycHggMH0uY2hhbmdlLXBvc2l0aW9uX2lucHV0OmNoZWNrZWQrLmNoYW5nZS1wb3NpdGlvbl9sYWJlbCAucy1wb3NpdGlvbi1hcnItdG9wLXJpZ2h0e2JhY2tncm91bmQtcG9zaXRpb246LTMzcHggMH0uY2hhbmdlLXBvc2l0aW9uX2lucHV0OmNoZWNrZWQrLmNoYW5nZS1wb3NpdGlvbl9sYWJlbCAucy1wb3NpdGlvbi1hcnItYm90dG9tLWxlZnR7YmFja2dyb3VuZC1wb3NpdGlvbjotMjJweCAtMTFweH0uY2hhbmdlLXBvc2l0aW9uX2lucHV0OmNoZWNrZWQrLmNoYW5nZS1wb3NpdGlvbl9sYWJlbCAucy1wb3NpdGlvbi1hcnItYm90dG9tLXJpZ2h0e2JhY2tncm91bmQtcG9zaXRpb246LTMzcHggLTExcHh9LmNoYW5nZS1wb3NpdGlvbl9pbnB1dDpjaGVja2Vkfi5jaGFuZ2UtcG9zaXRpb25fdmFse2Rpc3BsYXk6YmxvY2t9LmNoYW5nZS1wb3NpdGlvbl9sYWJlbHtkaXNwbGF5OmJsb2NrO3dpZHRoOjMycHg7aGVpZ2h0OjMycHg7bWFyZ2luOjA7cGFkZGluZzo5cHggMCAwIDlweDtib3JkZXI6MXB4IHNvbGlkICNkZmRlZGI7Y3Vyc29yOnBvaW50ZXJ9LmNoYW5nZS1wb3NpdGlvbl92YWx7ZGlzcGxheTpub25lO3Bvc2l0aW9uOmFic29sdXRlO3RvcDoyN3B4O2xlZnQ6ODJweDtmb250LXNpemU6MTJweDt3aGl0ZS1zcGFjZTpub3dyYXB9LndvdC1pbmRpY2F0b3J7ZGlzcGxheTppbmxpbmUtYmxvY2s7dmVydGljYWwtYWxpZ246dG9wfS53b3QtaGlkZXtkaXNwbGF5Om5vbmV9I1dvdERlc2NyaXB0aW9uVGV4dHt3aGl0ZS1zcGFjZTpwcmUtbGluZX0uYWRnLXdvdHt3aWR0aDoxOHB4O2hlaWdodDoxOHB4O2Rpc3BsYXk6YmxvY2s7Ym9yZGVyOjVweCBzb2xpZCAjMDAwO2JvcmRlci1yYWRpdXM6NTAlfS5hZGctd290LXVua25vd257Ym9yZGVyLWNvbG9yOiNjY2N9LmFkZy13b3QtcmVke2JvcmRlci1jb2xvcjojYjYwMDAwfS5hZGctd290LWxpZ2h0UmVke2JvcmRlci1jb2xvcjojZjIxODAwfS5hZGctd290LXllbGxvd3tib3JkZXItY29sb3I6I2ZhYzAwMH0uYWRnLXdvdC1saWdodEdyZWVue2JvcmRlci1jb2xvcjojNjlkMjI1fS5hZGctd290LWdyZWVue2JvcmRlci1jb2xvcjojMDBhZTE3fS5hZGctd290LWNvbmZpZGVuY2V7YmFja2dyb3VuZDp1cmwoLi4vaS9zLXdvdC5wbmcpIG5vLXJlcGVhdH0uYWRnLXdvdC1jb25maWRlbmNle3dpZHRoOjUycHg7aGVpZ2h0OjE4cHg7ZGlzcGxheTppbmxpbmUtYmxvY2s7dmVydGljYWwtYWxpZ246dG9wfS5hZGctd290LWNvbmZpZGVuY2UtMHtiYWNrZ3JvdW5kLWltYWdlOnVybChkYXRhOmltYWdlL3N2Zyt4bWwsJTNDJTNGeG1sJTIwdmVyc2lvbiUzRCUyMjEuMCUyMiUyMGVuY29kaW5nJTNEJTIyVVRGLTglMjIlM0YlM0UlMEElM0NzdmclMjB2ZXJzaW9uJTNEJTIyMS4xJTIyJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB2aWV3Qm94JTNEJTIyMCUyMDAlMjA1MiUyMDE4JTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNNS4zNTMlMkM3LjQxMiUyMEw1LjMwNCUyQzcuMzYzJTIwQzcuMTIxJTJDNy4xMjUlMjA4LjUyOSUyQzUuNTg3JTIwOC41MjklMkMzLjcwNiUyMEM4LjUyOSUyQzEuNjU5JTIwNi44NyUyQzAlMjA0LjgyNCUyQzAlMjBDMi43NzclMkMwJTIwMS4xMTglMkMxLjY1OSUyMDEuMTE4JTJDMy43MDYlMjBDMS4xMTglMkM1LjU3MiUyMDIuNTAyJTJDNy4wOTklMjA0LjI5NCUyQzcuMzU4JTIwTDQuMjk0JTJDNy40MTIlMjBDMS4xMTglMkM3LjQxMiUyMDAuMDU5JTJDOS41MjklMjAwLjA1OSUyQzkuNTI5JTIwTDEuMTE4JTJDMTUuODgyJTIwQzEuMTE4JTJDMTYuOTM4JTIwMi40NzUlMkMxNy44MDYlMjA0LjI0NCUyQzE3Ljk2NyUyMEw0LjI5NCUyQzE4JTIwTDUuMzUzJTJDMTglMjBMNS40MDMlMkMxNy45NjclMjBDNy4xNzIlMkMxNy44MDYlMjA4LjUyOSUyQzE2LjkzOCUyMDguNTI5JTJDMTUuODgyJTIwTDkuNTg4JTJDOS41MjklMjBDOS41ODglMkM5LjUyOSUyMDguNTI5JTJDNy40MTIlMjA1LjM1MyUyQzcuNDEyJTIweiUyMiUyMGZpbGwlM0QlMjIlMjNENkQ2RDYlMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0xNS45NDElMkM3LjQxMiUyMEwxNS44OTIlMkM3LjM2MyUyMEMxNy43MDklMkM3LjEyNSUyMDE5LjExOCUyQzUuNTg3JTIwMTkuMTE4JTJDMy43MDYlMjBDMTkuMTE4JTJDMS42NTklMjAxNy40NTglMkMwJTIwMTUuNDEyJTJDMCUyMEMxMy4zNjUlMkMwJTIwMTEuNzA2JTJDMS42NTklMjAxMS43MDYlMkMzLjcwNiUyMEMxMS43MDYlMkM1LjU3MiUyMDEzLjA5JTJDNy4wOTklMjAxNC44ODIlMkM3LjM1OCUyMEwxNC44ODIlMkM3LjQxMiUyMEMxMS43MDYlMkM3LjQxMiUyMDEwLjY0NyUyQzkuNTI5JTIwMTAuNjQ3JTJDOS41MjklMjBMMTEuNzA2JTJDMTUuODgyJTIwQzExLjcwNiUyQzE2LjkzOCUyMDEzLjA2MyUyQzE3LjgwNiUyMDE0LjgzMyUyQzE3Ljk2NyUyMEwxNC44ODIlMkMxOCUyMEwxNS45NDElMkMxOCUyMEwxNS45OTElMkMxNy45NjclMjBDMTcuNzYlMkMxNy44MDYlMjAxOS4xMTglMkMxNi45MzglMjAxOS4xMTglMkMxNS44ODIlMjBMMjAuMTc2JTJDOS41MjklMjBDMjAuMTc2JTJDOS41MjklMjAxOS4xMTglMkM3LjQxMiUyMDE1Ljk0MSUyQzcuNDEyJTIweiUyMiUyMGZpbGwlM0QlMjIlMjNENkQ2RDYlMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0yNi41MjklMkM3LjQxMiUyMEwyNi40ODElMkM3LjM2MyUyMEMyOC4yOTglMkM3LjEyNSUyMDI5LjcwNiUyQzUuNTg3JTIwMjkuNzA2JTJDMy43MDYlMjBDMjkuNzA2JTJDMS42NTklMjAyOC4wNDclMkMwJTIwMjYlMkMwJTIwQzIzLjk1MyUyQzAlMjAyMi4yOTQlMkMxLjY1OSUyMDIyLjI5NCUyQzMuNzA2JTIwQzIyLjI5NCUyQzUuNTcyJTIwMjMuNjc4JTJDNy4wOTklMjAyNS40NzElMkM3LjM1OCUyMEwyNS40NzElMkM3LjQxMiUyMEMyMi4yOTQlMkM3LjQxMiUyMDIxLjIzNSUyQzkuNTI5JTIwMjEuMjM1JTJDOS41MjklMjBMMjIuMjk0JTJDMTUuODgyJTIwQzIyLjI5NCUyQzE2LjkzOCUyMDIzLjY1MiUyQzE3LjgwNiUyMDI1LjQyMSUyQzE3Ljk2NyUyMEwyNS40NzElMkMxOCUyMEwyNi41MjklMkMxOCUyMEwyNi41NzklMkMxNy45NjclMjBDMjguMzQ4JTJDMTcuODA2JTIwMjkuNzA2JTJDMTYuOTM4JTIwMjkuNzA2JTJDMTUuODgyJTIwTDMwLjc2NSUyQzkuNTI5JTIwQzMwLjc2NSUyQzkuNTI5JTIwMjkuNzA2JTJDNy40MTIlMjAyNi41MjklMkM3LjQxMiUyMHolMjIlMjBmaWxsJTNEJTIyJTIzRDZENkQ2JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNMzcuMTE4JTJDNy40MTIlMjBMMzcuMDY5JTJDNy4zNjMlMjBDMzguODg2JTJDNy4xMjUlMjA0MC4yOTQlMkM1LjU4NyUyMDQwLjI5NCUyQzMuNzA2JTIwQzQwLjI5NCUyQzEuNjU5JTIwMzguNjM1JTJDMCUyMDM2LjU4OCUyQzAlMjBDMzQuNTQyJTJDMCUyMDMyLjg4MiUyQzEuNjU5JTIwMzIuODgyJTJDMy43MDYlMjBDMzIuODgyJTJDNS41NzIlMjAzNC4yNjYlMkM3LjA5OSUyMDM2LjA1OSUyQzcuMzU4JTIwTDM2LjA1OSUyQzcuNDEyJTIwQzMyLjg4MiUyQzcuNDEyJTIwMzEuODI0JTJDOS41MjklMjAzMS44MjQlMkM5LjUyOSUyMEwzMi44ODIlMkMxNS44ODIlMjBDMzIuODgyJTJDMTYuOTM4JTIwMzQuMjQlMkMxNy44MDYlMjAzNi4wMDklMkMxNy45NjclMjBMMzYuMDU5JTJDMTglMjBMMzcuMTE4JTJDMTglMjBMMzcuMTY3JTJDMTcuOTY3JTIwQzM4LjkzNyUyQzE3LjgwNiUyMDQwLjI5NCUyQzE2LjkzOCUyMDQwLjI5NCUyQzE1Ljg4MiUyMEw0MS4zNTMlMkM5LjUyOSUyMEM0MS4zNTMlMkM5LjUyOSUyMDQwLjI5NCUyQzcuNDEyJTIwMzcuMTE4JTJDNy40MTIlMjB6JTIyJTIwZmlsbCUzRCUyMiUyM0Q2RDZENiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTTQ3LjcwNiUyQzcuNDEyJTIwTDQ3LjY1NyUyQzcuMzYzJTIwQzQ5LjQ3NCUyQzcuMTI1JTIwNTAuODgyJTJDNS41ODclMjA1MC44ODIlMkMzLjcwNiUyMEM1MC44ODIlMkMxLjY1OSUyMDQ5LjIyMyUyQzAlMjA0Ny4xNzYlMkMwJTIwQzQ1LjEzJTJDMCUyMDQzLjQ3MSUyQzEuNjU5JTIwNDMuNDcxJTJDMy43MDYlMjBDNDMuNDcxJTJDNS41NzIlMjA0NC44NTQlMkM3LjA5OSUyMDQ2LjY0NyUyQzcuMzU4JTIwTDQ2LjY0NyUyQzcuNDEyJTIwQzQzLjQ3MSUyQzcuNDEyJTIwNDIuNDEyJTJDOS41MjklMjA0Mi40MTIlMkM5LjUyOSUyMEw0My40NzElMkMxNS44ODIlMjBDNDMuNDcxJTJDMTYuOTM4JTIwNDQuODI4JTJDMTcuODA2JTIwNDYuNTk3JTJDMTcuOTY3JTIwTDQ2LjY0NyUyQzE4JTIwTDQ3LjcwNiUyQzE4JTIwTDQ3Ljc1NiUyQzE3Ljk2NyUyMEM0OS41MjUlMkMxNy44MDYlMjA1MC44ODIlMkMxNi45MzglMjA1MC44ODIlMkMxNS44ODIlMjBMNTEuOTQxJTJDOS41MjklMjBDNTEuOTQxJTJDOS41MjklMjA1MC44ODIlMkM3LjQxMiUyMDQ3LjcwNiUyQzcuNDEyJTIweiUyMiUyMGZpbGwlM0QlMjIlMjNENkQ2RDYlMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEEpfS5hZGctd290LWNvbmZpZGVuY2UtMXtiYWNrZ3JvdW5kLWltYWdlOnVybChkYXRhOmltYWdlL3N2Zyt4bWwsJTNDJTNGeG1sJTIwdmVyc2lvbiUzRCUyMjEuMCUyMiUyMGVuY29kaW5nJTNEJTIyVVRGLTglMjIlM0YlM0UlMEElM0NzdmclMjB2ZXJzaW9uJTNEJTIyMS4xJTIyJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB2aWV3Qm94JTNEJTIyMCUyMDAlMjA1MiUyMDE4JTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNNS4zNTMlMkM3LjQxMiUyMEw1LjMwNCUyQzcuMzYzJTIwQzcuMTIxJTJDNy4xMjUlMjA4LjUyOSUyQzUuNTg3JTIwOC41MjklMkMzLjcwNiUyMEM4LjUyOSUyQzEuNjU5JTIwNi44NyUyQzAlMjA0LjgyNCUyQzAlMjBDMi43NzclMkMwJTIwMS4xMTglMkMxLjY1OSUyMDEuMTE4JTJDMy43MDYlMjBDMS4xMTglMkM1LjU3MiUyMDIuNTAyJTJDNy4wOTklMjA0LjI5NCUyQzcuMzU4JTIwTDQuMjk0JTJDNy40MTIlMjBDMS4xMTglMkM3LjQxMiUyMDAuMDU5JTJDOS41MjklMjAwLjA1OSUyQzkuNTI5JTIwTDEuMTE4JTJDMTUuODgyJTIwQzEuMTE4JTJDMTYuOTM4JTIwMi40NzUlMkMxNy44MDYlMjA0LjI0NCUyQzE3Ljk2NyUyMEw0LjI5NCUyQzE4JTIwTDUuMzUzJTJDMTglMjBMNS40MDMlMkMxNy45NjclMjBDNy4xNzIlMkMxNy44MDYlMjA4LjUyOSUyQzE2LjkzOCUyMDguNTI5JTJDMTUuODgyJTIwTDkuNTg4JTJDOS41MjklMjBDOS41ODglMkM5LjUyOSUyMDguNTI5JTJDNy40MTIlMjA1LjM1MyUyQzcuNDEyJTIweiUyMiUyMGZpbGwlM0QlMjIlMjM3MTcxNzElMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0xNS45NDElMkM3LjQxMiUyMEwxNS44OTIlMkM3LjM2MyUyMEMxNy43MDklMkM3LjEyNSUyMDE5LjExOCUyQzUuNTg3JTIwMTkuMTE4JTJDMy43MDYlMjBDMTkuMTE4JTJDMS42NTklMjAxNy40NTglMkMwJTIwMTUuNDEyJTJDMCUyMEMxMy4zNjUlMkMwJTIwMTEuNzA2JTJDMS42NTklMjAxMS43MDYlMkMzLjcwNiUyMEMxMS43MDYlMkM1LjU3MiUyMDEzLjA5JTJDNy4wOTklMjAxNC44ODIlMkM3LjM1OCUyMEwxNC44ODIlMkM3LjQxMiUyMEMxMS43MDYlMkM3LjQxMiUyMDEwLjY0NyUyQzkuNTI5JTIwMTAuNjQ3JTJDOS41MjklMjBMMTEuNzA2JTJDMTUuODgyJTIwQzExLjcwNiUyQzE2LjkzOCUyMDEzLjA2MyUyQzE3LjgwNiUyMDE0LjgzMyUyQzE3Ljk2NyUyMEwxNC44ODIlMkMxOCUyMEwxNS45NDElMkMxOCUyMEwxNS45OTElMkMxNy45NjclMjBDMTcuNzYlMkMxNy44MDYlMjAxOS4xMTglMkMxNi45MzglMjAxOS4xMTglMkMxNS44ODIlMjBMMjAuMTc2JTJDOS41MjklMjBDMjAuMTc2JTJDOS41MjklMjAxOS4xMTglMkM3LjQxMiUyMDE1Ljk0MSUyQzcuNDEyJTIweiUyMiUyMGZpbGwlM0QlMjIlMjNENkQ2RDYlMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0yNi41MjklMkM3LjQxMiUyMEwyNi40ODElMkM3LjM2MyUyMEMyOC4yOTglMkM3LjEyNSUyMDI5LjcwNiUyQzUuNTg3JTIwMjkuNzA2JTJDMy43MDYlMjBDMjkuNzA2JTJDMS42NTklMjAyOC4wNDclMkMwJTIwMjYlMkMwJTIwQzIzLjk1MyUyQzAlMjAyMi4yOTQlMkMxLjY1OSUyMDIyLjI5NCUyQzMuNzA2JTIwQzIyLjI5NCUyQzUuNTcyJTIwMjMuNjc4JTJDNy4wOTklMjAyNS40NzElMkM3LjM1OCUyMEwyNS40NzElMkM3LjQxMiUyMEMyMi4yOTQlMkM3LjQxMiUyMDIxLjIzNSUyQzkuNTI5JTIwMjEuMjM1JTJDOS41MjklMjBMMjIuMjk0JTJDMTUuODgyJTIwQzIyLjI5NCUyQzE2LjkzOCUyMDIzLjY1MiUyQzE3LjgwNiUyMDI1LjQyMSUyQzE3Ljk2NyUyMEwyNS40NzElMkMxOCUyMEwyNi41MjklMkMxOCUyMEwyNi41NzklMkMxNy45NjclMjBDMjguMzQ4JTJDMTcuODA2JTIwMjkuNzA2JTJDMTYuOTM4JTIwMjkuNzA2JTJDMTUuODgyJTIwTDMwLjc2NSUyQzkuNTI5JTIwQzMwLjc2NSUyQzkuNTI5JTIwMjkuNzA2JTJDNy40MTIlMjAyNi41MjklMkM3LjQxMiUyMHolMjIlMjBmaWxsJTNEJTIyJTIzRDZENkQ2JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNMzcuMTE4JTJDNy40MTIlMjBMMzcuMDY5JTJDNy4zNjMlMjBDMzguODg2JTJDNy4xMjUlMjA0MC4yOTQlMkM1LjU4NyUyMDQwLjI5NCUyQzMuNzA2JTIwQzQwLjI5NCUyQzEuNjU5JTIwMzguNjM1JTJDMCUyMDM2LjU4OCUyQzAlMjBDMzQuNTQyJTJDMCUyMDMyLjg4MiUyQzEuNjU5JTIwMzIuODgyJTJDMy43MDYlMjBDMzIuODgyJTJDNS41NzIlMjAzNC4yNjYlMkM3LjA5OSUyMDM2LjA1OSUyQzcuMzU4JTIwTDM2LjA1OSUyQzcuNDEyJTIwQzMyLjg4MiUyQzcuNDEyJTIwMzEuODI0JTJDOS41MjklMjAzMS44MjQlMkM5LjUyOSUyMEwzMi44ODIlMkMxNS44ODIlMjBDMzIuODgyJTJDMTYuOTM4JTIwMzQuMjQlMkMxNy44MDYlMjAzNi4wMDklMkMxNy45NjclMjBMMzYuMDU5JTJDMTglMjBMMzcuMTE4JTJDMTglMjBMMzcuMTY3JTJDMTcuOTY3JTIwQzM4LjkzNyUyQzE3LjgwNiUyMDQwLjI5NCUyQzE2LjkzOCUyMDQwLjI5NCUyQzE1Ljg4MiUyMEw0MS4zNTMlMkM5LjUyOSUyMEM0MS4zNTMlMkM5LjUyOSUyMDQwLjI5NCUyQzcuNDEyJTIwMzcuMTE4JTJDNy40MTIlMjB6JTIyJTIwZmlsbCUzRCUyMiUyM0Q2RDZENiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTTQ3LjcwNiUyQzcuNDEyJTIwTDQ3LjY1NyUyQzcuMzYzJTIwQzQ5LjQ3NCUyQzcuMTI1JTIwNTAuODgyJTJDNS41ODclMjA1MC44ODIlMkMzLjcwNiUyMEM1MC44ODIlMkMxLjY1OSUyMDQ5LjIyMyUyQzAlMjA0Ny4xNzYlMkMwJTIwQzQ1LjEzJTJDMCUyMDQzLjQ3MSUyQzEuNjU5JTIwNDMuNDcxJTJDMy43MDYlMjBDNDMuNDcxJTJDNS41NzIlMjA0NC44NTQlMkM3LjA5OSUyMDQ2LjY0NyUyQzcuMzU4JTIwTDQ2LjY0NyUyQzcuNDEyJTIwQzQzLjQ3MSUyQzcuNDEyJTIwNDIuNDEyJTJDOS41MjklMjA0Mi40MTIlMkM5LjUyOSUyMEw0My40NzElMkMxNS44ODIlMjBDNDMuNDcxJTJDMTYuOTM4JTIwNDQuODI4JTJDMTcuODA2JTIwNDYuNTk3JTJDMTcuOTY3JTIwTDQ2LjY0NyUyQzE4JTIwTDQ3LjcwNiUyQzE4JTIwTDQ3Ljc1NiUyQzE3Ljk2NyUyMEM0OS41MjUlMkMxNy44MDYlMjA1MC44ODIlMkMxNi45MzglMjA1MC44ODIlMkMxNS44ODIlMjBMNTEuOTQxJTJDOS41MjklMjBDNTEuOTQxJTJDOS41MjklMjA1MC44ODIlMkM3LjQxMiUyMDQ3LjcwNiUyQzcuNDEyJTIweiUyMiUyMGZpbGwlM0QlMjIlMjNENkQ2RDYlMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEEpfS5hZGctd290LWNvbmZpZGVuY2UtMntiYWNrZ3JvdW5kLWltYWdlOnVybChkYXRhOmltYWdlL3N2Zyt4bWwsJTNDJTNGeG1sJTIwdmVyc2lvbiUzRCUyMjEuMCUyMiUyMGVuY29kaW5nJTNEJTIyVVRGLTglMjIlM0YlM0UlMEElM0NzdmclMjB2ZXJzaW9uJTNEJTIyMS4xJTIyJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB2aWV3Qm94JTNEJTIyMCUyMDAlMjA1MiUyMDE4JTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNNS4zNTMlMkM3LjQxMiUyMEw1LjMwNCUyQzcuMzYzJTIwQzcuMTIxJTJDNy4xMjUlMjA4LjUyOSUyQzUuNTg3JTIwOC41MjklMkMzLjcwNiUyMEM4LjUyOSUyQzEuNjU5JTIwNi44NyUyQzAlMjA0LjgyNCUyQzAlMjBDMi43NzclMkMwJTIwMS4xMTglMkMxLjY1OSUyMDEuMTE4JTJDMy43MDYlMjBDMS4xMTglMkM1LjU3MiUyMDIuNTAyJTJDNy4wOTklMjA0LjI5NCUyQzcuMzU4JTIwTDQuMjk0JTJDNy40MTIlMjBDMS4xMTglMkM3LjQxMiUyMDAuMDU5JTJDOS41MjklMjAwLjA1OSUyQzkuNTI5JTIwTDEuMTE4JTJDMTUuODgyJTIwQzEuMTE4JTJDMTYuOTM4JTIwMi40NzUlMkMxNy44MDYlMjA0LjI0NCUyQzE3Ljk2NyUyMEw0LjI5NCUyQzE4JTIwTDUuMzUzJTJDMTglMjBMNS40MDMlMkMxNy45NjclMjBDNy4xNzIlMkMxNy44MDYlMjA4LjUyOSUyQzE2LjkzOCUyMDguNTI5JTJDMTUuODgyJTIwTDkuNTg4JTJDOS41MjklMjBDOS41ODglMkM5LjUyOSUyMDguNTI5JTJDNy40MTIlMjA1LjM1MyUyQzcuNDEyJTIweiUyMiUyMGZpbGwlM0QlMjIlMjM3MTcxNzElMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0xNS45NDElMkM3LjQxMiUyMEwxNS44OTIlMkM3LjM2MyUyMEMxNy43MDklMkM3LjEyNSUyMDE5LjExOCUyQzUuNTg3JTIwMTkuMTE4JTJDMy43MDYlMjBDMTkuMTE4JTJDMS42NTklMjAxNy40NTglMkMwJTIwMTUuNDEyJTJDMCUyMEMxMy4zNjUlMkMwJTIwMTEuNzA2JTJDMS42NTklMjAxMS43MDYlMkMzLjcwNiUyMEMxMS43MDYlMkM1LjU3MiUyMDEzLjA5JTJDNy4wOTklMjAxNC44ODIlMkM3LjM1OCUyMEwxNC44ODIlMkM3LjQxMiUyMEMxMS43MDYlMkM3LjQxMiUyMDEwLjY0NyUyQzkuNTI5JTIwMTAuNjQ3JTJDOS41MjklMjBMMTEuNzA2JTJDMTUuODgyJTIwQzExLjcwNiUyQzE2LjkzOCUyMDEzLjA2MyUyQzE3LjgwNiUyMDE0LjgzMyUyQzE3Ljk2NyUyMEwxNC44ODIlMkMxOCUyMEwxNS45NDElMkMxOCUyMEwxNS45OTElMkMxNy45NjclMjBDMTcuNzYlMkMxNy44MDYlMjAxOS4xMTglMkMxNi45MzglMjAxOS4xMTglMkMxNS44ODIlMjBMMjAuMTc2JTJDOS41MjklMjBDMjAuMTc2JTJDOS41MjklMjAxOS4xMTglMkM3LjQxMiUyMDE1Ljk0MSUyQzcuNDEyJTIweiUyMiUyMGZpbGwlM0QlMjIlMjM3MTcxNzElMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0yNi41MjklMkM3LjQxMiUyMEwyNi40ODElMkM3LjM2MyUyMEMyOC4yOTglMkM3LjEyNSUyMDI5LjcwNiUyQzUuNTg3JTIwMjkuNzA2JTJDMy43MDYlMjBDMjkuNzA2JTJDMS42NTklMjAyOC4wNDclMkMwJTIwMjYlMkMwJTIwQzIzLjk1MyUyQzAlMjAyMi4yOTQlMkMxLjY1OSUyMDIyLjI5NCUyQzMuNzA2JTIwQzIyLjI5NCUyQzUuNTcyJTIwMjMuNjc4JTJDNy4wOTklMjAyNS40NzElMkM3LjM1OCUyMEwyNS40NzElMkM3LjQxMiUyMEMyMi4yOTQlMkM3LjQxMiUyMDIxLjIzNSUyQzkuNTI5JTIwMjEuMjM1JTJDOS41MjklMjBMMjIuMjk0JTJDMTUuODgyJTIwQzIyLjI5NCUyQzE2LjkzOCUyMDIzLjY1MiUyQzE3LjgwNiUyMDI1LjQyMSUyQzE3Ljk2NyUyMEwyNS40NzElMkMxOCUyMEwyNi41MjklMkMxOCUyMEwyNi41NzklMkMxNy45NjclMjBDMjguMzQ4JTJDMTcuODA2JTIwMjkuNzA2JTJDMTYuOTM4JTIwMjkuNzA2JTJDMTUuODgyJTIwTDMwLjc2NSUyQzkuNTI5JTIwQzMwLjc2NSUyQzkuNTI5JTIwMjkuNzA2JTJDNy40MTIlMjAyNi41MjklMkM3LjQxMiUyMHolMjIlMjBmaWxsJTNEJTIyJTIzRDZENkQ2JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNMzcuMTE4JTJDNy40MTIlMjBMMzcuMDY5JTJDNy4zNjMlMjBDMzguODg2JTJDNy4xMjUlMjA0MC4yOTQlMkM1LjU4NyUyMDQwLjI5NCUyQzMuNzA2JTIwQzQwLjI5NCUyQzEuNjU5JTIwMzguNjM1JTJDMCUyMDM2LjU4OCUyQzAlMjBDMzQuNTQyJTJDMCUyMDMyLjg4MiUyQzEuNjU5JTIwMzIuODgyJTJDMy43MDYlMjBDMzIuODgyJTJDNS41NzIlMjAzNC4yNjYlMkM3LjA5OSUyMDM2LjA1OSUyQzcuMzU4JTIwTDM2LjA1OSUyQzcuNDEyJTIwQzMyLjg4MiUyQzcuNDEyJTIwMzEuODI0JTJDOS41MjklMjAzMS44MjQlMkM5LjUyOSUyMEwzMi44ODIlMkMxNS44ODIlMjBDMzIuODgyJTJDMTYuOTM4JTIwMzQuMjQlMkMxNy44MDYlMjAzNi4wMDklMkMxNy45NjclMjBMMzYuMDU5JTJDMTglMjBMMzcuMTE4JTJDMTglMjBMMzcuMTY3JTJDMTcuOTY3JTIwQzM4LjkzNyUyQzE3LjgwNiUyMDQwLjI5NCUyQzE2LjkzOCUyMDQwLjI5NCUyQzE1Ljg4MiUyMEw0MS4zNTMlMkM5LjUyOSUyMEM0MS4zNTMlMkM5LjUyOSUyMDQwLjI5NCUyQzcuNDEyJTIwMzcuMTE4JTJDNy40MTIlMjB6JTIyJTIwZmlsbCUzRCUyMiUyM0Q2RDZENiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTTQ3LjcwNiUyQzcuNDEyJTIwTDQ3LjY1NyUyQzcuMzYzJTIwQzQ5LjQ3NCUyQzcuMTI1JTIwNTAuODgyJTJDNS41ODclMjA1MC44ODIlMkMzLjcwNiUyMEM1MC44ODIlMkMxLjY1OSUyMDQ5LjIyMyUyQzAlMjA0Ny4xNzYlMkMwJTIwQzQ1LjEzJTJDMCUyMDQzLjQ3MSUyQzEuNjU5JTIwNDMuNDcxJTJDMy43MDYlMjBDNDMuNDcxJTJDNS41NzIlMjA0NC44NTQlMkM3LjA5OSUyMDQ2LjY0NyUyQzcuMzU4JTIwTDQ2LjY0NyUyQzcuNDEyJTIwQzQzLjQ3MSUyQzcuNDEyJTIwNDIuNDEyJTJDOS41MjklMjA0Mi40MTIlMkM5LjUyOSUyMEw0My40NzElMkMxNS44ODIlMjBDNDMuNDcxJTJDMTYuOTM4JTIwNDQuODI4JTJDMTcuODA2JTIwNDYuNTk3JTJDMTcuOTY3JTIwTDQ2LjY0NyUyQzE4JTIwTDQ3LjcwNiUyQzE4JTIwTDQ3Ljc1NiUyQzE3Ljk2NyUyMEM0OS41MjUlMkMxNy44MDYlMjA1MC44ODIlMkMxNi45MzglMjA1MC44ODIlMkMxNS44ODIlMjBMNTEuOTQxJTJDOS41MjklMjBDNTEuOTQxJTJDOS41MjklMjA1MC44ODIlMkM3LjQxMiUyMDQ3LjcwNiUyQzcuNDEyJTIweiUyMiUyMGZpbGwlM0QlMjIlMjNENkQ2RDYlMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEEpfS5hZGctd290LWNvbmZpZGVuY2UtM3tiYWNrZ3JvdW5kLWltYWdlOnVybChkYXRhOmltYWdlL3N2Zyt4bWwsJTNDJTNGeG1sJTIwdmVyc2lvbiUzRCUyMjEuMCUyMiUyMGVuY29kaW5nJTNEJTIyVVRGLTglMjIlM0YlM0UlMEElM0NzdmclMjB2ZXJzaW9uJTNEJTIyMS4xJTIyJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB2aWV3Qm94JTNEJTIyMCUyMDAlMjA1MiUyMDE4JTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNNS4zNTMlMkM3LjQxMiUyMEw1LjMwNCUyQzcuMzYzJTIwQzcuMTIxJTJDNy4xMjUlMjA4LjUyOSUyQzUuNTg3JTIwOC41MjklMkMzLjcwNiUyMEM4LjUyOSUyQzEuNjU5JTIwNi44NyUyQzAlMjA0LjgyNCUyQzAlMjBDMi43NzclMkMwJTIwMS4xMTglMkMxLjY1OSUyMDEuMTE4JTJDMy43MDYlMjBDMS4xMTglMkM1LjU3MiUyMDIuNTAyJTJDNy4wOTklMjA0LjI5NCUyQzcuMzU4JTIwTDQuMjk0JTJDNy40MTIlMjBDMS4xMTglMkM3LjQxMiUyMDAuMDU5JTJDOS41MjklMjAwLjA1OSUyQzkuNTI5JTIwTDEuMTE4JTJDMTUuODgyJTIwQzEuMTE4JTJDMTYuOTM4JTIwMi40NzUlMkMxNy44MDYlMjA0LjI0NCUyQzE3Ljk2NyUyMEw0LjI5NCUyQzE4JTIwTDUuMzUzJTJDMTglMjBMNS40MDMlMkMxNy45NjclMjBDNy4xNzIlMkMxNy44MDYlMjA4LjUyOSUyQzE2LjkzOCUyMDguNTI5JTJDMTUuODgyJTIwTDkuNTg4JTJDOS41MjklMjBDOS41ODglMkM5LjUyOSUyMDguNTI5JTJDNy40MTIlMjA1LjM1MyUyQzcuNDEyJTIweiUyMiUyMGZpbGwlM0QlMjIlMjM3MTcxNzElMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0xNS45NDElMkM3LjQxMiUyMEwxNS44OTIlMkM3LjM2MyUyMEMxNy43MDklMkM3LjEyNSUyMDE5LjExOCUyQzUuNTg3JTIwMTkuMTE4JTJDMy43MDYlMjBDMTkuMTE4JTJDMS42NTklMjAxNy40NTglMkMwJTIwMTUuNDEyJTJDMCUyMEMxMy4zNjUlMkMwJTIwMTEuNzA2JTJDMS42NTklMjAxMS43MDYlMkMzLjcwNiUyMEMxMS43MDYlMkM1LjU3MiUyMDEzLjA5JTJDNy4wOTklMjAxNC44ODIlMkM3LjM1OCUyMEwxNC44ODIlMkM3LjQxMiUyMEMxMS43MDYlMkM3LjQxMiUyMDEwLjY0NyUyQzkuNTI5JTIwMTAuNjQ3JTJDOS41MjklMjBMMTEuNzA2JTJDMTUuODgyJTIwQzExLjcwNiUyQzE2LjkzOCUyMDEzLjA2MyUyQzE3LjgwNiUyMDE0LjgzMyUyQzE3Ljk2NyUyMEwxNC44ODIlMkMxOCUyMEwxNS45NDElMkMxOCUyMEwxNS45OTElMkMxNy45NjclMjBDMTcuNzYlMkMxNy44MDYlMjAxOS4xMTglMkMxNi45MzglMjAxOS4xMTglMkMxNS44ODIlMjBMMjAuMTc2JTJDOS41MjklMjBDMjAuMTc2JTJDOS41MjklMjAxOS4xMTglMkM3LjQxMiUyMDE1Ljk0MSUyQzcuNDEyJTIweiUyMiUyMGZpbGwlM0QlMjIlMjM3MTcxNzElMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0yNi41MjklMkM3LjQxMiUyMEwyNi40ODElMkM3LjM2MyUyMEMyOC4yOTglMkM3LjEyNSUyMDI5LjcwNiUyQzUuNTg3JTIwMjkuNzA2JTJDMy43MDYlMjBDMjkuNzA2JTJDMS42NTklMjAyOC4wNDclMkMwJTIwMjYlMkMwJTIwQzIzLjk1MyUyQzAlMjAyMi4yOTQlMkMxLjY1OSUyMDIyLjI5NCUyQzMuNzA2JTIwQzIyLjI5NCUyQzUuNTcyJTIwMjMuNjc4JTJDNy4wOTklMjAyNS40NzElMkM3LjM1OCUyMEwyNS40NzElMkM3LjQxMiUyMEMyMi4yOTQlMkM3LjQxMiUyMDIxLjIzNSUyQzkuNTI5JTIwMjEuMjM1JTJDOS41MjklMjBMMjIuMjk0JTJDMTUuODgyJTIwQzIyLjI5NCUyQzE2LjkzOCUyMDIzLjY1MiUyQzE3LjgwNiUyMDI1LjQyMSUyQzE3Ljk2NyUyMEwyNS40NzElMkMxOCUyMEwyNi41MjklMkMxOCUyMEwyNi41NzklMkMxNy45NjclMjBDMjguMzQ4JTJDMTcuODA2JTIwMjkuNzA2JTJDMTYuOTM4JTIwMjkuNzA2JTJDMTUuODgyJTIwTDMwLjc2NSUyQzkuNTI5JTIwQzMwLjc2NSUyQzkuNTI5JTIwMjkuNzA2JTJDNy40MTIlMjAyNi41MjklMkM3LjQxMiUyMHolMjIlMjBmaWxsJTNEJTIyJTIzNzE3MTcxJTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNMzcuMTE4JTJDNy40MTIlMjBMMzcuMDY5JTJDNy4zNjMlMjBDMzguODg2JTJDNy4xMjUlMjA0MC4yOTQlMkM1LjU4NyUyMDQwLjI5NCUyQzMuNzA2JTIwQzQwLjI5NCUyQzEuNjU5JTIwMzguNjM1JTJDMCUyMDM2LjU4OCUyQzAlMjBDMzQuNTQyJTJDMCUyMDMyLjg4MiUyQzEuNjU5JTIwMzIuODgyJTJDMy43MDYlMjBDMzIuODgyJTJDNS41NzIlMjAzNC4yNjYlMkM3LjA5OSUyMDM2LjA1OSUyQzcuMzU4JTIwTDM2LjA1OSUyQzcuNDEyJTIwQzMyLjg4MiUyQzcuNDEyJTIwMzEuODI0JTJDOS41MjklMjAzMS44MjQlMkM5LjUyOSUyMEwzMi44ODIlMkMxNS44ODIlMjBDMzIuODgyJTJDMTYuOTM4JTIwMzQuMjQlMkMxNy44MDYlMjAzNi4wMDklMkMxNy45NjclMjBMMzYuMDU5JTJDMTglMjBMMzcuMTE4JTJDMTglMjBMMzcuMTY3JTJDMTcuOTY3JTIwQzM4LjkzNyUyQzE3LjgwNiUyMDQwLjI5NCUyQzE2LjkzOCUyMDQwLjI5NCUyQzE1Ljg4MiUyMEw0MS4zNTMlMkM5LjUyOSUyMEM0MS4zNTMlMkM5LjUyOSUyMDQwLjI5NCUyQzcuNDEyJTIwMzcuMTE4JTJDNy40MTIlMjB6JTIyJTIwZmlsbCUzRCUyMiUyM0Q2RDZENiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTTQ3LjcwNiUyQzcuNDEyJTIwTDQ3LjY1NyUyQzcuMzYzJTIwQzQ5LjQ3NCUyQzcuMTI1JTIwNTAuODgyJTJDNS41ODclMjA1MC44ODIlMkMzLjcwNiUyMEM1MC44ODIlMkMxLjY1OSUyMDQ5LjIyMyUyQzAlMjA0Ny4xNzYlMkMwJTIwQzQ1LjEzJTJDMCUyMDQzLjQ3MSUyQzEuNjU5JTIwNDMuNDcxJTJDMy43MDYlMjBDNDMuNDcxJTJDNS41NzIlMjA0NC44NTQlMkM3LjA5OSUyMDQ2LjY0NyUyQzcuMzU4JTIwTDQ2LjY0NyUyQzcuNDEyJTIwQzQzLjQ3MSUyQzcuNDEyJTIwNDIuNDEyJTJDOS41MjklMjA0Mi40MTIlMkM5LjUyOSUyMEw0My40NzElMkMxNS44ODIlMjBDNDMuNDcxJTJDMTYuOTM4JTIwNDQuODI4JTJDMTcuODA2JTIwNDYuNTk3JTJDMTcuOTY3JTIwTDQ2LjY0NyUyQzE4JTIwTDQ3LjcwNiUyQzE4JTIwTDQ3Ljc1NiUyQzE3Ljk2NyUyMEM0OS41MjUlMkMxNy44MDYlMjA1MC44ODIlMkMxNi45MzglMjA1MC44ODIlMkMxNS44ODIlMjBMNTEuOTQxJTJDOS41MjklMjBDNTEuOTQxJTJDOS41MjklMjA1MC44ODIlMkM3LjQxMiUyMDQ3LjcwNiUyQzcuNDEyJTIweiUyMiUyMGZpbGwlM0QlMjIlMjNENkQ2RDYlMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEEpfS5hZGctd290LWNvbmZpZGVuY2UtNHtiYWNrZ3JvdW5kLWltYWdlOnVybChkYXRhOmltYWdlL3N2Zyt4bWwsJTNDJTNGeG1sJTIwdmVyc2lvbiUzRCUyMjEuMCUyMiUyMGVuY29kaW5nJTNEJTIyVVRGLTglMjIlM0YlM0UlMEElM0NzdmclMjB2ZXJzaW9uJTNEJTIyMS4xJTIyJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB2aWV3Qm94JTNEJTIyMCUyMDAlMjA1MiUyMDE4JTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNNS4zNTMlMkM3LjQxMiUyMEw1LjMwNCUyQzcuMzYzJTIwQzcuMTIxJTJDNy4xMjUlMjA4LjUyOSUyQzUuNTg3JTIwOC41MjklMkMzLjcwNiUyMEM4LjUyOSUyQzEuNjU5JTIwNi44NyUyQzAlMjA0LjgyNCUyQzAlMjBDMi43NzclMkMwJTIwMS4xMTglMkMxLjY1OSUyMDEuMTE4JTJDMy43MDYlMjBDMS4xMTglMkM1LjU3MiUyMDIuNTAyJTJDNy4wOTklMjA0LjI5NCUyQzcuMzU4JTIwTDQuMjk0JTJDNy40MTIlMjBDMS4xMTglMkM3LjQxMiUyMDAuMDU5JTJDOS41MjklMjAwLjA1OSUyQzkuNTI5JTIwTDEuMTE4JTJDMTUuODgyJTIwQzEuMTE4JTJDMTYuOTM4JTIwMi40NzUlMkMxNy44MDYlMjA0LjI0NCUyQzE3Ljk2NyUyMEw0LjI5NCUyQzE4JTIwTDUuMzUzJTJDMTglMjBMNS40MDMlMkMxNy45NjclMjBDNy4xNzIlMkMxNy44MDYlMjA4LjUyOSUyQzE2LjkzOCUyMDguNTI5JTJDMTUuODgyJTIwTDkuNTg4JTJDOS41MjklMjBDOS41ODglMkM5LjUyOSUyMDguNTI5JTJDNy40MTIlMjA1LjM1MyUyQzcuNDEyJTIweiUyMiUyMGZpbGwlM0QlMjIlMjM3MTcxNzElMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0xNS45NDElMkM3LjQxMiUyMEwxNS44OTIlMkM3LjM2MyUyMEMxNy43MDklMkM3LjEyNSUyMDE5LjExOCUyQzUuNTg3JTIwMTkuMTE4JTJDMy43MDYlMjBDMTkuMTE4JTJDMS42NTklMjAxNy40NTglMkMwJTIwMTUuNDEyJTJDMCUyMEMxMy4zNjUlMkMwJTIwMTEuNzA2JTJDMS42NTklMjAxMS43MDYlMkMzLjcwNiUyMEMxMS43MDYlMkM1LjU3MiUyMDEzLjA5JTJDNy4wOTklMjAxNC44ODIlMkM3LjM1OCUyMEwxNC44ODIlMkM3LjQxMiUyMEMxMS43MDYlMkM3LjQxMiUyMDEwLjY0NyUyQzkuNTI5JTIwMTAuNjQ3JTJDOS41MjklMjBMMTEuNzA2JTJDMTUuODgyJTIwQzExLjcwNiUyQzE2LjkzOCUyMDEzLjA2MyUyQzE3LjgwNiUyMDE0LjgzMyUyQzE3Ljk2NyUyMEwxNC44ODIlMkMxOCUyMEwxNS45NDElMkMxOCUyMEwxNS45OTElMkMxNy45NjclMjBDMTcuNzYlMkMxNy44MDYlMjAxOS4xMTglMkMxNi45MzglMjAxOS4xMTglMkMxNS44ODIlMjBMMjAuMTc2JTJDOS41MjklMjBDMjAuMTc2JTJDOS41MjklMjAxOS4xMTglMkM3LjQxMiUyMDE1Ljk0MSUyQzcuNDEyJTIweiUyMiUyMGZpbGwlM0QlMjIlMjM3MTcxNzElMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0yNi41MjklMkM3LjQxMiUyMEwyNi40ODElMkM3LjM2MyUyMEMyOC4yOTglMkM3LjEyNSUyMDI5LjcwNiUyQzUuNTg3JTIwMjkuNzA2JTJDMy43MDYlMjBDMjkuNzA2JTJDMS42NTklMjAyOC4wNDclMkMwJTIwMjYlMkMwJTIwQzIzLjk1MyUyQzAlMjAyMi4yOTQlMkMxLjY1OSUyMDIyLjI5NCUyQzMuNzA2JTIwQzIyLjI5NCUyQzUuNTcyJTIwMjMuNjc4JTJDNy4wOTklMjAyNS40NzElMkM3LjM1OCUyMEwyNS40NzElMkM3LjQxMiUyMEMyMi4yOTQlMkM3LjQxMiUyMDIxLjIzNSUyQzkuNTI5JTIwMjEuMjM1JTJDOS41MjklMjBMMjIuMjk0JTJDMTUuODgyJTIwQzIyLjI5NCUyQzE2LjkzOCUyMDIzLjY1MiUyQzE3LjgwNiUyMDI1LjQyMSUyQzE3Ljk2NyUyMEwyNS40NzElMkMxOCUyMEwyNi41MjklMkMxOCUyMEwyNi41NzklMkMxNy45NjclMjBDMjguMzQ4JTJDMTcuODA2JTIwMjkuNzA2JTJDMTYuOTM4JTIwMjkuNzA2JTJDMTUuODgyJTIwTDMwLjc2NSUyQzkuNTI5JTIwQzMwLjc2NSUyQzkuNTI5JTIwMjkuNzA2JTJDNy40MTIlMjAyNi41MjklMkM3LjQxMiUyMHolMjIlMjBmaWxsJTNEJTIyJTIzNzE3MTcxJTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNMzcuMTE4JTJDNy40MTIlMjBMMzcuMDY5JTJDNy4zNjMlMjBDMzguODg2JTJDNy4xMjUlMjA0MC4yOTQlMkM1LjU4NyUyMDQwLjI5NCUyQzMuNzA2JTIwQzQwLjI5NCUyQzEuNjU5JTIwMzguNjM1JTJDMCUyMDM2LjU4OCUyQzAlMjBDMzQuNTQyJTJDMCUyMDMyLjg4MiUyQzEuNjU5JTIwMzIuODgyJTJDMy43MDYlMjBDMzIuODgyJTJDNS41NzIlMjAzNC4yNjYlMkM3LjA5OSUyMDM2LjA1OSUyQzcuMzU4JTIwTDM2LjA1OSUyQzcuNDEyJTIwQzMyLjg4MiUyQzcuNDEyJTIwMzEuODI0JTJDOS41MjklMjAzMS44MjQlMkM5LjUyOSUyMEwzMi44ODIlMkMxNS44ODIlMjBDMzIuODgyJTJDMTYuOTM4JTIwMzQuMjQlMkMxNy44MDYlMjAzNi4wMDklMkMxNy45NjclMjBMMzYuMDU5JTJDMTglMjBMMzcuMTE4JTJDMTglMjBMMzcuMTY3JTJDMTcuOTY3JTIwQzM4LjkzNyUyQzE3LjgwNiUyMDQwLjI5NCUyQzE2LjkzOCUyMDQwLjI5NCUyQzE1Ljg4MiUyMEw0MS4zNTMlMkM5LjUyOSUyMEM0MS4zNTMlMkM5LjUyOSUyMDQwLjI5NCUyQzcuNDEyJTIwMzcuMTE4JTJDNy40MTIlMjB6JTIyJTIwZmlsbCUzRCUyMiUyMzcxNzE3MSUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTTQ3LjcwNiUyQzcuNDEyJTIwTDQ3LjY1NyUyQzcuMzYzJTIwQzQ5LjQ3NCUyQzcuMTI1JTIwNTAuODgyJTJDNS41ODclMjA1MC44ODIlMkMzLjcwNiUyMEM1MC44ODIlMkMxLjY1OSUyMDQ5LjIyMyUyQzAlMjA0Ny4xNzYlMkMwJTIwQzQ1LjEzJTJDMCUyMDQzLjQ3MSUyQzEuNjU5JTIwNDMuNDcxJTJDMy43MDYlMjBDNDMuNDcxJTJDNS41NzIlMjA0NC44NTQlMkM3LjA5OSUyMDQ2LjY0NyUyQzcuMzU4JTIwTDQ2LjY0NyUyQzcuNDEyJTIwQzQzLjQ3MSUyQzcuNDEyJTIwNDIuNDEyJTJDOS41MjklMjA0Mi40MTIlMkM5LjUyOSUyMEw0My40NzElMkMxNS44ODIlMjBDNDMuNDcxJTJDMTYuOTM4JTIwNDQuODI4JTJDMTcuODA2JTIwNDYuNTk3JTJDMTcuOTY3JTIwTDQ2LjY0NyUyQzE4JTIwTDQ3LjcwNiUyQzE4JTIwTDQ3Ljc1NiUyQzE3Ljk2NyUyMEM0OS41MjUlMkMxNy44MDYlMjA1MC44ODIlMkMxNi45MzglMjA1MC44ODIlMkMxNS44ODIlMjBMNTEuOTQxJTJDOS41MjklMjBDNTEuOTQxJTJDOS41MjklMjA1MC44ODIlMkM3LjQxMiUyMDQ3LjcwNiUyQzcuNDEyJTIweiUyMiUyMGZpbGwlM0QlMjIlMjNENkQ2RDYlMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEEpfS5hZGctd290LWNvbmZpZGVuY2UtNXtiYWNrZ3JvdW5kLWltYWdlOnVybChkYXRhOmltYWdlL3N2Zyt4bWwsJTNDJTNGeG1sJTIwdmVyc2lvbiUzRCUyMjEuMCUyMiUyMGVuY29kaW5nJTNEJTIyVVRGLTglMjIlM0YlM0UlMEElM0NzdmclMjB2ZXJzaW9uJTNEJTIyMS4xJTIyJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB2aWV3Qm94JTNEJTIyMCUyMDAlMjA1MiUyMDE4JTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNNS4zNTMlMkM3LjQxMiUyMEw1LjMwNCUyQzcuMzYzJTIwQzcuMTIxJTJDNy4xMjUlMjA4LjUyOSUyQzUuNTg3JTIwOC41MjklMkMzLjcwNiUyMEM4LjUyOSUyQzEuNjU5JTIwNi44NyUyQzAlMjA0LjgyNCUyQzAlMjBDMi43NzclMkMwJTIwMS4xMTglMkMxLjY1OSUyMDEuMTE4JTJDMy43MDYlMjBDMS4xMTglMkM1LjU3MiUyMDIuNTAyJTJDNy4wOTklMjA0LjI5NCUyQzcuMzU4JTIwTDQuMjk0JTJDNy40MTIlMjBDMS4xMTglMkM3LjQxMiUyMDAuMDU5JTJDOS41MjklMjAwLjA1OSUyQzkuNTI5JTIwTDEuMTE4JTJDMTUuODgyJTIwQzEuMTE4JTJDMTYuOTM4JTIwMi40NzUlMkMxNy44MDYlMjA0LjI0NCUyQzE3Ljk2NyUyMEw0LjI5NCUyQzE4JTIwTDUuMzUzJTJDMTglMjBMNS40MDMlMkMxNy45NjclMjBDNy4xNzIlMkMxNy44MDYlMjA4LjUyOSUyQzE2LjkzOCUyMDguNTI5JTJDMTUuODgyJTIwTDkuNTg4JTJDOS41MjklMjBDOS41ODglMkM5LjUyOSUyMDguNTI5JTJDNy40MTIlMjA1LjM1MyUyQzcuNDEyJTIweiUyMiUyMGZpbGwlM0QlMjIlMjM3MTcxNzElMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0xNS45NDElMkM3LjQxMiUyMEwxNS44OTIlMkM3LjM2MyUyMEMxNy43MDklMkM3LjEyNSUyMDE5LjExOCUyQzUuNTg3JTIwMTkuMTE4JTJDMy43MDYlMjBDMTkuMTE4JTJDMS42NTklMjAxNy40NTglMkMwJTIwMTUuNDEyJTJDMCUyMEMxMy4zNjUlMkMwJTIwMTEuNzA2JTJDMS42NTklMjAxMS43MDYlMkMzLjcwNiUyMEMxMS43MDYlMkM1LjU3MiUyMDEzLjA5JTJDNy4wOTklMjAxNC44ODIlMkM3LjM1OCUyMEwxNC44ODIlMkM3LjQxMiUyMEMxMS43MDYlMkM3LjQxMiUyMDEwLjY0NyUyQzkuNTI5JTIwMTAuNjQ3JTJDOS41MjklMjBMMTEuNzA2JTJDMTUuODgyJTIwQzExLjcwNiUyQzE2LjkzOCUyMDEzLjA2MyUyQzE3LjgwNiUyMDE0LjgzMyUyQzE3Ljk2NyUyMEwxNC44ODIlMkMxOCUyMEwxNS45NDElMkMxOCUyMEwxNS45OTElMkMxNy45NjclMjBDMTcuNzYlMkMxNy44MDYlMjAxOS4xMTglMkMxNi45MzglMjAxOS4xMTglMkMxNS44ODIlMjBMMjAuMTc2JTJDOS41MjklMjBDMjAuMTc2JTJDOS41MjklMjAxOS4xMTglMkM3LjQxMiUyMDE1Ljk0MSUyQzcuNDEyJTIweiUyMiUyMGZpbGwlM0QlMjIlMjM3MTcxNzElMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0yNi41MjklMkM3LjQxMiUyMEwyNi40ODElMkM3LjM2MyUyMEMyOC4yOTglMkM3LjEyNSUyMDI5LjcwNiUyQzUuNTg3JTIwMjkuNzA2JTJDMy43MDYlMjBDMjkuNzA2JTJDMS42NTklMjAyOC4wNDclMkMwJTIwMjYlMkMwJTIwQzIzLjk1MyUyQzAlMjAyMi4yOTQlMkMxLjY1OSUyMDIyLjI5NCUyQzMuNzA2JTIwQzIyLjI5NCUyQzUuNTcyJTIwMjMuNjc4JTJDNy4wOTklMjAyNS40NzElMkM3LjM1OCUyMEwyNS40NzElMkM3LjQxMiUyMEMyMi4yOTQlMkM3LjQxMiUyMDIxLjIzNSUyQzkuNTI5JTIwMjEuMjM1JTJDOS41MjklMjBMMjIuMjk0JTJDMTUuODgyJTIwQzIyLjI5NCUyQzE2LjkzOCUyMDIzLjY1MiUyQzE3LjgwNiUyMDI1LjQyMSUyQzE3Ljk2NyUyMEwyNS40NzElMkMxOCUyMEwyNi41MjklMkMxOCUyMEwyNi41NzklMkMxNy45NjclMjBDMjguMzQ4JTJDMTcuODA2JTIwMjkuNzA2JTJDMTYuOTM4JTIwMjkuNzA2JTJDMTUuODgyJTIwTDMwLjc2NSUyQzkuNTI5JTIwQzMwLjc2NSUyQzkuNTI5JTIwMjkuNzA2JTJDNy40MTIlMjAyNi41MjklMkM3LjQxMiUyMHolMjIlMjBmaWxsJTNEJTIyJTIzNzE3MTcxJTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNMzcuMTE4JTJDNy40MTIlMjBMMzcuMDY5JTJDNy4zNjMlMjBDMzguODg2JTJDNy4xMjUlMjA0MC4yOTQlMkM1LjU4NyUyMDQwLjI5NCUyQzMuNzA2JTIwQzQwLjI5NCUyQzEuNjU5JTIwMzguNjM1JTJDMCUyMDM2LjU4OCUyQzAlMjBDMzQuNTQyJTJDMCUyMDMyLjg4MiUyQzEuNjU5JTIwMzIuODgyJTJDMy43MDYlMjBDMzIuODgyJTJDNS41NzIlMjAzNC4yNjYlMkM3LjA5OSUyMDM2LjA1OSUyQzcuMzU4JTIwTDM2LjA1OSUyQzcuNDEyJTIwQzMyLjg4MiUyQzcuNDEyJTIwMzEuODI0JTJDOS41MjklMjAzMS44MjQlMkM5LjUyOSUyMEwzMi44ODIlMkMxNS44ODIlMjBDMzIuODgyJTJDMTYuOTM4JTIwMzQuMjQlMkMxNy44MDYlMjAzNi4wMDklMkMxNy45NjclMjBMMzYuMDU5JTJDMTglMjBMMzcuMTE4JTJDMTglMjBMMzcuMTY3JTJDMTcuOTY3JTIwQzM4LjkzNyUyQzE3LjgwNiUyMDQwLjI5NCUyQzE2LjkzOCUyMDQwLjI5NCUyQzE1Ljg4MiUyMEw0MS4zNTMlMkM5LjUyOSUyMEM0MS4zNTMlMkM5LjUyOSUyMDQwLjI5NCUyQzcuNDEyJTIwMzcuMTE4JTJDNy40MTIlMjB6JTIyJTIwZmlsbCUzRCUyMiUyMzcxNzE3MSUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTTQ3LjcwNiUyQzcuNDEyJTIwTDQ3LjY1NyUyQzcuMzYzJTIwQzQ5LjQ3NCUyQzcuMTI1JTIwNTAuODgyJTJDNS41ODclMjA1MC44ODIlMkMzLjcwNiUyMEM1MC44ODIlMkMxLjY1OSUyMDQ5LjIyMyUyQzAlMjA0Ny4xNzYlMkMwJTIwQzQ1LjEzJTJDMCUyMDQzLjQ3MSUyQzEuNjU5JTIwNDMuNDcxJTJDMy43MDYlMjBDNDMuNDcxJTJDNS41NzIlMjA0NC44NTQlMkM3LjA5OSUyMDQ2LjY0NyUyQzcuMzU4JTIwTDQ2LjY0NyUyQzcuNDEyJTIwQzQzLjQ3MSUyQzcuNDEyJTIwNDIuNDEyJTJDOS41MjklMjA0Mi40MTIlMkM5LjUyOSUyMEw0My40NzElMkMxNS44ODIlMjBDNDMuNDcxJTJDMTYuOTM4JTIwNDQuODI4JTJDMTcuODA2JTIwNDYuNTk3JTJDMTcuOTY3JTIwTDQ2LjY0NyUyQzE4JTIwTDQ3LjcwNiUyQzE4JTIwTDQ3Ljc1NiUyQzE3Ljk2NyUyMEM0OS41MjUlMkMxNy44MDYlMjA1MC44ODIlMkMxNi45MzglMjA1MC44ODIlMkMxNS44ODIlMjBMNTEuOTQxJTJDOS41MjklMjBDNTEuOTQxJTJDOS41MjklMjA1MC44ODIlMkM3LjQxMiUyMDQ3LjcwNiUyQzcuNDEyJTIweiUyMiUyMGZpbGwlM0QlMjIlMjM3MTcxNzElMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEEpfS5jb25maWRlbmNlLWluZGljYXRpb24sLndvdC1pbmRpY2F0b3J7dGV4dC1kZWNvcmF0aW9uOm5vbmV9LmNvbmZpZGVuY2UtaW5kaWNhdGlvbjpob3Zlciwud290LWluZGljYXRvcjpob3Zlcnt0ZXh0LWRlY29yYXRpb246bm9uZX0ud290LWxvZ297ZGlzcGxheTppbmxpbmUtYmxvY2s7dmVydGljYWwtYWxpZ246dG9wO3dpZHRoOjMxcHg7aGVpZ2h0OjEycHg7YmFja2dyb3VuZDp1cmwoZGF0YTppbWFnZS9zdmcreG1sLCUzQyUzRnhtbCUyMHZlcnNpb24lM0QlMjIxLjAlMjIlMjBlbmNvZGluZyUzRCUyMlVURi04JTIyJTNGJTNFJTBBJTNDc3ZnJTIwdmVyc2lvbiUzRCUyMjEuMSUyMiUyMHhtbG5zJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYyMDAwJTJGc3ZnJTIyJTIwdmlld0JveCUzRCUyMjAlMjAwJTIwMzglMjAxNSUyMiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTTIxLjkxJTJDMS4wODMlMjBDMTguMDA4JTJDMS4wODMlMjAxNC44NDYlMkM0LjA3JTIwMTQuODQ2JTJDNy43NTglMjBDMTQuODQ2JTJDMTEuNDQ1JTIwMTguMDA4JTJDMTQuNDMyJTIwMjEuOTElMkMxNC40MzIlMjBDMjUuODEzJTJDMTQuNDMyJTIwMjguOTc3JTJDMTEuNDQ1JTIwMjguOTc3JTJDNy43NTglMjBDMjguOTc4JTJDNC4wNyUyMDI1LjgxMyUyQzEuMDgzJTIwMjEuOTElMkMxLjA4MyUyMHolMjBNMjEuNzcxJTJDMTEuOSUyMEMxOS41JTJDMTEuOSUyMDE3LjY1NyUyQzEwLjA1NiUyMDE3LjY1NyUyQzcuNzgzJTIwQzE3LjY1NyUyQzUuNTA4JTIwMTkuNTAxJTJDMy42NjQlMjAyMS43NzElMkMzLjY2NCUyMEMyNC4wNDUlMkMzLjY2NCUyMDI1Ljg4NiUyQzUuNTA4JTIwMjUuODg2JTJDNy43ODMlMjBDMjUuODg2JTJDMTAuMDU3JTIwMjQuMDQ1JTJDMTEuOSUyMDIxLjc3MSUyQzExLjklMjB6JTIyJTIwZmlsbCUzRCUyMiUyMzc0QjAzRSUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTTE2Ljc1MSUyQzAuNjQyJTIwTDE3LjAzMSUyQzAlMjBMMTQuMDYzJTJDMCUyMEwxMS4yNyUyQzglMjBMOC42NDglMkMwJTIwTDguMjcyJTJDMCUyMEw1LjY1JTJDOCUyMEwzJTJDMCUyMEwwLjAzMSUyQzAlMjBMNC45JTJDMTMuNDg2JTIwQzQuOSUyQzEzLjQ4NiUyMDUuMDc4JTJDMTMuODYlMjA1LjI3NSUyQzEzLjg2JTIwQzUuNDUxJTJDMTMuODYlMjA1LjY0OSUyQzEzLjQ4NiUyMDUuNjQ5JTJDMTMuNDg2JTIwTDguNDQ1JTJDNi40MDYlMjBMMTEuMjY5JTJDMTMuNDg2JTIwQzExLjI2OSUyQzEzLjQ4NiUyMDExLjQ1NSUyQzEzLjg2JTIwMTEuNjQzJTJDMTMuODYlMjBDMTEuODI5JTJDMTMuODYlMjAxMi4wMTglMkMxMy40ODYlMjAxMi4wMTglMkMxMy40ODYlMjBMMTMuNjE0JTJDOS4wNjclMjBDMTMuNDQ1JTJDOC40MzMlMjAxMy4zNDUlMkM3Ljc3MyUyMDEzLjM0NSUyQzcuMDg5JTIwQzEzLjM0NiUyQzQuNDUzJTIwMTQuNjg2JTJDMi4xMTglMjAxNi43NTElMkMwLjY0MiUyMHolMjIlMjBmaWxsJTNEJTIyJTIzRUUzNDI4JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNMjcuMDMxJTJDMCUyMEwyNy4wMzElMkMwLjYxMyUyMEMyNy45NDQlMkMxLjI1OCUyMDI4LjcxNSUyQzIuMDY3JTIwMjkuMjk1JTJDMyUyMEwzMS4wMzElMkMzJTIwTDMxLjAzMSUyQzE0JTIwTDM0LjAzMSUyQzE0JTIwTDM0LjAzMSUyQzMlMjBMMzguMDMxJTJDMyUyMEwzOC4wMzElMkMwJTIwTDI3LjAzMSUyQzAlMjB6JTIyJTIwZmlsbCUzRCUyMiUyM0YwODYxNSUyMiUyRiUzRSUwQSUzQyUyRnN2ZyUzRSUwQSkgbm8tcmVwZWF0IDAgMC9jb3ZlcjttYXJnaW4tdG9wOjNweH0ubWVudS1oZWFke3BhZGRpbmc6MThweCAyMHB4O2N1cnNvcjptb3ZlfS5tZW51LWhlYWRfdGl0bGV7Zm9udC1zaXplOjE2cHg7Zm9udC13ZWlnaHQ6NzAwO2NvbG9yOiMzNDM0MzR9Lm1lbnUtaGVhZF9uYW1le2Rpc3BsYXk6aW5saW5lLWJsb2NrO3ZlcnRpY2FsLWFsaWduOnRvcDt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzO292ZXJmbG93OmhpZGRlbjt3aGl0ZS1zcGFjZTpub3dyYXA7bWF4LXdpZHRoOjIzMHB4fS5tZW51LWhlYWRfdGV4dHttYXJnaW46NHB4IDEwcHggMCAwO2ZvbnQtc2l6ZToxMnB4O2NvbG9yOiMzNDM0MzR9Lm1lbnUtZmlsdGVye3BhZGRpbmc6MjBweDtib3JkZXItdG9wOjFweCBzb2xpZCAjZTBkZmRifS5tZW51LWZpbHRlcl9sYmx7ZmxvYXQ6bGVmdDtmb250LXNpemU6MTRweDtmb250LXdlaWdodDo1MDA7Y29sb3I6IzhmOWI5Mn0ubWVudS1maWx0ZXJfdmFse2Zsb2F0OnJpZ2h0fS5tZW51LWZpbHRlcl9sYWJlbHtwb3NpdGlvbjpyZWxhdGl2ZTtmbG9hdDpyaWdodDt3aWR0aDo0M3B4O2hlaWdodDoyMnB4O21hcmdpbjowO2JvcmRlci1yYWRpdXM6NHB4O2JhY2tncm91bmQ6I2U4NTAzNztjdXJzb3I6cG9pbnRlcjtvdmVyZmxvdzpoaWRkZW59Lm1lbnUtZmlsdGVyX2xhYmVsOmhvdmVye2JhY2tncm91bmQ6I2VkNzg2NX0ubWVudS1maWx0ZXJfbGFiZWw6YmVmb3Jle2NvbnRlbnQ6Jyc7cG9zaXRpb246YWJzb2x1dGU7dG9wOjdweDtsZWZ0Oi0xNHB4O3dpZHRoOjEwcHg7aGVpZ2h0OjVweDtib3JkZXItYm90dG9tOjJweCBzb2xpZCAjZmZmO2JvcmRlci1sZWZ0OjJweCBzb2xpZCAjZmZmOy13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgtNDVkZWcpOy1tcy10cmFuc2Zvcm06cm90YXRlKC00NWRlZyk7dHJhbnNmb3JtOnJvdGF0ZSgtNDVkZWcpfS5tZW51LWZpbHRlcl9sYWJlbDphZnRlcntjb250ZW50OicrJztwb3NpdGlvbjphYnNvbHV0ZTt0b3A6OXB4O3JpZ2h0Oi0zcHg7d2lkdGg6MTNweDtoZWlnaHQ6MjBweDtmb250LXNpemU6MjBweDtsaW5lLWhlaWdodDowO2ZvbnQtd2VpZ2h0OjQwMDtjb2xvcjojZmZmOy13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgtNDVkZWcpOy1tcy10cmFuc2Zvcm06cm90YXRlKC00NWRlZyk7dHJhbnNmb3JtOnJvdGF0ZSgtNDVkZWcpfS5tZW51LWZpbHRlcl9sYWJlbC5hbmltYXRlLC5tZW51LWZpbHRlcl9sYWJlbC5hbmltYXRlIC5tZW51LWZpbHRlcl9oYW5kbGUsLm1lbnUtZmlsdGVyX2xhYmVsLmFuaW1hdGU6YWZ0ZXIsLm1lbnUtZmlsdGVyX2xhYmVsLmFuaW1hdGU6YmVmb3Jle3RyYW5zaXRpb246LjJzfS5tZW51LWZpbHRlcl9oYW5kbGV7cG9zaXRpb246YWJzb2x1dGU7d2lkdGg6MjBweDtoZWlnaHQ6MjBweDt0b3A6MXB4O2xlZnQ6MXB4O2JvcmRlci1yYWRpdXM6NHB4O2JhY2tncm91bmQ6I2ZmZn0ubWVudS1maWx0ZXJfaW5wdXQ6Y2hlY2tlZCsubWVudS1maWx0ZXJfbGFiZWx7YmFja2dyb3VuZDojMzZiYTUzfS5tZW51LWZpbHRlcl9pbnB1dDpjaGVja2VkKy5tZW51LWZpbHRlcl9sYWJlbDpob3ZlcntiYWNrZ3JvdW5kOiM1NWNlNzB9Lm1lbnUtZmlsdGVyX2lucHV0OmNoZWNrZWQrLm1lbnUtZmlsdGVyX2xhYmVsOmJlZm9yZXtsZWZ0OjdweH0ubWVudS1maWx0ZXJfaW5wdXQ6Y2hlY2tlZCsubWVudS1maWx0ZXJfbGFiZWw6YWZ0ZXJ7cmlnaHQ6LTI0cHh9Lm1lbnUtZmlsdGVyX2lucHV0OmNoZWNrZWQrLm1lbnUtZmlsdGVyX2xhYmVsIC5tZW51LWZpbHRlcl9oYW5kbGV7bGVmdDoyMnB4fVtjbGFzcyo9IiBpLW1lbnUtIl0sW2NsYXNzXj1pLW1lbnUtXXtkaXNwbGF5OmlubGluZS1ibG9jazt2ZXJ0aWNhbC1hbGlnbjptaWRkbGU7d2lkdGg6MjRweDtoZWlnaHQ6MjRweH0uaS1tZW51LXRpbWV7YmFja2dyb3VuZDp1cmwoZGF0YTppbWFnZS9zdmcreG1sLCUzQyUzRnhtbCUyMHZlcnNpb24lM0QlMjIxLjAlMjIlMjBlbmNvZGluZyUzRCUyMlVURi04JTIyJTNGJTNFJTBBJTNDc3ZnJTIwdmVyc2lvbiUzRCUyMjEuMSUyMiUyMHhtbG5zJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYyMDAwJTJGc3ZnJTIyJTIwdmlld0JveCUzRCUyMjAlMjAwJTIwMjQlMjAyNCUyMiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTTEzJTJDMTMuNzExJTIwTDE2LjY0NSUyQzE3LjM1NSUyMEwxNS4yMzElMkMxOC43NyUyMEwxMS4yOTMlMkMxNC44MzIlMjBMMTElMkMxNCUyMEwxMSUyQzE0JTIwTDExJTJDNyUyMEwxMyUyQzclMjBMMTMlMkMxMy43MTElMjB6JTIwTTEzJTJDMy4wNSUyMEwxMyUyQzIlMjBMMTUlMkMyJTIwTDE1JTJDMCUyMEw5JTJDMCUyMEw5JTJDMiUyMEwxMSUyQzIlMjBMMTElMkMzLjA1JTIwQzUuNjclMkMzLjU1NSUyMDEuNSUyQzguMDM4JTIwMS41JTJDMTMuNSUyMEMxLjUlMkMxOS4yOTklMjA2LjIwMSUyQzI0JTIwMTIlMkMyNCUyMEMxNy43OTklMkMyNCUyMDIyLjUlMkMxOS4yOTklMjAyMi41JTJDMTMuNSUyMEMyMi41JTJDOC4wMzglMjAxOC4zMyUyQzMuNTU1JTIwMTMlMkMzLjA1JTIweiUyME0xMiUyQzIyJTIwQzcuMzEzJTJDMjIlMjAzLjUlMkMxOC4xODclMjAzLjUlMkMxMy41JTIwQzMuNSUyQzguODEzJTIwNy4zMTMlMkM1JTIwMTIlMkM1JTIwQzE2LjY4NyUyQzUlMjAyMC41JTJDOC44MTMlMjAyMC41JTJDMTMuNSUyMEMyMC41JTJDMTguMTg3JTIwMTYuNjg3JTJDMjIlMjAxMiUyQzIyJTIweiUyMiUyMGZpbGwlM0QlMjIlMjNCNEMxQjYlMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEEpfS5pLW1lbnUtdGltZS1oe2JhY2tncm91bmQ6dXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0MlM0Z4bWwlMjB2ZXJzaW9uJTNEJTIyMS4wJTIyJTIwZW5jb2RpbmclM0QlMjJVVEYtOCUyMiUzRiUzRSUwQSUzQ3N2ZyUyMHZlcnNpb24lM0QlMjIxLjElMjIlMjB4bWxucyUzRCUyMmh0dHAlM0ElMkYlMkZ3d3cudzMub3JnJTJGMjAwMCUyRnN2ZyUyMiUyMHZpZXdCb3glM0QlMjIwJTIwMCUyMDI0JTIwMjQlMjIlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0xMyUyQzEzLjcxMSUyMEwxNi42NDUlMkMxNy4zNTUlMjBMMTUuMjMxJTJDMTguNzclMjBMMTEuMjkzJTJDMTQuODMyJTIwTDExJTJDMTQlMjBMMTElMkMxNCUyMEwxMSUyQzclMjBMMTMlMkM3JTIweiUyMiUyMGZpbGwlM0QlMjIlMjM0RkJCNTQlMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0xMyUyQzMuMDUlMjBMMTMlMkMyJTIwTDE1JTJDMiUyMEwxNSUyQzAlMjBMOSUyQzAlMjBMOSUyQzIlMjBMMTElMkMyJTIwTDExJTJDMy4wNSUyMEM1LjY3JTJDMy41NTUlMjAxLjUlMkM4LjAzOCUyMDEuNSUyQzEzLjUlMjBDMS41JTJDMTkuMjk5JTIwNi4yMDElMkMyNCUyMDEyJTJDMjQlMjBDMTcuNzk5JTJDMjQlMjAyMi41JTJDMTkuMjk5JTIwMjIuNSUyQzEzLjUlMjBDMjIuNSUyQzguMDM4JTIwMTguMzMlMkMzLjU1NSUyMDEzJTJDMy4wNSUyMHolMjBNMTIlMkMyMiUyMEM3LjMxMyUyQzIyJTIwMy41JTJDMTguMTg3JTIwMy41JTJDMTMuNSUyMEMzLjUlMkM4LjgxMyUyMDcuMzEzJTJDNSUyMDEyJTJDNSUyMEMxNi42ODclMkM1JTIwMjAuNSUyQzguODEzJTIwMjAuNSUyQzEzLjUlMjBDMjAuNSUyQzE4LjE4NyUyMDE2LjY4NyUyQzIyJTIwMTIlMkMyMiUyMHolMjIlMjBmaWxsJTNEJTIyJTIzNTU2MjU3JTIyJTJGJTNFJTBBJTNDJTJGc3ZnJTNFJTBBKX0uaS1tZW51LXNlbGVjdHtiYWNrZ3JvdW5kOnVybChkYXRhOmltYWdlL3N2Zyt4bWwsJTNDJTNGeG1sJTIwdmVyc2lvbiUzRCUyMjEuMCUyMiUyMGVuY29kaW5nJTNEJTIyVVRGLTglMjIlM0YlM0UlMEElM0NzdmclMjB2ZXJzaW9uJTNEJTIyMS4xJTIyJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB2aWV3Qm94JTNEJTIyMCUyMDAlMjAyNCUyMDI0JTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNMTAuNjY3JTJDMjEuMDY3JTIwQzUuOTc3JTJDMjEuMDY3JTIwMi4wOTYlMkMyMS4wNjclMjAxLjYlMkMyMS4wNjclMjBDMCUyQzIxLjA2NyUyMDAlMkMxOS40NjclMjAwJTJDMTkuNDY3JTIwTDAlMkMyLjQlMjBDMCUyQzIuNCUyMDAlMkMwLjglMjAxLjYlMkMwLjglMjBDMi42NjclMkMwLjglMjAyMC44JTJDMC44JTIwMjEuODY3JTJDMC44JTIwQzIzLjQ2NyUyQzAuOCUyMDIzLjQ2NyUyQzIuNCUyMDIzLjQ2NyUyQzIuNCUyMEwyMy40NjclMkMxMy4wNjclMjBMMjEuMzMzJTJDMTIlMjBMMjEuMzMzJTJDMi45MzMlMjBMMi4xMzMlMkMyLjkzMyUyMEwyLjEzMyUyQzE4LjkzMyUyMEwxMC42NjclMkMxOC45MzMlMjBMMTAuNjY3JTJDMjEuMDY3JTIweiUyME0xNi41MzMlMkMxOS40NjclMjBMMTkuMDc3JTJDMjIuOTQxJTIwTDIxLjU2NSUyQzIxLjI1NCUyMEwxOS4wNDIlMkMxNy43MTUlMjBMMjQlMkMxNS4xOTklMjBMMTIuOCUyQzExLjQ2NyUyMEwxMi44JTJDMjMuMiUyMEwxNi41MzMlMkMxOS40NjclMjB6JTIyJTIwZmlsbCUzRCUyMiUyM0I0QzFCNiUyMiUyRiUzRSUwQSUzQyUyRnN2ZyUzRSUwQSl9LmktbWVudS1zZWxlY3QtaHtiYWNrZ3JvdW5kOnVybChkYXRhOmltYWdlL3N2Zyt4bWwsJTNDJTNGeG1sJTIwdmVyc2lvbiUzRCUyMjEuMCUyMiUyMGVuY29kaW5nJTNEJTIyVVRGLTglMjIlM0YlM0UlMEElM0NzdmclMjB2ZXJzaW9uJTNEJTIyMS4xJTIyJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB2aWV3Qm94JTNEJTIyMCUyMDAlMjAyNCUyMDI0JTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNMTAuNjY3JTJDMjEuMDY3JTIwQzUuOTc3JTJDMjEuMDY3JTIwMi4wOTYlMkMyMS4wNjclMjAxLjYlMkMyMS4wNjclMjBDMCUyQzIxLjA2NyUyMDAlMkMxOS40NjclMjAwJTJDMTkuNDY3JTIwTDAlMkMyLjQlMjBDMCUyQzIuNCUyMDAlMkMwLjglMjAxLjYlMkMwLjglMjBDMi42NjclMkMwLjglMjAyMC44JTJDMC44JTIwMjEuODY3JTJDMC44JTIwQzIzLjQ2NyUyQzAuOCUyMDIzLjQ2NyUyQzIuNCUyMDIzLjQ2NyUyQzIuNCUyMEwyMy40NjclMkMxMy4wNjclMjBMMjEuMzMzJTJDMTIlMjBMMjEuMzMzJTJDMi45MzMlMjBMMi4xMzMlMkMyLjkzMyUyMEwyLjEzMyUyQzE4LjkzMyUyMEwxMC42NjclMkMxOC45MzMlMjBMMTAuNjY3JTJDMjEuMDY3JTIweiUyMiUyMGZpbGwlM0QlMjIlMjM1NTYyNTclMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0xNi41MzMlMkMxOS40NjclMjBMMTkuMDc3JTJDMjIuOTQxJTIwTDIxLjU2NSUyQzIxLjI1NCUyMEwxOS4wNDIlMkMxNy43MTUlMjBMMjQlMkMxNS4xOTklMjBMMTIuOCUyQzExLjQ2NyUyMEwxMi44JTJDMjMuMiUyMHolMjIlMjBmaWxsJTNEJTIyJTIzNEZCQjU0JTIyJTJGJTNFJTBBJTNDJTJGc3ZnJTNFJTBBKX0uaS1tZW51LWNvbXBsYWludHtiYWNrZ3JvdW5kOnVybChkYXRhOmltYWdlL3N2Zyt4bWwsJTNDJTNGeG1sJTIwdmVyc2lvbiUzRCUyMjEuMCUyMiUyMGVuY29kaW5nJTNEJTIyVVRGLTglMjIlM0YlM0UlMEElM0NzdmclMjB2ZXJzaW9uJTNEJTIyMS4xJTIyJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB2aWV3Qm94JTNEJTIyMCUyMDAlMjAyNCUyMDI0JTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNMjMuNTI2JTJDMTAuMzg5JTIwQzIzLjUyMSUyQzEwLjM3OCUyMDIzLjUxNSUyQzEwLjM2NiUyMDIzLjUxJTJDMTAuMzU0JTIwQzIzLjc2MSUyQzEwLjA0MSUyMDI0JTJDOS41OTYlMjAyNCUyQzklMjBDMjQlMkM4LjQ1MSUyMDIzLjc5OCUyQzguMDQlMjAyMy41NDIlMkM3LjUyJTIwQzIzLjU0MiUyQzcuNTE5JTIwMjMuNTQxJTJDNy41MTklMjAyMy41NCUyQzcuNTE3JTIwQzI0LjAzOSUyQzYuODE1JTIwMjQuMTY1JTJDNS45NzYlMjAyMy44MzglMkM1LjIxMyUyMEMyMy43MjklMkM0Ljk1OCUyMDIzLjU4MyUyQzQuNjE2JTIwMjIuMjI5JTJDMy4yMiUyMEMyMi4xMzglMkMyLjkwOCUyMDIyJTJDMi41MjklMjAyMS43ODklMkMyLjEwNiUyMEMyMS4wNjQlMkMwLjY1NiUyMDE5LjE0MiUyQzAuMTcyJTIwMTguMzUlMkMwLjAzMSUyMEwxOC4xNzUlMkMwJTIwTDE3Ljk5OCUyQzAlMjBMMTIuODA0JTJDMC4wMDQlMjBMMTIuNzM2JTJDMC4wMDQlMjBMMTIuNjY5JTJDMC4wMDglMjBDOS43OTglMkMwLjIwNCUyMDguMTgyJTJDMC43MjclMjA3LjI2OSUyQzEuMjY5JTIwTDclMkMxJTIwQzclMkMxJTIwMyUyQzElMjAyJTJDMSUyMEMxJTJDMSUyMDElMkMyJTIwMSUyQzIlMjBMLTAlMkMxMiUyMEMtMCUyQzEyJTIwLTAlMkMxMyUyMDElMkMxMyUyMEMyJTJDMTMlMjA3JTJDMTMlMjA3JTJDMTMlMjBMNy40MTYlMkMxMi4xNjglMjBDNy43MjYlMkMxMi40ODMlMjA4LjE2NyUyQzEzLjExMyUyMDguMzI0JTJDMTMuNDMyJTIwQzguNDU5JTJDMTMuODU0JTIwOC43NjIlMkMxNC40NjUlMjA5LjQ2OCUyQzE1LjgxNiUyMEM5LjU3OCUyQzE2LjAyNyUyMDkuNjc1JTJDMTYuMjEyJTIwOS43NDIlMkMxNi4zNDQlMjBDMTAuMTYzJTJDMTcuMTczJTIwMTAuODI4JTJDMTcuNjYyJTIwMTEuMjY3JTJDMTcuOTg2JTIwQzExLjMyMSUyQzE4LjAyNSUyMDExLjM4OCUyQzE4LjA3NSUyMDExLjQzNyUyQzE4LjExMiUyMEMxMS41MTMlMkMxOC4yNCUyMDExLjYzOCUyQzE4LjQ4OCUyMDExLjcyNSUyQzE4LjY2MiUyMEMxMS45MTMlMkMxOS4wMzUlMjAxMi4xMjUlMkMxOS40NTUlMjAxMi4zODklMkMxOS44NjglMjBDMTIuNTM3JTJDMjAuMTc2JTIwMTIuNzc4JTJDMjEuMjYlMjAxMi44OTklMkMyMi4xNjclMjBMMTIuOTg4JTJDMjIuODM4JTIwTDEzLjQ2NiUyQzIzLjMxOCUyMEMxMy44ODQlMkMyMy43MzYlMjAxNC40ODMlMkMyMy45NzclMjAxNS4xMSUyQzIzLjk3NyUyMEMxNS43NTYlMkMyMy45NzclMjAxNi4zOTIlMkMyMy43MzUlMjAxNy4wMDElMkMyMy4yNTYlMjBDMTguNTIxJTJDMjIuMDYlMjAxOC44NDQlMkMxOC4zNTElMjAxOC4zNjElMkMxNy4wMzclMjBDMTguMTc0JTJDMTYuNTMlMjAxNy44NDglMkMxNi4wMzIlMjAxNy41MDMlMkMxNS41MDUlMjBDMTcuNDE0JTJDMTUuMzY5JTIwMTcuMjk1JTJDMTUuMTg2JTIwMTcuMTc4JTJDMTQuOTk5JTIwQzE3LjMyNyUyQzE1LjAwNSUyMDE3LjU5OCUyQzE1LjAxOSUyMDE3LjgyNCUyQzE1LjAzMSUyMEMxOC40NjElMkMxNS4wNjYlMjAxOS4yNTQlMkMxNS4xMSUyMDE5LjkzOCUyQzE1LjExJTIwQzIwLjc4NiUyQzE1LjExJTIwMjEuNDIlMkMxNS4wNTElMjAyMS45NTklMkMxNC43NTclMjBDMjIuNTY3JTJDMTQuNDI0JTIwMjQuMTg0JTJDMTMuNTQyJTIwMjMuOTg4JTJDMTEuNzgxJTIwQzIzLjkzNiUyQzExLjMxNCUyMDIzLjc1NSUyQzEwLjkwNiUyMDIzLjUyNiUyQzEwLjM4OSUyMHolMjBNMjEuNDE2JTJDNy42MTQlMjBDMjEuNDYlMkM3LjkyMyUyMDIyJTJDOC44MjMlMjAyMiUyQzklMjBDMjIlMkM5LjE3NyUyMDIxLjQyMiUyQzkuNDYlMjAyMS4yODklMkM5Ljg1OCUyMEMyMS4xNTYlMkMxMC4yNTUlMjAyMS45NTYlMkMxMS42MDIlMjAyMiUyQzEyJTIwQzIyLjA0NCUyQzEyLjM5OCUyMDIxLjQ4NiUyQzEyLjczNCUyMDIxJTJDMTMlMjBDMjAuODUxJTJDMTMuMDgyJTIwMjAuNDQxJTJDMTMuMTA5JTIwMTkuOTM4JTJDMTMuMTA5JTIwQzE4LjkxNCUyQzEzLjEwOSUyMDE3LjUlMkMxMi45OTYlMjAxNy4wOTUlMkMxMi45OTYlMjBDMTcuMDUlMkMxMi45OTYlMjAxNy4wMTglMkMxMi45OTclMjAxNyUyQzEzJTIwQzE2LjczNSUyQzEzLjA0NCUyMDE1LjAzJTJDMTMuMjY0JTIwMTQuODIlMkMxNC4yMjIlMjBDMTQuNjElMkMxNS4xODIlMjAxNi4xNzQlMkMxNi44ODUlMjAxNi40ODQlMkMxNy43MjYlMjBDMTYuNzkzJTJDMTguNTY2JTIwMTYuMzgzJTJDMjEuMTk2JTIwMTUuNzY1JTJDMjEuNjgzJTIwQzE1LjQ2OSUyQzIxLjkxNSUyMDE1LjI1NCUyQzIxLjk3NiUyMDE1LjExJTJDMjEuOTc2JTIwQzE0Ljk1MyUyQzIxLjk3NiUyMDE0Ljg4MSUyQzIxLjkwMyUyMDE0Ljg4MSUyQzIxLjkwMyUyMEMxNC44ODElMkMyMS45MDMlMjAxNC41NzIlMkMxOS41NTklMjAxNC4wODYlMkMxOC44MDglMjBDMTMuNiUyQzE4LjA1NiUyMDEzLjI0NyUyQzE3LjA4MyUyMDEyLjg5NCUyQzE2LjcyOSUyMEMxMi41NCUyQzE2LjM3NSUyMDExLjgzMyUyQzE2LjA0NCUyMDExLjUyNCUyQzE1LjQzNiUyMEMxMS4yMTUlMkMxNC44MjglMjAxMC4zMDglMkMxMy4xNDQlMjAxMC4yMiUyQzEyLjc5JTIwQzEwLjEzMiUyQzEyLjQzNyUyMDguOTc3JTJDMTAuNTM4JTIwOC4wNDklMkMxMC4xOTMlMjBMOCUyQzMuMzA4JTIwTDglMkMzLjIwNSUyMEM4LjAwNyUyQzMuMTk3JTIwOC44MTIlMkMyLjI3NyUyMDEyLjgwNiUyQzIuMDA0JTIwTDE4JTJDMiUyMEMxOCUyQzIlMjAxOS42NDYlMkMyLjI5MyUyMDIwJTJDMyUyMEMyMC4zNTQlMkMzLjcwOCUyMDIwLjQwMyUyQzQuMjE0JTIwMjAuNDAzJTJDNC4yMTQlMjBDMjAuNDAzJTJDNC4yMTQlMjAyMS44NjglMkM1LjY5MSUyMDIyJTJDNiUyMEMyMi4xMzIlMkM2LjMxJTIwMjEuNTUyJTJDNi42OTElMjAyMS41NTIlMkM2LjY5MSUyMEMyMS41NTIlMkM2LjY5MSUyMDIxLjM3MiUyQzcuMzA0JTIwMjEuNDE2JTJDNy42MTQlMjB6JTIyJTIwZmlsbCUzRCUyMiUyM0I0QzFCNiUyMiUyRiUzRSUwQSUzQyUyRnN2ZyUzRSUwQSl9LmktbWVudS1jb21wbGFpbnQtaHtiYWNrZ3JvdW5kOnVybChkYXRhOmltYWdlL3N2Zyt4bWwsJTNDJTNGeG1sJTIwdmVyc2lvbiUzRCUyMjEuMCUyMiUyMGVuY29kaW5nJTNEJTIyVVRGLTglMjIlM0YlM0UlMEElM0NzdmclMjB2ZXJzaW9uJTNEJTIyMS4xJTIyJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB2aWV3Qm94JTNEJTIyMCUyMDAlMjAyNCUyMDI0JTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNMTglMkMyJTIwQzE4JTJDMiUyMDE5LjY0NiUyQzIuMjkyJTIwMjAlMkMzJTIwQzIwLjM1NCUyQzMuNzA3JTIwMjAuNDAzJTJDNC4yMTQlMjAyMC40MDMlMkM0LjIxNCUyMEMyMC40MDMlMkM0LjIxNCUyMDIxLjg2OCUyQzUuNjklMjAyMiUyQzYlMjBDMjIuMTMyJTJDNi4zMDklMjAyMS41NTIlMkM2LjY5MSUyMDIxLjU1MiUyQzYuNjkxJTIwQzIxLjU1MiUyQzYuNjkxJTIwMjEuMzcyJTJDNy4zMDQlMjAyMS40MTYlMkM3LjYxMyUyMEMyMS40NiUyQzcuOTIzJTIwMjIlMkM4LjgyMyUyMDIyJTJDOSUyMEMyMiUyQzkuMTc3JTIwMjEuNDIyJTJDOS40NTklMjAyMS4yOSUyQzkuODU3JTIwQzIxLjE1NiUyQzEwLjI1NSUyMDIxLjk1NiUyQzExLjYwMiUyMDIyJTJDMTIlMjBDMjIuMDQ0JTJDMTIuMzk4JTIwMjEuNDg2JTJDMTIuNzM0JTIwMjElMkMxMyUyMEMyMC44NTElMkMxMy4wODIlMjAyMC40NDElMkMxMy4xMDglMjAxOS45MzglMkMxMy4xMDglMjBDMTguOTE0JTJDMTMuMTA4JTIwMTcuNSUyQzEyLjk5NSUyMDE3LjA5NSUyQzEyLjk5NSUyMEMxNy4wNTElMkMxMi45OTUlMjAxNy4wMTklMkMxMi45OTclMjAxNyUyQzEzJTIwQzE2LjczNSUyQzEzLjA0NCUyMDE1LjAzMSUyQzEzLjI2MyUyMDE0LjgyMSUyQzE0LjIyMiUyMEMxNC42MTElMkMxNS4xODElMjAxNi4xNzQlMkMxNi44ODUlMjAxNi40ODQlMkMxNy43MjYlMjBDMTYuNzkzJTJDMTguNTY2JTIwMTYuMzg0JTJDMjEuMTk2JTIwMTUuNzY1JTJDMjEuNjgyJTIwQzE1LjQ3JTJDMjEuOTE1JTIwMTUuMjU1JTJDMjEuOTc2JTIwMTUuMTExJTJDMjEuOTc2JTIwQzE0Ljk1NCUyQzIxLjk3NiUyMDE0Ljg4MiUyQzIxLjkwMyUyMDE0Ljg4MiUyQzIxLjkwMyUyMEMxNC44ODIlMkMyMS45MDMlMjAxNC41NzIlMkMxOS41NTklMjAxNC4wODclMkMxOC44MDclMjBDMTMuNjAxJTJDMTguMDU2JTIwMTMuMjQ3JTJDMTcuMDgzJTIwMTIuODk0JTJDMTYuNzI5JTIwQzEyLjU0MSUyQzE2LjM3NSUyMDExLjgzMyUyQzE2LjA0MyUyMDExLjUyNCUyQzE1LjQzNSUyMEMxMS4yMTUlMkMxNC44MjclMjAxMC4zMDglMkMxMy4xNDQlMjAxMC4yMiUyQzEyLjc5JTIwQzEwLjEzMiUyQzEyLjQzNyUyMDguOTI4JTJDMTAuNTM5JTIwOCUyQzEwLjE5MyUyMEw4JTJDMy4yMSUyMEM4JTJDMy4yMSUyMDguNzk0JTJDMi4yNzclMjAxMi44MDYlMkMyLjAwMyUyMEwxOCUyQzIlMjBNMTguMTc2JTJDLTAlMjBMMTcuOTk5JTJDLTAlMjBMMTIuODA0JTJDMC4wMDMlMjBMMTIuNzM3JTJDMC4wMDMlMjBMMTIuNjY5JTJDMC4wMDglMjBDOC42NjElMkMwLjI4MSUyMDcuMDkyJTJDMS4xOSUyMDYuNDglMkMxLjkwNSUyMEw1Ljk5NCUyQzIuNDczJTIwTDYlMkMzLjIyJTIwTDYuMDUlMkMxMC4yMDglMjBMNi4wNiUyQzExLjU4NyUyMEw3LjI3MyUyQzEyLjAzOSUyMEM3LjU3JTJDMTIuMjYyJTIwOC4xNDElMkMxMy4wNiUyMDguMzI0JTJDMTMuNDMyJTIwQzguNDYlMkMxMy44NTQlMjA4Ljc2MyUyQzE0LjQ2NSUyMDkuNDY5JTJDMTUuODE2JTIwQzkuNTc5JTJDMTYuMDI3JTIwOS42NzUlMkMxNi4yMTIlMjA5Ljc0MiUyQzE2LjM0NCUyMEMxMC4xNjMlMkMxNy4xNzMlMjAxMC44MjglMkMxNy42NjIlMjAxMS4yNjclMkMxNy45ODYlMjBDMTEuMzIxJTJDMTguMDI1JTIwMTEuMzg4JTJDMTguMDc1JTIwMTEuNDM3JTJDMTguMTEyJTIwQzExLjUxMyUyQzE4LjI0JTIwMTEuNjM4JTJDMTguNDg4JTIwMTEuNzI2JTJDMTguNjYyJTIwQzExLjkxMyUyQzE5LjAzNSUyMDEyLjEyNiUyQzE5LjQ1NiUyMDEyLjM4OSUyQzE5Ljg2OCUyMEMxMi41MzclMkMyMC4xNzYlMjAxMi43NzglMkMyMS4yNiUyMDEyLjg5OSUyQzIyLjE2OCUyMEwxMi45ODglMkMyMi44MzglMjBMMTMuNDY2JTJDMjMuMzE4JTIwQzEzLjg4NCUyQzIzLjczNyUyMDE0LjQ4NCUyQzIzLjk3NyUyMDE1LjExMSUyQzIzLjk3NyUyMEMxNS43NTclMkMyMy45NzclMjAxNi4zOTIlMkMyMy43MzUlMjAxNy4wMDElMkMyMy4yNTclMjBDMTguNTIxJTJDMjIuMDYxJTIwMTguODQ0JTJDMTguMzUyJTIwMTguMzYxJTJDMTcuMDM4JTIwQzE4LjE3NCUyQzE2LjUzMSUyMDE3Ljg0OSUyQzE2LjAzMyUyMDE3LjUwMyUyQzE1LjUwNiUyMEMxNy40MTQlMkMxNS4zNjklMjAxNy4yOTUlMkMxNS4xODYlMjAxNy4xNzglMkMxNC45OTklMjBDMTcuMzI3JTJDMTUuMDA1JTIwMTcuNTk4JTJDMTUuMDIlMjAxNy44MjQlMkMxNS4wMzIlMjBDMTguNDYxJTJDMTUuMDY3JTIwMTkuMjU0JTJDMTUuMTElMjAxOS45MzglMkMxNS4xMSUyMEMyMC43ODYlMkMxNS4xMSUyMDIxLjQyJTJDMTUuMDUxJTIwMjEuOTU5JTJDMTQuNzU3JTIwQzIyLjU2OCUyQzE0LjQyNCUyMDI0LjE4NCUyQzEzLjU0MiUyMDIzLjk4OCUyQzExLjc4MSUyMEMyMy45MzclMkMxMS4zMTYlMjAyMy43NTYlMkMxMC45MDglMjAyMy41MjclMkMxMC4zOTElMjBDMjMuNTIxJTJDMTAuMzglMjAyMy41MTYlMkMxMC4zNjglMjAyMy41MSUyQzEwLjM1NSUyMEMyMy43NjElMkMxMC4wNDElMjAyNCUyQzkuNTk2JTIwMjQlMkM5JTIwQzI0JTJDOC40NTElMjAyMy43OTglMkM4LjA0JTIwMjMuNTQyJTJDNy41MiUyMEMyMy41NDIlMkM3LjUxOSUyMDIzLjU0MSUyQzcuNTE4JTIwMjMuNTQxJTJDNy41MTclMjBDMjQuMDQlMkM2LjgxNSUyMDI0LjE2NiUyQzUuOTc2JTIwMjMuODM5JTJDNS4yMTMlMjBDMjMuNzI5JTJDNC45NTglMjAyMy41ODMlMkM0LjYxNiUyMDIyLjIyOSUyQzMuMjIlMjBDMjIuMTM4JTJDMi45MDglMjAyMiUyQzIuNTI4JTIwMjEuNzg5JTJDMi4xMDYlMjBDMjEuMDY1JTJDMC42NTYlMjAxOS4xNDIlMkMwLjE3MSUyMDE4LjM1JTJDMC4wMzElMjBMMTguMTc2JTJDLTAlMjBMMTguMTc2JTJDLTAlMjB6JTIyJTIwZmlsbCUzRCUyMiUyMzU1NjI1NyUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTTElMkMxMyUyMEMyJTJDMTMlMjA3JTJDMTMlMjA3JTJDMTMlMjBDNyUyQzEzJTIwOCUyQzEzJTIwOCUyQzExJTIwQzglMkM5JTIwOCUyQzMlMjA4JTJDMiUyMEM4JTJDMSUyMDclMkMxJTIwNyUyQzElMjBDNyUyQzElMjAzJTJDMSUyMDIlMkMxJTIwQzElMkMxJTIwMSUyQzIlMjAxJTJDMiUyMEwwJTJDMTIlMjBDMCUyQzEyJTIwMCUyQzEzJTIwMSUyQzEzJTIweiUyMiUyMGZpbGwlM0QlMjIlMjM0RkJCNTQlMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEEpfS5pLW1lbnUtcmVwb3J0e2JhY2tncm91bmQ6dXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0MlM0Z4bWwlMjB2ZXJzaW9uJTNEJTIyMS4wJTIyJTIwZW5jb2RpbmclM0QlMjJVVEYtOCUyMiUzRiUzRSUwQSUzQ3N2ZyUyMHZlcnNpb24lM0QlMjIxLjElMjIlMjB4bWxucyUzRCUyMmh0dHAlM0ElMkYlMkZ3d3cudzMub3JnJTJGMjAwMCUyRnN2ZyUyMiUyMHZpZXdCb3glM0QlMjIwJTIwMCUyMDI0JTIwMjQlMjIlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0xMi4wMTglMkMtMC4wMDMlMjBDOC41MTIlMkMtMC4wMDMlMjA0LjI4MiUyQzEuMTMyJTIwMC44JTJDMy4wMjklMjBDMC44JTJDNy4xMjclMjAwLjczNCUyQzE3LjAyNSUyMDEyJTJDMjQlMjBDMjMuMjY2JTJDMTcuMDI1JTIwMjMuMjM3JTJDNy4xNzElMjAyMy4yMzclMkMzLjA3NCUyMEMxOS43NTUlMkMxLjE3NiUyMDE1LjUyNSUyQy0wLjAwMyUyMDEyLjAxOCUyQy0wLjAwMyUyMHolMjBNMTIlMkMyMS4zOTElMjBDMy42NjYlMkMxNS4wMzglMjAzLjA1MSUyQzcuNzUlMjAzLjA1MSUyQzQuMjk5JTIwQzUuODU0JTJDMi43MDIlMjA5LjEwNiUyQzIuMDg3JTIwMTIlMkMyLjA4NyUyMEMxNC44OTUlMkMyLjA4NyUyMDE4LjE4OCUyQzIuNzM5JTIwMjAuOTkxJTJDNC4zMzclMjBDMjAuOTkxJTJDNy43ODclMjAyMC4zNjIlMkMxNS4wMzglMjAxMiUyQzIxLjM5MSUyMHolMjBNMTMuNTY1JTJDOS4zOTElMjBMMTAuNDM1JTJDOS4zOTElMjBMMTAuNDM1JTJDMTcuMjE3JTIwTDEzLjU2NSUyQzE3LjIxNyUyMEwxMy41NjUlMkM5LjM5MSUyMHolMjBNMTIlMkM3LjMwNCUyMEMxMy4yNzglMkM3LjMwNCUyMDEzLjkwOSUyQzYuODE0JTIwMTMuOTA5JTJDNS43NjIlMjBDMTMuOTA5JTJDNS4yMzYlMjAxMy43NTYlMkM0LjgzOSUyMDEzLjQ1JTJDNC41NyUyMEMxMy4xNDQlMkM0LjMwMSUyMDEyLjY1OCUyQzQuMTY3JTIwMTEuOTkyJTJDNC4xNjclMjBDMTEuMzI1JTJDNC4xNjclMjAxMC44NDIlMkM0LjI5OCUyMDEwLjU0MyUyQzQuNTYxJTIwQzEwLjI0MyUyQzQuODI0JTIwMTAuMDk0JTJDNS4yMjQlMjAxMC4wOTQlMkM1Ljc2MyUyMEMxMC4wOTMlMkM2LjgxNCUyMDEwLjczNCUyQzcuMzA0JTIwMTIlMkM3LjMwNCUyMEwxMiUyQzcuMzA0JTIweiUyMiUyMGZpbGwlM0QlMjIlMjNCNEMxQjYlMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEEpfS5pLW1lbnUtcmVwb3J0LWh7YmFja2dyb3VuZDp1cmwoZGF0YTppbWFnZS9zdmcreG1sLCUzQyUzRnhtbCUyMHZlcnNpb24lM0QlMjIxLjAlMjIlMjBlbmNvZGluZyUzRCUyMlVURi04JTIyJTNGJTNFJTBBJTNDc3ZnJTIwdmVyc2lvbiUzRCUyMjEuMSUyMiUyMHhtbG5zJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYyMDAwJTJGc3ZnJTIyJTIwdmlld0JveCUzRCUyMjAlMjAwJTIwMjQlMjAyNCUyMiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTTEyLjAyNyUyQzAuMDA0JTIwQzguNTIlMkMwLjAwNCUyMDQuMjklMkMxLjEzOSUyMDAuODA4JTJDMy4wMzclMjBDMC44MDglMkM3LjEzNSUyMDAuNzQyJTJDMTcuMDMzJTIwMTIuMDA4JTJDMjQuMDA4JTIwQzIzLjI3NCUyQzE3LjAzMyUyMDIzLjI0NSUyQzcuMTc5JTIwMjMuMjQ1JTJDMy4wODElMjBDMTkuNzYzJTJDMS4xODQlMjAxNS41MzMlMkMwLjAwNCUyMDEyLjAyNyUyQzAuMDA0JTIweiUyME0xMi4wMDglMkMyMS4zOTklMjBDMy42NzQlMkMxNS4wNDUlMjAzLjA1OSUyQzcuNzU3JTIwMy4wNTklMkM0LjMwNyUyMEM1Ljg2MiUyQzIuNzA5JTIwOS4xMTQlMkMyLjA5NSUyMDEyLjAwOCUyQzIuMDk1JTIwQzE0LjkwMyUyQzIuMDk1JTIwMTguMTk2JTJDMi43NDYlMjAyMSUyQzQuMzQ0JTIwQzIxJTJDNy43OTQlMjAyMC4zNyUyQzE1LjA0NSUyMDEyLjAwOCUyQzIxLjM5OSUyMHolMjIlMjBmaWxsJTNEJTIyJTIzNTU2MjU3JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNMTMuNTc0JTJDOS4zOTklMjBMMTAuNDQzJTJDOS4zOTklMjBMMTAuNDQzJTJDMTcuMjI1JTIwTDEzLjU3NCUyQzE3LjIyNSUyMEwxMy41NzQlMkM5LjM5OSUyMHolMjBNMTIuMDA4JTJDNy4zMTIlMjBDMTMuMjg2JTJDNy4zMTIlMjAxMy45MTclMkM2LjgyMiUyMDEzLjkxNyUyQzUuNzclMjBDMTMuOTE3JTJDNS4yNDQlMjAxMy43NjQlMkM0Ljg0NiUyMDEzLjQ1OCUyQzQuNTc4JTIwQzEzLjE1MyUyQzQuMzA5JTIwMTIuNjY2JTJDNC4xNzQlMjAxMiUyQzQuMTc0JTIwQzExLjMzNCUyQzQuMTc0JTIwMTAuODUxJTJDNC4zMDUlMjAxMC41NTElMkM0LjU2OCUyMEMxMC4yNTIlMkM0LjgzMSUyMDEwLjEwMiUyQzUuMjMxJTIwMTAuMTAyJTJDNS43NyUyMEMxMC4xMDElMkM2LjgyMSUyMDEwLjc0MyUyQzcuMzEyJTIwMTIuMDA4JTJDNy4zMTIlMjBMMTIuMDA4JTJDNy4zMTIlMjB6JTIyJTIwZmlsbCUzRCUyMiUyMzRGQkI1NCUyMiUyRiUzRSUwQSUzQyUyRnN2ZyUzRSUwQSl9LmktbWVudS1zZXR0aW5nc3tiYWNrZ3JvdW5kOnVybChkYXRhOmltYWdlL3N2Zyt4bWwsJTNDJTNGeG1sJTIwdmVyc2lvbiUzRCUyMjEuMCUyMiUyMGVuY29kaW5nJTNEJTIyVVRGLTglMjIlM0YlM0UlMEElM0NzdmclMjB2ZXJzaW9uJTNEJTIyMS4xJTIyJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB2aWV3Qm94JTNEJTIyMCUyMDAlMjAyNCUyMDI0JTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNMjQlMkMxMCUyMEwyMC43NSUyQzguMzc1JTIwTDIxLjg5OSUyQzQuOTI5JTIwTDE5LjA3JTJDMi4xMDElMjBMMTUuNjI0JTJDMy4yNDklMjBMMTQlMkMwJTIwTDEwJTJDMCUyMEw4LjM3NSUyQzMuMjUlMjBMNC45MjklMkMyLjEwMSUyMEwyLjEwMSUyQzQuOTI5JTIwTDMuMjQ5JTJDOC4zNzUlMjBMMCUyQzEwJTIwTDAlMkMxNCUyMEwzLjI1JTJDMTUuNjI1JTIwTDIuMTAxJTJDMTkuMDcyJTIwTDQuOTMlMkMyMS44OTklMjBMOC4zNzYlMkMyMC43NTElMjBMMTAlMkMyNCUyMEwxNCUyQzI0JTIwTDE1LjYyNSUyQzIwLjc1JTIwTDE5LjA3MSUyQzIxLjg5OSUyMEwyMS44OTklMkMxOS4wNzElMjBMMjAuNzUxJTJDMTUuNjI1JTIwTDI0JTJDMTQlMjBMMjQlMkMxMCUyMHolMjBNMjIlMkMxMyUyMEwxOC41NjMlMkMxNC43MTklMjBMMTkuNzc4JTJDMTguMzY0JTIwTDE4LjM2NCUyQzE5Ljc3OCUyMEwxNC43MTklMkMxOC41NjMlMjBMMTMlMkMyMiUyMEwxMSUyQzIyJTIwTDkuMjgxJTJDMTguNTYzJTIwTDUuNjM2JTJDMTkuNzc4JTIwTDQuMjIxJTJDMTguMzY0JTIwTDUuNDM3JTJDMTQuNzE5JTIwTDIlMkMxMyUyMEwyJTJDMTElMjBMNS40MzclMkM5LjI4MSUyMEw0LjIyMSUyQzUuNjM2JTIwTDUuNjM2JTJDNC4yMjElMjBMOS4yODElMkM1LjQzNyUyMEwxMSUyQzIlMjBMMTMlMkMyJTIwTDE0LjcxOSUyQzUuNDM3JTIwTDE4LjM2NCUyQzQuMjIxJTIwTDE5Ljc3OCUyQzUuNjM2JTIwTDE4LjU2MyUyQzkuMjgxJTIwTDIyJTJDMTElMjBMMjIlMkMxMyUyMHolMjBNMTIlMkM3Ljk3JTIwQzkuNzc0JTJDNy45NyUyMDcuOTclMkM5Ljc3NCUyMDcuOTclMkMxMiUyMEM3Ljk3JTJDMTQuMjI2JTIwOS43NzQlMkMxNi4wMjklMjAxMiUyQzE2LjAyOSUyMEMxNC4yMjYlMkMxNi4wMjklMjAxNi4wMjklMkMxNC4yMjYlMjAxNi4wMjklMkMxMiUyMEMxNi4wMjklMkM5Ljc3NCUyMDE0LjIyNiUyQzcuOTclMjAxMiUyQzcuOTclMjB6JTIwTTEyJTJDMTMuOTI5JTIwQzEwLjkzNCUyQzEzLjkyOSUyMDEwLjA3MSUyQzEzLjA2NiUyMDEwLjA3MSUyQzEyJTIwQzEwLjA3MSUyQzEwLjkzNCUyMDEwLjkzNCUyQzEwLjA3MSUyMDEyJTJDMTAuMDcxJTIwQzEzLjA2NiUyQzEwLjA3MSUyMDEzLjkyOSUyQzEwLjkzNCUyMDEzLjkyOSUyQzEyJTIwQzEzLjkyOSUyQzEzLjA2NiUyMDEzLjA2NiUyQzEzLjkyOSUyMDEyJTJDMTMuOTI5JTIweiUyMiUyMGZpbGwlM0QlMjIlMjNCNEMxQjYlMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEEpfS5pLW1lbnUtc2V0dGluZ3MtaHtiYWNrZ3JvdW5kOnVybChkYXRhOmltYWdlL3N2Zyt4bWwsJTNDJTNGeG1sJTIwdmVyc2lvbiUzRCUyMjEuMCUyMiUyMGVuY29kaW5nJTNEJTIyVVRGLTglMjIlM0YlM0UlMEElM0NzdmclMjB2ZXJzaW9uJTNEJTIyMS4xJTIyJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB2aWV3Qm94JTNEJTIyMCUyMDAlMjAyNCUyMDI0JTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNMjQlMkMxMCUyMEwyMC43NSUyQzguMzc1JTIwTDIxLjg5OSUyQzQuOTI5JTIwTDE5LjA3JTJDMi4xMDElMjBMMTUuNjI0JTJDMy4yNDklMjBMMTQlMkMwJTIwTDEwJTJDMCUyMEw4LjM3NSUyQzMuMjUlMjBMNC45MjklMkMyLjEwMSUyMEwyLjEwMSUyQzQuOTI5JTIwTDMuMjQ5JTJDOC4zNzUlMjBMMCUyQzEwJTIwTDAlMkMxNCUyMEwzLjI1JTJDMTUuNjI1JTIwTDIuMTAxJTJDMTkuMDcyJTIwTDQuOTMlMkMyMS44OTklMjBMOC4zNzYlMkMyMC43NTElMjBMMTAlMkMyNCUyMEwxNCUyQzI0JTIwTDE1LjYyNSUyQzIwLjc1JTIwTDE5LjA3MSUyQzIxLjg5OSUyMEwyMS44OTklMkMxOS4wNzElMjBMMjAuNzUxJTJDMTUuNjI1JTIwTDI0JTJDMTQlMjBMMjQlMkMxMCUyMHolMjBNMjIlMkMxMyUyMEwxOC41NjMlMkMxNC43MTklMjBMMTkuNzc4JTJDMTguMzY0JTIwTDE4LjM2NCUyQzE5Ljc3OCUyMEwxNC43MTklMkMxOC41NjMlMjBMMTMlMkMyMiUyMEwxMSUyQzIyJTIwTDkuMjgxJTJDMTguNTYzJTIwTDUuNjM2JTJDMTkuNzc4JTIwTDQuMjIxJTJDMTguMzY0JTIwTDUuNDM3JTJDMTQuNzE5JTIwTDIlMkMxMyUyMEwyJTJDMTElMjBMNS40MzclMkM5LjI4MSUyMEw0LjIyMSUyQzUuNjM2JTIwTDUuNjM2JTJDNC4yMjElMjBMOS4yODElMkM1LjQzNyUyMEwxMSUyQzIlMjBMMTMlMkMyJTIwTDE0LjcxOSUyQzUuNDM3JTIwTDE4LjM2NCUyQzQuMjIxJTIwTDE5Ljc3OCUyQzUuNjM2JTIwTDE4LjU2MyUyQzkuMjgxJTIwTDIyJTJDMTElMjBMMjIlMkMxMyUyMHolMjIlMjBmaWxsJTNEJTIyJTIzNTU2MjU3JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNMTIlMkM3Ljk3JTIwQzkuNzc0JTJDNy45NyUyMDcuOTclMkM5Ljc3NCUyMDcuOTclMkMxMiUyMEM3Ljk3JTJDMTQuMjI2JTIwOS43NzQlMkMxNi4wMjklMjAxMiUyQzE2LjAyOSUyMEMxNC4yMjYlMkMxNi4wMjklMjAxNi4wMjklMkMxNC4yMjYlMjAxNi4wMjklMkMxMiUyMEMxNi4wMjklMkM5Ljc3NCUyMDE0LjIyNiUyQzcuOTclMjAxMiUyQzcuOTclMjB6JTIwTTEyJTJDMTMuOTI5JTIwQzEwLjkzNCUyQzEzLjkyOSUyMDEwLjA3MSUyQzEzLjA2NiUyMDEwLjA3MSUyQzEyJTIwQzEwLjA3MSUyQzEwLjkzNCUyMDEwLjkzNCUyQzEwLjA3MSUyMDEyJTJDMTAuMDcxJTIwQzEzLjA2NiUyQzEwLjA3MSUyMDEzLjkyOSUyQzEwLjkzNCUyMDEzLjkyOSUyQzEyJTIwQzEzLjkyOSUyQzEzLjA2NiUyMDEzLjA2NiUyQzEzLjkyOSUyMDEyJTJDMTMuOTI5JTIweiUyMiUyMGZpbGwlM0QlMjIlMjM0RkJCNTQlMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEEpfS5tZW51e3BhZGRpbmc6MTFweCAwO2ZvbnQtc2l6ZToxNHB4O2ZvbnQtd2VpZ2h0OjUwMDtjb2xvcjojOGY5YjkyO2JvcmRlci10b3A6MXB4IHNvbGlkICNlMGRmZGJ9Lm1lbnVfaXtwYWRkaW5nOjhweCAyMHB4O2N1cnNvcjpwb2ludGVyfS5tZW51X2k6aG92ZXJ7YmFja2dyb3VuZDojZWVmN2YxO2NvbG9yOiMzMzN9Lm1lbnVfaTpob3ZlciAubWVudV9pY29fc3tkaXNwbGF5Om5vbmV9Lm1lbnVfaTpob3ZlciAubWVudV9pY29faHtkaXNwbGF5OmlubGluZS1ibG9jazt2ZXJ0aWNhbC1hbGlnbjp0b3B9Lm1lbnVfaWNve2Rpc3BsYXk6aW5saW5lLWJsb2NrO3ZlcnRpY2FsLWFsaWduOnRvcH0ubWVudV9pY29faHtkaXNwbGF5Om5vbmV9Lm1lbnVfbmFtZXtkaXNwbGF5OmlubGluZS1ibG9jazt2ZXJ0aWNhbC1hbGlnbjptaWRkbGU7bWFyZ2luOjJweCAwIDAgNnB4fS5jZi1taXg6YWZ0ZXIsLmNmLW1peDpiZWZvcmUsLmNmOmFmdGVyLC5jZjpiZWZvcmUsLmNsZWFyZml4OmFmdGVyLC5jbGVhcmZpeDpiZWZvcmUsLmZvb3Q6YWZ0ZXIsLmZvb3Q6YmVmb3JlLC5tZW51LWZpbHRlcjphZnRlciwubWVudS1maWx0ZXI6YmVmb3Jle2Rpc3BsYXk6dGFibGU7Y29udGVudDoiIn0uY2YtbWl4OmFmdGVyLC5jZjphZnRlciwuY2xlYXJmaXg6YWZ0ZXIsLmZvb3Q6YWZ0ZXIsLm1lbnUtZmlsdGVyOmFmdGVye2NsZWFyOmJvdGh9LmNlbnRlci1ibG9ja3tkaXNwbGF5OmJsb2NrO21hcmdpbi1sZWZ0OmF1dG87bWFyZ2luLXJpZ2h0OmF1dG99LnB1bGwtcmlnaHR7ZmxvYXQ6cmlnaHQhaW1wb3J0YW50fS5wdWxsLWxlZnR7ZmxvYXQ6bGVmdCFpbXBvcnRhbnR9LmhpZGV7ZGlzcGxheTpub25lfS5zaG93e2Rpc3BsYXk6YmxvY2t9LmludmlzaWJsZXt2aXNpYmlsaXR5OmhpZGRlbn0udGV4dC1oaWRle2ZvbnQ6MC8wIGE7Y29sb3I6dHJhbnNwYXJlbnQ7dGV4dC1zaGFkb3c6bm9uZTtiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50O2JvcmRlcjowfS5oaWRkZW57ZGlzcGxheTpub25lIWltcG9ydGFudDt2aXNpYmlsaXR5OmhpZGRlbiFpbXBvcnRhbnR9",

"mainMenu.html": "PGRpdiBjbGFzcz0ibWFpbiI+CiAgICA8ZGl2IGNsYXNzPSJjbG9zZSI+PC9kaXY+CiAgICA8ZGl2IGNsYXNzPSJtZW51LWhlYWQiPgogICAgICAgIDxkaXYgY2xhc3M9Im1lbnUtaGVhZF90aXRsZSI+CiAgICAgICAgPHNwYW4gY2xhc3M9Im1lbnUtaGVhZF9uYW1lIj4KCiAgICAgICAgPC9zcGFuPgogICAgICAgICAgICA8YSBjbGFzcz0id290LWluZGljYXRvciB3b3QtaGlkZSIgdGFyZ2V0PSJfYmxhbmsiIGhyZWY9Imh0dHA6Ly9hZGd1YXJkLmNvbS93b3Qtc2NvcmVjYXJkLmh0bWw/ZG9tYWluPWhhYnJhaGFici5ydSI+CiAgICAgICAgICAgICAgICA8aSBpZD0iV290SW5kaWNhdGlvbiIgY2xhc3M9ImFkZy13b3QgdG9vbHRpcCIgZGF0YS10aXRsZT0iU2l0ZSByZXB1dGF0aW9uIGluZGljYXRvciI+PC9pPgogICAgICAgICAgICA8L2E+CiAgICAgICAgICAgIDxhIGNsYXNzPSJjb25maWRlbmNlLWluZGljYXRpb24gd290LWhpZGUiIGhyZWY9IiMiPjxpIGlkPSJDb25maWRlbmNlSW5kaWNhdGlvbiIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9ImFkZy13b3QtY29uZmlkZW5jZSB0b29sdGlwIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLXRpdGxlPSJSZXB1dGF0aW9uIENvbmZpZGVuY2UgTGV2ZWwiPjwvaT48L2E+CiAgICAgICAgPC9kaXY+CiAgICAgICAgPGRpdiBjbGFzcz0ibWVudS1oZWFkX3RleHQgd290LWhpZGUiIGlkPSJXb3REZXNjcmlwdGlvblRleHQiPgogICAgICAgICAgICA8YSBpZD0iV290TG9nbyIgaHJlZj0iIyI+PHNwYW4KICAgICAgICAgICAgICAgIGNsYXNzPSJ3b3QtbG9nbyI+PC9zcGFuPjwvYT4KICAgICAgICA8L2Rpdj4KICAgIDwvZGl2PgogICAgPGRpdiBjbGFzcz0ibWVudS1maWx0ZXIiPgogICAgICAgIDxkaXYgaTE4bj0ibWVudV9maWx0cmF0aW9uX3N0YXR1cyIgY2xhc3M9Im1lbnUtZmlsdGVyX2xibCI+CiAgICAgICAgPC9kaXY+CiAgICAgICAgPGRpdiBjbGFzcz0ibWVudS1maWx0ZXJfdmFsIj4KICAgICAgICAgICAgPGlucHV0IHR5cGU9ImNoZWNrYm94IiBjbGFzcz0ibWVudS1maWx0ZXJfaW5wdXQiIGlkPSJpcy1maWx0ZXIiPgogICAgICAgICAgICA8bGFiZWwgZm9yPSJpcy1maWx0ZXIiIGNsYXNzPSJtZW51LWZpbHRlcl9sYWJlbCI+CiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0ibWVudS1maWx0ZXJfaGFuZGxlIj48L3NwYW4+CiAgICAgICAgICAgIDwvbGFiZWw+CiAgICAgICAgPC9kaXY+CiAgICA8L2Rpdj4KICAgIDxkaXYgY2xhc3M9Im1lbnUiPgogICAgICAgIDxkaXYgaWQ9ImRvLW5vdC1ibG9jay0zMC1zZWMiIGNsYXNzPSJtZW51X2kiPgogICAgICAgIDxzcGFuIGNsYXNzPSJtZW51X2ljbyI+CiAgICAgICAgICAgIDxzcGFuIGNsYXNzPSJtZW51X2ljb19zIGktbWVudS10aW1lIj48L3NwYW4+CiAgICAgICAgICAgIDxzcGFuIGNsYXNzPSJtZW51X2ljb19oIGktbWVudS10aW1lLWgiPjwvc3Bhbj4KICAgICAgICA8L3NwYW4+CiAgICAgICAgICAgIDxzcGFuIGkxOG49Im1lbnVfZG9fbm90X2ZpbHRlcl8zMF9zZWMiIGNsYXNzPSJtZW51X25hbWUiPjwvc3Bhbj4KICAgICAgICA8L2Rpdj4KICAgICAgICA8ZGl2IGlkPSJibG9jay1hZCIgY2xhc3M9Im1lbnVfaSI+CiAgICAgICAgPHNwYW4gY2xhc3M9Im1lbnVfaWNvIj4KICAgICAgICAgICAgPHNwYW4gY2xhc3M9Im1lbnVfaWNvX3MgaS1tZW51LXNlbGVjdCI+PC9zcGFuPgogICAgICAgICAgICA8c3BhbiBjbGFzcz0ibWVudV9pY29faCBpLW1lbnUtc2VsZWN0LWgiPjwvc3Bhbj4KICAgICAgICA8L3NwYW4+CiAgICAgICAgICAgIDxzcGFuIGkxOG49Im1lbnVfYmxvY2tfYWRfb25fc2l0ZSIgY2xhc3M9Im1lbnVfbmFtZSI+PC9zcGFuPgogICAgICAgIDwvZGl2PgogICAgICAgIDxkaXYgY2xhc3M9Im1lbnVfaSIgaWQ9InJlcG9ydC1hYnVzZSI+CiAgICAgICAgPHNwYW4gY2xhc3M9Im1lbnVfaWNvIj4KICAgICAgICAgICAgPHNwYW4gY2xhc3M9Im1lbnVfaWNvX3MgaS1tZW51LWNvbXBsYWludCI+PC9zcGFuPgogICAgICAgICAgICA8c3BhbiBjbGFzcz0ibWVudV9pY29faCBpLW1lbnUtY29tcGxhaW50LWgiPjwvc3Bhbj4KICAgICAgICA8L3NwYW4+CiAgICAgICAgICAgIDxzcGFuIGkxOG49Im1lbnVfcmVwb3J0X2FidXNlIiBjbGFzcz0ibWVudV9uYW1lIj48L3NwYW4+CiAgICAgICAgPC9kaXY+CiAgICAgICAgPGRpdiBjbGFzcz0ibWVudV9pIiBpZD0ic2l0ZS1yZXBvcnQiPgogICAgICAgIDxzcGFuIGNsYXNzPSJtZW51X2ljbyI+CiAgICAgICAgICAgIDxzcGFuIGNsYXNzPSJtZW51X2ljb19zIGktbWVudS1yZXBvcnQiPjwvc3Bhbj4KICAgICAgICAgICAgPHNwYW4gY2xhc3M9Im1lbnVfaWNvX2ggaS1tZW51LXJlcG9ydC1oIj48L3NwYW4+CiAgICAgICAgPC9zcGFuPgogICAgICAgICAgICA8c3BhbiBpMThuPSJtZW51X3NpdGVfcmVwb3J0IiBjbGFzcz0ibWVudV9uYW1lIj48L3NwYW4+CiAgICAgICAgPC9kaXY+CiAgICAgICAgPGRpdiBjbGFzcz0ibWVudV9pIiBpZD0iYXNzaXN0YW50LXNldHRpbmdzIj4KICAgICAgICA8c3BhbiBjbGFzcz0ibWVudV9pY28iPgogICAgICAgICAgICA8c3BhbiBjbGFzcz0ibWVudV9pY29fcyBpLW1lbnUtc2V0dGluZ3MiPjwvc3Bhbj4KICAgICAgICAgICAgPHNwYW4gY2xhc3M9Im1lbnVfaWNvX2ggaS1tZW51LXNldHRpbmdzLWgiPjwvc3Bhbj4KICAgICAgICA8L3NwYW4+CiAgICAgICAgICAgIDxzcGFuIGkxOG49Im1lbnVfc2V0dGluZ3MiIGNsYXNzPSJtZW51X25hbWUiPjwvc3Bhbj4KICAgICAgICA8L2Rpdj4KICAgIDwvZGl2Pgo8L2Rpdj4=",

"selectorMenu.html": "PGRpdiBjbGFzcz0ibWFpbiBzZ19pZ25vcmUiPgogICAgPGRpdiBjbGFzcz0iY2xvc2UgYWRnLWNsb3NlIiBpZD0iY2xvc2UtYnV0dG9uIj48L2Rpdj4KICAgIDxkaXYgY2xhc3M9ImhlYWQiIGlkPSJkcmFnLWhhbmRsZSI+CiAgICAgICAgPGRpdiBpMThuPSJhc3Npc3RhbnRfc2VsZWN0X2VsZW1lbnQiIGNsYXNzPSJoZWFkX3RpdGxlIj48L2Rpdj4KICAgICAgICA8ZGl2IGkxOG49ImFzc2lzdGFudF9zZWxlY3RfZWxlbWVudF9leHQiIGNsYXNzPSJoZWFkX3RleHQiPjwvZGl2PgogICAgICAgIDwvZGl2PgogICAgPGRpdiBjbGFzcz0iZm9vdCI+CiAgICAgICAgPGJ1dHRvbiBpMThuPSJhc3Npc3RhbnRfc2VsZWN0X2VsZW1lbnRfY2FuY2VsIiB0eXBlPSJidXR0b24iIGNsYXNzPSJidG4gYnRuLWRlZmF1bHQiIGlkPSJjYW5jZWwtc2VsZWN0LW1vZGUiPjwvYnV0dG9uPgogICAgICAgIDwvZGl2PgogICAgPC9kaXY+",

"sliderMenu.html": "PGRpdiBjbGFzcz0ibWFpbiI+CiAgICA8ZGl2IGNsYXNzPSJjbG9zZSBhZGctY2xvc2UiPjwvZGl2PgogICAgPGRpdiBjbGFzcz0iaGVhZCI+CiAgICAgICAgPGRpdiBpMThuPSJhc3Npc3RhbnRfYmxvY2tfZWxlbWVudCIgY2xhc3M9ImhlYWRfdGl0bGUiIGlkPSJoZWFkX3RpdGxlIj48L2Rpdj4KICAgICAgICA8ZGl2IGkxOG49ImFzc2lzdGFudF9ibG9ja19lbGVtZW50X2V4cGxhaW4iIGNsYXNzPSJoZWFkX3RleHQiIGlkPSJoZWFkX3RleHQiPjwvZGl2PgogICAgPC9kaXY+CiAgICA8ZGl2IGNsYXNzPSJjb250ZW50IiBpZD0ic2xpZGVyLWFyZWEiPgogICAgICAgIDxkaXYgY2xhc3M9ImVsZW1lbnQtcnVsZSI+CiAgICAgICAgICAgIDxkaXYgaTE4bj0iYXNzaXN0YW50X3NsaWRlcl9leHBsYWluIiBjbGFzcz0iZWxlbWVudC1ydWxlX3RleHQiPjwvZGl2PgogICAgICAgICAgICA8ZGl2IGNsYXNzPSJlbGVtZW50LXJ1bGVfc2xpZGVyIj4KICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImFkZy1zbGlkZSIgaWQ9InNsaWRlciI+CiAgICAgICAgICAgICAgICAgICAgPGRpdiBpMThuPSJhc3Npc3RhbnRfc2xpZGVyX21heCIgY2xhc3M9ImFkZy1zbGlkZS1jbHVlLW1heCI+PC9kaXY+CiAgICAgICAgICAgICAgICAgICAgPGRpdiBpMThuPSJhc3Npc3RhbnRfc2xpZGVyX21pbiIgY2xhc3M9ImFkZy1zbGlkZS1jbHVlLW1pbiI+PC9kaXY+CiAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgIDxkaXYgY2xhc3M9ImVsZW1lbnQtcnVsZV9tb3JlIj4KICAgICAgICAgICAgICAgIAkJCTxzcGFuIGNsYXNzPSJlbGVtZW50LXJ1bGVfZXhwYW5kLWxpbmsiIGlkPSJFeHRlbmRlZFNldHRpbmdzVGV4dCI+CgkJCQkJCQk8c3BhbiBpMThuPSJhc3Npc3RhbnRfZXh0ZW5kZWRfc2V0dGluZ3MiIGNsYXNzPSJlbGVtZW50LXJ1bGVfZXhwYW5kLWxpbmtfdHh0Ij48L3NwYW4+CgkJCQkJCTxzcGFuIGNsYXNzPSJlbGVtZW50LXJ1bGVfZXhwYW5kLWxpbmtfYXJyIj48L3NwYW4+CgkJCQkJCTwvc3Bhbj4KICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgIDxkaXYgY2xhc3M9ImVsZW1lbnQtcnVsZV9mb3JtIiBpZD0iYWR2LXNldHRpbmdzIj4KICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImVsZW1lbnQtcnVsZV9mb3JtLWNvbnQiPgogICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImVsZW1lbnQtcnVsZV9maWVsZHNldCIgaWQ9Im9uZS1kb21haW4tY2hlY2tib3gtYmxvY2siPgogICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgY2xhc3M9ImZvcm0tdWktY29udHJvbCIgaWQ9Im9uZS1kb21haW4tY2hlY2tib3giIHR5cGU9ImNoZWNrYm94Ii8+CiAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9Im9uZS1kb21haW4tY2hlY2tib3giIGNsYXNzPSJmb3JtLXVpIj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGkxOG49ImFzc2lzdGFudF9hcHBseV9ydWxlX3RvX2FsbF9zaXRlcyIgY2xhc3M9ImZvcm0tdWktdHh0Ij48L3NwYW4+CiAgICAgICAgICAgICAgICAgICAgICAgIDwvbGFiZWw+CiAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgPGRpdiBzdHlsZT0iZGlzcGxheTogbm9uZTsiIGNsYXNzPSJlbGVtZW50LXJ1bGVfZmllbGRzZXQiIGlkPSJibG9jay1ieS11cmwtY2hlY2tib3gtYmxvY2siPgogICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgY2xhc3M9ImZvcm0tdWktY29udHJvbCIgaWQ9ImJsb2NrLWJ5LXVybC1jaGVja2JveCIgdHlwZT0iY2hlY2tib3giLz4KICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGZvcj0iYmxvY2stYnktdXJsLWNoZWNrYm94IiBjbGFzcz0iZm9ybS11aSI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBpMThuPSJhc3Npc3RhbnRfYmxvY2tfYnlfcmVmZXJlbmNlIiBjbGFzcz0iZm9ybS11aS10eHQiPjwvc3Bhbj4KICAgICAgICAgICAgICAgICAgICAgICAgPC9sYWJlbD4KICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPSJkaXNwbGF5OiBub25lOyIgY2xhc3M9ImVsZW1lbnQtcnVsZV9maWVsZHNldCIgaWQ9ImJsb2NrLXNpbWlsYXItY2hlY2tib3gtYmxvY2siPgogICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgY2xhc3M9ImZvcm0tdWktY29udHJvbCIgaWQ9ImJsb2NrLXNpbWlsYXItY2hlY2tib3giIHR5cGU9ImNoZWNrYm94Ii8+CiAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9ImJsb2NrLXNpbWlsYXItY2hlY2tib3giIGNsYXNzPSJmb3JtLXVpIj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGkxOG49ImFzc2lzdGFudF9ibG9ja19zaW1pbGFyIiBjbGFzcz0iZm9ybS11aS10eHQiPjwvc3Bhbj4KICAgICAgICAgICAgICAgICAgICAgICAgPC9sYWJlbD4KICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJlbGVtZW50LXJ1bGVfZmllbGRzZXQiPgogICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgY2xhc3M9ImZvcm0tY29udHJvbCIgaWQ9ImZpbHRlci1ydWxlIiB0eXBlPSJ0ZXh0Ii8+CiAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgPC9kaXY+CiAgICA8L2Rpdj4KICAgIDxkaXYgY2xhc3M9ImZvb3QiPgogICAgICAgIDxidXR0b24gaTE4bj0iYXNzaXN0YW50X2Fub3RoZXJfZWxlbWVudCIgdHlwZT0iYnV0dG9uIiBjbGFzcz0iYnRuIGJ0bi1kZWZhdWx0IiBpZD0iYWRnLWNhbmNlbCI+PC9idXR0b24+CiAgICAgICAgPGRpdiBjbGFzcz0iZm9vdF9hY3Rpb24iPgogICAgICAgICAgICA8ZGl2IGNsYXNzPSJmb290X2FjdGlvbl9idG4iPgogICAgICAgICAgICAgICAgPGJ1dHRvbiBpMThuPSJhc3Npc3RhbnRfcHJldmlldyIgdHlwZT0iYnV0dG9uIiBjbGFzcz0iYnRuIGJ0bi1wcmltYXJ5IiBpZD0iYWRnLXByZXZpZXciPjwvYnV0dG9uPgogICAgICAgICAgICAgICAgPGJ1dHRvbiBpMThuPSJhc3Npc3RhbnRfYmxvY2siIHR5cGU9ImJ1dHRvbiIgY2xhc3M9ImJ0biBidG4tY2FuY2VsIiBpZD0iYWRnLWFjY2VwdCI+PC9idXR0b24+CiAgICAgICAgICAgIDwvZGl2PgogICAgICAgIDwvZGl2PgogICAgPC9kaXY+CjwvZGl2Pgo=",

"blockPreview.html": "PGRpdiBjbGFzcz0ibWFpbiI+CjxkaXYgY2xhc3M9ImNsb3NlIj48L2Rpdj4KCjxkaXYgY2xhc3M9ImhlYWQiPgogICAgPGRpdiBpMThuPSJhc3Npc3RhbnRfcHJldmlld19oZWFkZXIiIGNsYXNzPSJoZWFkX3RpdGxlIj4KICAgIDwvZGl2PgogICAgPGRpdiBpMThuPSJhc3Npc3RhbnRfcHJldmlld19oZWFkZXJfaW5mbyIgY2xhc3M9ImhlYWRfdGV4dCI+CiAgICA8L2Rpdj4KPC9kaXY+Cgo8ZGl2IGNsYXNzPSJmb290Ij4KICAgIDxidXR0b24gaTE4bj0iYXNzaXN0YW50X2Fub3RoZXJfZWxlbWVudCIgY2xhc3M9ImJ0biBidG4tZGVmYXVsdCIgaWQ9InNlbGVjdC1hbm90aGVyLWVsZW1lbnQiIHR5cGU9ImJ1dHRvbiI+PC9idXR0b24+CgogICAgPGRpdiBjbGFzcz0iZm9vdF9hY3Rpb24iPgogICAgICAgIDxkaXYgY2xhc3M9ImZvb3RfYWN0aW9uX2J0biI+CiAgICAgICAgICAgIDxidXR0b24gaTE4bj0iYXNzaXN0YW50X3ByZXZpZXdfZW5kIiBjbGFzcz0iYnRuIGJ0bi1wcmltYXJ5IiBpZD0iZW5kLXByZXZpZXciIHR5cGU9ImJ1dHRvbiI+PC9idXR0b24+CiAgICAgICAgICAgIDxidXR0b24gaTE4bj0iYXNzaXN0YW50X2Jsb2NrIiBjbGFzcz0iYnRuIGJ0bi1jYW5jZWwiIGlkPSJibG9jay1lbGVtZW50IiB0eXBlPSJidXR0b24iPjwvYnV0dG9uPgogICAgICAgIDwvZGl2PgogICAgPC9kaXY+CjwvZGl2Pgo8L2Rpdj4=",

"settingsMenu.html": "PGRpdiBjbGFzcz0ibWFpbiI+CiAgICA8ZGl2IGNsYXNzPSJjbG9zZSI+PC9kaXY+CgogICAgPGRpdiBjbGFzcz0iaGVhZCI+CiAgICAgICAgPGRpdiBpMThuPSJhc3Npc3RhbnRfc2V0dGluZ3MiIGNsYXNzPSJoZWFkX3RpdGxlIj4KICAgICAgICA8L2Rpdj4KICAgICAgICA8ZGl2IGkxOG49InNldHRpbmdzX2Nob29zZV9zaXplX2FuZF9wb3NpdGlvbiIgY2xhc3M9ImhlYWRfdGV4dCI+CiAgICAgICAgPC9kaXY+CiAgICA8L2Rpdj4KCiAgICA8ZGl2IGNsYXNzPSJjb250ZW50Ij4KICAgICAgICA8ZGl2IGNsYXNzPSJzZXR0aW5ncyBzZXR0aW5nc19faG9yaXpvbnRhbCI+CgogICAgICAgICAgICA8ZGl2IGNsYXNzPSJzZXR0aW5nc19maWVsZHNldCI+CiAgICAgICAgICAgICAgICA8ZGl2IGkxOG49InNldHRpbmdzX2ljb25fc2l6ZSIgY2xhc3M9InNldHRpbmdzX2ZpZWxkc2V0X2xibCI+CiAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InNldHRpbmdzX2ZpZWxkc2V0X3ZhbCI+CiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iY2hvaWNlLXNpemUiPgogICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJjaG9pY2Utc2l6ZV9ncm91cCI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJjaG9pY2Utc2l6ZV9maWVsZCI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IGNsYXNzPSJjaG9pY2Utc2l6ZV9pbnB1dCBmb3JtLXVpLWNvbnRyb2wiIGlkPSJzaXplLXNtYWxsIiB0eXBlPSJyYWRpbyIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZT0icmFkaW8iPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz0iZm9ybS11aSIgZm9yPSJzaXplLXNtYWxsIj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBpMThuPSJzZXR0aW5nc19zbWFsbCIgY2xhc3M9ImZvcm0tdWktdHh0Ij4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9sYWJlbD4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSJjaG9pY2Utc2l6ZV9sb2dvIj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0iYS1sb2dvIGEtbG9nb19fc21hbGwiPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0ibG9nbyI+PC9zcGFuPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iY2hvaWNlLXNpemVfZmllbGQiPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCBjbGFzcz0iY2hvaWNlLXNpemVfaW5wdXQgZm9ybS11aS1jb250cm9sIiBpZD0ic2l6ZS1iaWciIHR5cGU9InJhZGlvIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lPSJyYWRpbyI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPSJmb3JtLXVpIiBmb3I9InNpemUtYmlnIj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBpMThuPSJzZXR0aW5nc19iaWciIGNsYXNzPSJmb3JtLXVpLXR4dCI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbGFiZWw+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0iY2hvaWNlLXNpemVfbG9nbyI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9ImEtbG9nbyI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSJsb2dvIj48L3NwYW4+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgIDwvZGl2PgoKCiAgICAgICAgICAgIDxkaXYgY2xhc3M9InNldHRpbmdzX2ZpZWxkc2V0Ij4KICAgICAgICAgICAgICAgIDxkaXYgaTE4bj0ic2V0dGluZ3NfcG9zaXRpb24iIGNsYXNzPSJzZXR0aW5nc19maWVsZHNldF9sYmwgc2V0dGluZ3NfZmllbGRzZXRfbGJsX19wb3MiPgogICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJzZXR0aW5nc19maWVsZHNldF92YWwiPgogICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImNoYW5nZS1wb3NpdGlvbiI+CiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImNoYW5nZS1wb3NpdGlvbl9pIj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPSJyYWRpbyIgbmFtZT0icG9zaXRpb24iIGNsYXNzPSJjaGFuZ2UtcG9zaXRpb25faW5wdXQiIGlkPSJwb3NpdGlvbi10b3AtbGVmdCI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9ImNoYW5nZS1wb3NpdGlvbl9sYWJlbCIgZm9yPSJwb3NpdGlvbi10b3AtbGVmdCI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9InMtcG9zaXRpb24tYXJyLXRvcC1sZWZ0Ij48L3NwYW4+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2xhYmVsPgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgaTE4bj0ic2V0dGluZ3NfbGVmdF90b3AiIGNsYXNzPSJjaGFuZ2UtcG9zaXRpb25fdmFsIj48L2Rpdj4KICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImNoYW5nZS1wb3NpdGlvbl9pIj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPSJyYWRpbyIgbmFtZT0icG9zaXRpb24iIGNsYXNzPSJjaGFuZ2UtcG9zaXRpb25faW5wdXQiIGlkPSJwb3NpdGlvbi10b3AtcmlnaHQiPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPSJjaGFuZ2UtcG9zaXRpb25fbGFiZWwiIGZvcj0icG9zaXRpb24tdG9wLXJpZ2h0Ij4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0icy1wb3NpdGlvbi1hcnItdG9wLXJpZ2h0Ij48L3NwYW4+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2xhYmVsPgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgaTE4bj0ic2V0dGluZ3NfcmlnaHRfdG9wIiBjbGFzcz0iY2hhbmdlLXBvc2l0aW9uX3ZhbCI+PC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJjaGFuZ2UtcG9zaXRpb25faSI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT0icmFkaW8iIG5hbWU9InBvc2l0aW9uIiBjbGFzcz0iY2hhbmdlLXBvc2l0aW9uX2lucHV0IiBpZD0icG9zaXRpb24tYm90dG9tLWxlZnQiPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPSJjaGFuZ2UtcG9zaXRpb25fbGFiZWwiIGZvcj0icG9zaXRpb24tYm90dG9tLWxlZnQiPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSJzLXBvc2l0aW9uLWFyci1ib3R0b20tbGVmdCI+PC9zcGFuPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9sYWJlbD4KCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGkxOG49InNldHRpbmdzX2xlZnRfYm90dG9tIiBjbGFzcz0iY2hhbmdlLXBvc2l0aW9uX3ZhbCI+PC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJjaGFuZ2UtcG9zaXRpb25faSI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT0icmFkaW8iIG5hbWU9InBvc2l0aW9uIiBjbGFzcz0iY2hhbmdlLXBvc2l0aW9uX2lucHV0IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkPSJwb3NpdGlvbi1ib3R0b20tcmlnaHQiPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPSJjaGFuZ2UtcG9zaXRpb25fbGFiZWwiIGZvcj0icG9zaXRpb24tYm90dG9tLXJpZ2h0Ij4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0icy1wb3NpdGlvbi1hcnItYm90dG9tLXJpZ2h0Ij48L3NwYW4+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2xhYmVsPgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgaTE4bj0ic2V0dGluZ3NfcmlnaHRfYm90dG9tIiBjbGFzcz0iY2hhbmdlLXBvc2l0aW9uX3ZhbCI+PC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgIDwvZGl2PgoKICAgICAgICA8L2Rpdj4KICAgIDwvZGl2PgoKCiAgICA8ZGl2IGNsYXNzPSJmb290Ij4KICAgICAgICA8ZGl2IGNsYXNzPSJmb290X2FjdGlvbiI+CiAgICAgICAgICAgIDxkaXYgY2xhc3M9ImZvb3RfYWN0aW9uX2J0biI+CiAgICAgICAgICAgICAgICA8YnV0dG9uIGkxOG49InNldHRpbmdzX2NhbmNlbCIgY2xhc3M9ImJ0biBidG4tZGVmYXVsdCIgdHlwZT0iYnV0dG9uIiBpZD0iY2FuY2VsIj48L2J1dHRvbj4KICAgICAgICAgICAgICAgIDxidXR0b24gaTE4bj0ic2V0dGluZ3Nfc2F2ZSIgY2xhc3M9ImJ0biBidG4tcHJpbWFyeSIgdHlwZT0iYnV0dG9uIiBpZD0ic2F2ZS1zZXR0aW5ncyI+PC9idXR0b24+CiAgICAgICAgICAgIDwvZGl2PgogICAgICAgIDwvZGl2PgogICAgPC9kaXY+CjwvZGl2Pg=="

};
var _getResource = function (name) {
                return Base64.decode(_resources[name]);
            }
return {getResource: _getResource};
};
/*! https://mths.be/cssescape v1.5.1 by @mathias | MIT license */
var cssEscape = (function(root, factory) { // jshint ignore:line
    // https://github.com/umdjs/umd/blob/master/returnExports.js
    // if (typeof exports == 'object') {
    //     // For Node.js.
    //     module.exports = factory(root);
    // } else if (typeof define == 'function' && define.amd) {
    //     // For AMD. Register as an anonymous module.
    //     define([], factory.bind(root, root));
    // } else {
    //     // For browser globals (not exposing the function separately).
    //     factory(root);
    // }
    return factory(root); //We use local variable because we don't want to spoil global scope
}(this, function(root) {

    if (root.CSS && root.CSS.escape) {
        return root.CSS.escape;
    }

    // https://drafts.csswg.org/cssom/#serialize-an-identifier
    var cssEscape = function(value) {
        if (arguments.length === 0) {
            throw new TypeError('`CSS.escape` requires an argument.');
        }
        var string = String(value);
        var length = string.length;
        var index = -1;
        var codeUnit;
        var result = '';
        var firstCodeUnit = string.charCodeAt(0);
        while (++index < length) {
            codeUnit = string.charCodeAt(index);
            // Note: there’s no need to special-case astral symbols, surrogate
            // pairs, or lone surrogates.

            // If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
            // (U+FFFD).
            if (codeUnit === 0x0000) {
                result += '\uFFFD';
                continue;
            }

            if (
                // If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
            // U+007F, […]
            (codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
            // If the character is the first character and is in the range [0-9]
            // (U+0030 to U+0039), […]
            (index === 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
            // If the character is the second character and is in the range [0-9]
            // (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
            (
                index == 1 &&
                codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
                firstCodeUnit == 0x002D
            )
            ) {
                // https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
                result += '\\' + codeUnit.toString(16) + ' ';
                continue;
            }

            if (
                // If the character is the first character and is a `-` (U+002D), and
            // there is no second character, […]
            index === 0 &&
            length == 1 &&
            codeUnit == 0x002D
            ) {
                result += '\\' + string.charAt(index);
                continue;
            }

            // If the character is not handled by one of the above rules and is
            // greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
            // is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
            // U+005A), or [a-z] (U+0061 to U+007A), […]
            if (
                codeUnit >= 0x0080 ||
                codeUnit == 0x002D ||
                codeUnit == 0x005F ||
                codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
                codeUnit >= 0x0041 && codeUnit <= 0x005A ||
                codeUnit >= 0x0061 && codeUnit <= 0x007A
            ) {
                // the character itself
                result += string.charAt(index);
                continue;
            }

            // Otherwise, the escaped character.
            // https://drafts.csswg.org/cssom/#escape-a-character
            result += '\\' + string.charAt(index);

        }
        return result;
    };

    if (!root.CSS) {
        root.CSS = {};
    }

    root.CSS.escape = cssEscape;
    return cssEscape;

}));
/**
 * Simple ioc implementation
 * @type {{add, get}}
 */
var Ioc = (function () { // jshint ignore:line
    var dependencies = {};

    var register = function (qualifier, obj) {
        dependencies[qualifier] = obj;
    };

    var get = function (func) {
        if (typeof func === 'string') {
            var resolved = dependencies[func];
            if (!resolved) {
                throw "Can't resolve " + func;
            }
            return resolved;
        }
        var resolvedDependencies = resolveDependencies(func);

        function FuncWrapper() {
            return func.apply(func, resolvedDependencies);
        }

        FuncWrapper.prototype = func.prototype;
        return new FuncWrapper();
    };

    var resolveDependencies = function (func) {
        var args = getArguments(func);
        var resolved = [];
        for (var i = 0; i < args.length; i++) {
            var depName = args[i].trim();
            var dep = dependencies[depName];
            if (!dep) {
                throw  "Can't find dependency: " + depName;
            }
            resolved.push(dependencies[depName]);
        }
        return resolved;
    };

    var getArguments = function (func) {
        //This regex is from require.js
        var FN_ARGS = /^function\s*[^\(]*\(\s*([^\)]*)\)/m;
        var args = func.toString().match(FN_ARGS)[1].split(',');
        if (args[0] === "") {
            return [];
        }
        return args;
    };

    return {
        register: register,
        get: get
    };

})();



/**
 * Simple logger with log levels
 * @returns {{warn: warn, info: info, debug: debug, error: error}}
 * @constructor
 */
var Log = function () { // jshint ignore:line

    var currentLevel = "INFO";

    var LogLevels = {
        ERROR: 1,
        WARN: 2,
        INFO: 3,
        DEBUG: 4
    };

    var print = function (level, method, args) {
        // gulp preprocess condition
        //check log level
        if (LogLevels[currentLevel] < LogLevels[level]) {
            return;
        }
        if (!args || args.length === 0 || !args[0]) {
            return;
        }
        var str = args[0] + "";
        args = Array.prototype.slice.call(args, 1);
        var formatted = str.replace(/{(\d+)}/g, function (match, number) {
            return typeof  args[number] !== "undefined" ? args[number] : match;
        });
        if (LogLevels[level] >= LogLevels[currentLevel]) {
            var now = new Date();
            formatted = now.toISOString() + ": " + formatted;
        }
        console[method](formatted);

    };

    var debug = function () {
        print("DEBUG", "log", arguments);
    };

    var info = function () {
        print("INFO", "info", arguments);
    };

    var warn = function () {
        print("WARN", "info", arguments);
    };

    var error = function () {
        print("ERROR", "error", arguments);
    };

    return {
        warn: warn,
        info: info,
        debug: debug,
        error: error
    };
};

/**
 * Balalaika library
 *
 * https://github.com/finom/balalaika/blob/master/balalaika.js
 *
 * The patch includes methods `addClass`, `removeClass`, `hasClass`, `get`, `css`, `hide`, `show`, `remove`, `text`, `attr`, `trigger`.
 * Also, for registration in the Ioc, the library is used through the variable `balalaika`
 */
var balalaika = (function (window, document, fn, nsRegAndEvents, id, s_EventListener, s_MatchesSelector, i, j, k, l, $) {
    $ = function (s, context) {
        return new $.i(s, context);
    };

    $.i = function (s, context) {
        var st;
        if (!s) {
            st = fn;
        } else {
            if (s.nodeType || s == window) {
                st = [s];
            } else {
                if (typeof(s) === 'string') {
                    if (/</.test(s)) {
                        st = ((i = document.createElement(context || 'q')).innerHTML = s, i.children);
                    } else {
                        st = (context && $(context)[0] || document).querySelectorAll(s);
                    }
                } else {
                    if (/f/.test(typeof s)) {
                        if (/c/.test(document.readyState)) {
                            st = s();
                        } else {
                            st = $(document).on('DOMContentLoaded', s);
                        }
                    } else {
                        st = s;
                    }
                }
            }
        }
        st = [].slice.call(st);
        fn.push.apply(this, st);
    };

    $.i[l = 'prototype'] = ( $.extend = function (obj) {
        k = arguments;
        for (i = 1; i < k.length; i++) {
            if (l = k[i]) {
                for (j in l) {
                    obj[j] = l[j];
                }
            }
        }

        return obj;
    })($.fn = $[l] = fn, { // $.fn = $.prototype = fn
        on: function (n, f) {
            // n = [ eventName, nameSpace ]
            n = n.split(nsRegAndEvents);
            this.map(function (item) {
                // item.b$ is balalaika_id for an element
                // i is eventName + id ("click75")
                // nsRegAndEvents[ i ] is array of events (eg all click events for element#75) ([[namespace, handler], [namespace, handler]])
                ( nsRegAndEvents[i = n[0] + ( item.b$ = item.b$ || ++id )] = nsRegAndEvents[i] || [] ).push([f, n[1]]);
                // item.addEventListener( eventName, f )
                item['add' + s_EventListener](n[0], f);
            });
            return this;
        },
        off: function (n, f) {
            // n = [ eventName, nameSpace ]
            n = n.split(nsRegAndEvents);
            // l = 'removeEventListener'
            l = 'remove' + s_EventListener;
            this.map(function (item) {
                // k - array of events
                // item.b$ - balalaika_id for an element
                // n[ 0 ] + item.b$ - eventName + id ("click75")
                k = nsRegAndEvents[n[0] + item.b$];
                // if array of events exist then i = length of array of events
                if (i = k && k.length) {
                    // while j = one of array of events
                    while (j = k[--i]) {
                        // if( no f and no namespace || f but no namespace || no f but namespace || f and namespace )
                        if (( !f || f == j[0] ) && ( !n[1] || n[1] == j[1] )) {
                            // item.removeEventListener( eventName, handler );
                            item[l](n[0], j[0]);
                            // remove event from array of events
                            k.splice(i, 1);
                        }
                    }
                } else {
                    // if event added before using addEventListener, just remove it using item.removeEventListener( eventName, f )
                    !n[1] && item[l](n[0], f);
                }
            });
            return this;
        },
        is: function (s) {
            i = this[0];
            return (i.matches
            || i['webkit' + s_MatchesSelector]
            || i['moz' + s_MatchesSelector]
            || i['ms' + s_MatchesSelector]
            || i['o' + s_MatchesSelector]).call(i, s);
        }
    });
    return $;
})(window, window.document, [], /\.(.+)/, 0, 'EventListener', 'MatchesSelector');

/**
 * Add some more functions to balalaika
 */
balalaika.fn.hasClass = function (className) {
    return !!this[0] && (this[0].classList != undefined) && this[0].classList.contains(className);
};

balalaika.fn.addClass = function (className) {
    this.forEach(function (item) {
        var classList = item.classList;
        classList.add.apply(classList, className.split(/\s/));
    });
    return this;
};

balalaika.fn.removeClass = function (className) {
    this.forEach(function (item) {
        var classList = item.classList;
        classList.remove.apply(classList, className.split(/\s/));
    });
    return this;
};

balalaika.fn.get = function (index) {
    return this.length > index ? this[index] : null;
};

balalaika.fn.css = function (attr, value) {
    this.forEach(function (item) {
        item.style[attr] = value;
    });
    return this;
};

balalaika.fn.hide = function () {
    this.forEach(function (item) {
        item.style['display'] = 'none';
    });
    return this;
};

balalaika.fn.show = function () {
    this.forEach(function (item) {
        item.style['display'] = 'block';
    });
    return this;
};

balalaika.fn.remove = function () {
    this.forEach(function (item) {
        item.parentNode.removeChild(item);
    });
    return this;
};

balalaika.fn.text = function (v) {
    this.forEach(function (item) {
        item.textContent = v;
    });
    return this;
};

balalaika.fn.attr = function (k, v) {
    this.forEach(function (item) {
        item.setAttribute(k, v);
    });
    return this;
};

balalaika.fn.trigger = function (eventName, options) {
    this.forEach(function (item) {
        if (window.CustomEvent) {
            var event = new CustomEvent(eventName, {detail: options});
        } else {
            var event = document.createEvent('CustomEvent');
            event.initCustomEvent(eventName, true, true, options);
        }

        item.dispatchEvent(event);
    });
    return this;
};

/**
 * Object that manages user settings.
 * @param log
 * @param gmApi
 * @returns {{Constants: {MINIMUM_IE_SUPPORTED_VERSION: number, MINIMUM_VISIBLE_HEIGHT_TO_SHOW_BUTTON: number, BUTTON_POSITION_ITEM_NAME: string, IFRAME_ID: string}, MenuItemsNames: {DetailedMenu: string, SelectorMenu: string, SliderMenu: string, BlockPreview: string, SettingsMenu: string}, getSettings: getSettings, loadSettings: loadSettings, getWotData: getWotData, setWotData: setWotData, saveSettings: saveSettings, getUserPositionForButton: getUserPositionForButton, removeUserPositionForButton: removeUserPositionForButton, selectedElement: *, setAdguardSettings: setAdguardSettings, getAdguardSettings: getAdguardSettings}}
 * @constructor
 */
var Settings = function (log, gmApi) { // jshint ignore:line
    var Constants = {
        MINIMUM_IE_SUPPORTED_VERSION: 9,
        MINIMUM_VISIBLE_HEIGHT_TO_SHOW_BUTTON: 250,
        BUTTON_POSITION_ITEM_NAME: '__adbpos',
        IFRAME_ID: 'adguard-assistant-dialog',
        REPORT_URL: 'https://adguard.com/adguard-report/{0}/report.html'
    };
    var MenuItemsNames = {
        DetailedMenu: 'mainMenu.html',
        SelectorMenu: 'selectorMenu.html',
        SliderMenu: 'sliderMenu.html',
        BlockPreview: 'blockPreview.html',
        SettingsMenu: 'settingsMenu.html'
    };

    var DefaultConfig = {
        buttonPositionTop: false,
        buttonPositionLeft: false,
        largeIcon: true,
        assistantFirstStart: true,
        scriptVersion: 1
    };

    var wotData = null;
    var adguardSettings = null;

    var Config = null;

    var loadSettings = function () {
        var config;
        log.debug("Trying to get settings");
        // Empty settings
        var settings = gmApi.GM_getValue('settings');
        try {
            config = JSON.parse(settings);
            validateSettings(config);
            log.debug('Settings parsed successfully');
        } catch (ex) {
            log.error(ex);
            config = JSON.parse(JSON.stringify(DefaultConfig));
            if (typeof settings !== 'undefined') {
                config.assistantFirstStart = false;
            }
            saveSettings(config);
        }
        Config = config;
    };

    var saveSettings = function (config) {
        log.debug("Saving settings");
        gmApi.GM_setValue('settings', JSON.stringify(config));
        Config = config;
    };

    var getSettings = function () {
        return Config;
    };

    var getWotData = function () {
        return wotData;
    };

    var setWotData = function (data) {
        wotData = data;
    };

    var setAdguardSettings = function (settings) {
        if (!settings) {
            log.info("No Adguard API Found");
            return;
        }
        adguardSettings = settings;
    };

    var getAdguardSettings = function () {
        return adguardSettings;
    };

    var removeUserPositionForButton = function () {
        localStorage.removeItem(Constants.BUTTON_POSITION_ITEM_NAME);
    };

    var setUserPositionForButton = function (coords) {
        localStorage.setItem(Constants.BUTTON_POSITION_ITEM_NAME, JSON.stringify(coords));
    };

    var getUserPositionForButton = function () {
        try {
            var userPosition = localStorage.getItem(Constants.BUTTON_POSITION_ITEM_NAME);
            log.info("Check user position for domain");
            if (userPosition) {
                log.info("User position is set for this domain");
                return JSON.parse(userPosition);
            }
        } catch (ex) {
            removeUserPositionForButton();
            log.error(ex);
        }
        return null;
    };

    var validateSettings = function (settings) {
        if (!settings) {
            throw 'Invalid settings object';
        }
        for (var prop in settings) {
            if (!settings.hasOwnProperty(prop)) {
                continue;
            }
            var property = DefaultConfig[prop];
            if (property && typeof property !== typeof settings[prop]) {
                throw 'Invalid settings object';
            }
        }
        if (settings.scriptVersion > DefaultConfig.scriptVersion) {
            throw 'Invalid settings object';
        }
    };

    return {
        Constants: Constants,
        MenuItemsNames: MenuItemsNames,
        getSettings: getSettings,
        loadSettings: loadSettings,
        getWotData: getWotData,
        setWotData: setWotData,
        saveSettings: saveSettings,
        getUserPositionForButton: getUserPositionForButton,
        removeUserPositionForButton: removeUserPositionForButton,
        setUserPositionForButton: setUserPositionForButton,
        setAdguardSettings: setAdguardSettings,
        getAdguardSettings: getAdguardSettings
    };
};

/**
 * UI utils
 * @param $
 * @returns {{makeElementDraggable: Function, makeIframeDraggable: Function, tryFullScreenPrefix: Function}}
 * @constructor
 */
var UIUtils = function($) { // jshint ignore:line
    /**
     * Make element draggable
     * @param element
     * @param onDragEnd
     * @param onClick
     */
    var makeElementDraggable = function(element, onDragEnd, onClick) {
        var events = getEvents(UIValidationUtils.isTouchDevice);

        var getCoords = function(elem) {
            var box = elem.getBoundingClientRect();
            return {
                top: box.top,
                left: box.left,
                bottom: box.bottom,
                right: box.right
            };
        };

        /**
         * Prevent text selection
         * With cursor drag
         */
        var pauseEvent = function(e) {
            e.stopPropagation();
            e.preventDefault();
            e.cancelBubble = true;
            e.returnValue = false;
            return false;
        };

        $(element).on(events.mousedown, function(e) {
            pauseEvent(e);

            // prevent right button mousedown
            if (e.button > 0) return;

            // getting screen width and height without scroll bars
            var windowWidth = Math.min(document.documentElement.clientWidth, window.innerWidth || screen.width);
            var windowHeight = Math.min(document.documentElement.clientHeight, window.innerHeight || screen.height);

            var elWidth = element.clientWidth;
            var elHeight = element.clientWidth;

            var outsidePosition = {
                top: function(pos) {
                    return storedAnchor.top && (pos.y + elHeight > windowHeight || pos.y < 0);
                },
                bottom: function(pos) {
                    return !storedAnchor.top && (Math.abs(pos.y) + elHeight > windowHeight || pos.y > 0);
                },
                left: function(pos) {
                    return storedAnchor.left && (pos.x + elWidth > windowWidth || pos.x < 0);
                },
                right: function(pos) {
                    return !storedAnchor.left && (Math.abs(pos.x) + elWidth > windowWidth || pos.x > 0);
                }
            };

            var coords = getCoords(element),
                shiftX, shiftY;

            if (storedAnchor.top) {
                shiftY = getOriginalEvent(e).pageY - coords.top;
            } else {
                shiftY = windowHeight - (coords.bottom - getOriginalEvent(e).pageY);
            }

            if (storedAnchor.left) {
                shiftX = getOriginalEvent(e).pageX - coords.left;
            } else {
                shiftX = windowWidth - (coords.right - getOriginalEvent(e).pageX);
            }

            document.body.appendChild(element);

            var onMouseUp = function(e) {
                e.stopPropagation();
                $(document).off(events.mousemove, onMouseMove);
                $(element).off(events.mouseup, onMouseUp);

                // When a user finishes dragging icon, we set icon anchor
                // depending on the icon position, i.e. which quarter
                // of the screen it belongs.
                var lastX, lastY, lastCoords = getCoords(element);

                var topHalf = lastCoords.top < windowHeight / 2;
                var leftHalf = lastCoords.left < windowWidth / 2;

                setAnchorPosition.positionY(element, topHalf);
                setAnchorPosition.positionX(element, leftHalf);

                if (topHalf) {
                    lastY = lastCoords.top;
                } else {
                    lastY = lastCoords.bottom - windowHeight;
                }

                if (leftHalf) {
                    lastX = lastCoords.left;
                } else {
                    lastX = lastCoords.right - windowWidth;
                }

                moveElementTo(element, lastX, lastY);

                if ((coords.left !== lastCoords.left) || (coords.top !== lastCoords.top)) {
                    if (onDragEnd) {
                        var store = {
                            "x": lastX,
                            "y": lastY,
                            "storedAnchor": storedAnchor
                        };
                        onDragEnd(store);
                    }
                } else {
                    if (onClick) {
                        onClick(e);
                        e.stopPropagation();
                    }
                }
            };

            var moveAt = function(e) {
                var position = {
                    x: getOriginalEvent(e).pageX - shiftX,
                    y: getOriginalEvent(e).pageY - shiftY
                };

                // disable mousemove if button element outside the screen
                var out = outsidePosition.top(position) ||
                    outsidePosition.left(position) ||
                    outsidePosition.bottom(position) ||
                    outsidePosition.right(position);

                if (out) {
                    onMouseUp(e);
                } else {
                    moveElementTo(element, position.x, position.y);
                }
            };

            moveAt(e);

            var onMouseMove = function(e) {
                e.stopPropagation();
                pauseEvent(e);
                moveAt(e);
            };

            $(document).on(events.mousemove, onMouseMove);
            $(element).on(events.mouseup, onMouseUp);
        });

        $(element).on('dragstart', function() {
            return false;
        });
    };

    /**
     * Makes iframe draggable
     *
     * @param iframe
     * @param handleElement
     */
    var makeIframeDraggable = function(iframe, handleElement) {
        var events = getEvents(UIValidationUtils.isTouchDevice);
        var iframeJ = iframe;
        var dragHandle = handleElement;
        var $iframeDocument = $(iframe[0].contentDocument);

        var offset = Object.create(null);

        /**
         * Generalized function to get position of an event (like mousedown, mousemove, etc)
         *
         * @param e
         * @returns {{x: (Number|number), y: (Number|number)}}
         */
        var getEventPosition = function(e) {
            if (!e) {
                e = window.event;
            }
            return {
                x: e.screenX,
                y: e.screenY
            };
        };

        /**
         * Function that does actual "dragging"
         *
         * @param x
         * @param y
         */
        var drag = function(x, y) {
            var newPositionX = x;
            var newPositionY = y;
            // Don't drag it off the top or left of the screen?
            if (newPositionX < 0) {
                newPositionX = 0;
            }
            if (newPositionY < 0) {
                newPositionY = 0;
            }

            iframeJ.css('left', newPositionX + 'px');
            iframeJ.css('top', newPositionY + 'px');
        };

        var cancelIFrameSelection = function(e) {
            e.preventDefault();
            e.stopPropagation();
        };

        var onMouseMove = function(e) {
            var eventPosition = getEventPosition(e);
            drag(eventPosition.x + offset.x, eventPosition.y + offset.y);
        };

        var onMouseDown = function(e) {
            var eventPosition = getEventPosition(e);
            var dragHandleEl = dragHandle.get(0);
            var rect = iframeJ.get(0).getBoundingClientRect();

            offset.x = rect.left + dragHandleEl.offsetLeft - eventPosition.x;
            offset.y = rect.top + dragHandleEl.offsetTop - eventPosition.y;

            $iframeDocument.on(events.mousemove, onMouseMove);
            $iframeDocument.on('selectstart', cancelIFrameSelection);
        };

        var onMouseUp = function() {
            $iframeDocument.off(events.mousemove, onMouseMove);
            $iframeDocument.off('selectstart', cancelIFrameSelection);
        };

        dragHandle.on(events.mousedown, onMouseDown);
        $iframeDocument.on(events.mouseup, onMouseUp);
    };

    var browserPrefixes = ["webkit", "moz", "ms", "o", ""];

    /*
     Checks prefixes for full screen mode.
     */
    var tryFullScreenPrefix = function(obj, method) {
        var i = 0,
            currentMethod = null,
            type;
        while (i < browserPrefixes.length && !obj[currentMethod]) {
            currentMethod = method;
            if (browserPrefixes[i] === "") {
                currentMethod = currentMethod.substr(0, 1).toLowerCase() + currentMethod.substr(1);
            }
            currentMethod = browserPrefixes[i] + currentMethod;
            type = typeof obj[currentMethod];
            if (type !== "undefined") {
                browserPrefixes = [browserPrefixes[i]];
                return (type === "function" ? obj[currentMethod]() : obj[currentMethod]);
            }
            i++;
        }
    };

    /**
     * Set transition css property for drag
     * translate3d is for better rendering performance
     * see: https://www.html5rocks.com/en/tutorials/speed/layers/
     */
    var moveElementTo = function(el, x, y) {
        var transform = 'translate3d(' + x + 'px,' + y + 'px, 0px)';
        el.style.webkitTransform = transform;
        el.style.mozTransform = transform;
        el.style.msTransform = transform;
        el.style.oTransform = transform;
        el.style.transform = transform;
    };

    /**
     * Get touch event strings for touch devices
     * @param {Boolean}
     * @return {Object}
     */
    var getEvents = function(isTouch) {
        return {
            mousedown: isTouch ? 'touchstart' : 'mousedown',
            mousemove: isTouch ? 'touchmove' : 'mousemove',
            mouseup: isTouch ? 'touchend' : 'mouseup'
        };
    };

    /**
     * Get original event object for touch
     * devices to getting current coordinates
     * @param {Object}
     * @return {Object}
     */
    var getOriginalEvent = function(e) {
        return e.targetTouches ? e.targetTouches[0] : e;
    };

    /**
     * Functions for saving left/top anchors and setting class position
     *
     * @param {Object} element  button element
     * @param {Boolean} anchor  anchors positions `true` for top/left or `false` for bottom/right
     */
    var setAnchorPosition = {
        positionY: function(element, anchor) {
            storedAnchor.top = anchor;

            if (storedAnchor.top) {
                $(element).addClass('adguard-assistant-button-top');
                $(element).removeClass('adguard-assistant-button-bottom');
            } else {
                $(element).addClass('adguard-assistant-button-bottom');
                $(element).removeClass('adguard-assistant-button-top');
            }
        },
        positionX: function(element, anchor) {
            storedAnchor.left = anchor;

            if (storedAnchor.left) {
                $(element).addClass('adguard-assistant-button-left');
                $(element).removeClass('adguard-assistant-button-right');
            } else {
                $(element).addClass('adguard-assistant-button-right');
                $(element).removeClass('adguard-assistant-button-left');
            }
        }
    };

    var storedAnchor = {
        top: false,
        left: false
    };

    return {
        makeElementDraggable: makeElementDraggable,
        makeIframeDraggable: makeIframeDraggable,
        tryFullScreenPrefix: tryFullScreenPrefix,
        moveElementTo: moveElementTo,
        setAnchorPosition: setAnchorPosition
    };
};

/**
 * Utils that checks environment for compatibility with assistant
 * @param settings
 * @returns {{checkVisibleAreaSize: checkVisibleAreaSize, validateBrowser: validateBrowser, validatePage: validatePage}}
 * @constructor
 */
var UIValidationUtils = function(settings) { // jshint ignore:line
    var document = window.document;
    /**
     * Check if visible area are enough to show menu.
     * @returns boolean. True if area enough
     */
    var checkVisibleAreaSize = function() {
        var viewPort = getViewPort();
        return viewPort.height > settings.Constants.MINIMUM_VISIBLE_HEIGHT_TO_SHOW_BUTTON;
    };

    var getViewPort = function() {
        var viewPortWidth;
        var viewPortHeight;

        viewPortWidth = window.innerWidth;
        viewPortHeight = window.innerHeight;

        return {
            width: viewPortWidth,
            height: viewPortHeight
        };
    };

    /**
     * Checks if browser is valid for Adguard assistant
     * @returns boolean. True if browser valid
     */
    var validateBrowser = function() {
        return !document.documentMode || (document.documentMode > settings.Constants.MINIMUM_IE_SUPPORTED_VERSION);
    };

    /**
     * Checks if page is valid for Adguard assistant to work here.
     */
    var validatePage = function() {
        // Assistant do not work in iframes
        if (window.window !== window.top) {
            return false;
        }

        // Check for necessary html elements existence
        return document.getElementsByTagName('head').length &&
            document.getElementsByTagName('body').length;
    };

    var isTouchDevice = function() {
        return (('ontouchstart' in window) ||
            (navigator.MaxTouchPoints > 0) ||
            (navigator.msMaxTouchPoints > 0));
    };

    return {
        checkVisibleAreaSize: checkVisibleAreaSize,
        validateBrowser: validateBrowser,
        validatePage: validatePage,
        getViewPort: getViewPort,
        isTouchDevice: isTouchDevice
    };
};

/**
 * String utils
 */
var StringUtils = { // jshint ignore:line
    /**
     * Replaces the format items in a specified String with the text equivalents of the values of corresponding object instances.
     * @param format
     */
    format: function (format) {
        for (var i = 1; i < arguments.length; i++) {
            format = format.replace('{' + (i - 1) + '}', arguments[i]);
        }
        return format;
    }
};

/**
 * Common utils
 * @type {{getParentsLevel: Function, getNodeName: Function, getAllChilds: Function, getSingleChildren: Function, cropDomain: Function}}
 */
var CommonUtils = { // jshint ignore:line

    getParentsLevel: function (element) {
        var parent = element;
        var parentArr = [];
        while ((parent = parent.parentNode) && this.getNodeName(parent) !== "BODY") {
            parentArr.push(parent);
        }
        return parentArr;
    },

    getNodeName: function (element) {
        return element && element.nodeName ? element.nodeName.toUpperCase() : "";
    },

    getAllChildren: function (element) {
        var childArray = [];
        var child = element;
        while ((child = this.getSingleChildren(child))) {
            childArray.push(child);
        }
        return childArray;
    },

    getSingleChildren: function (element) {
        var children = element.childNodes;
        if (children) {
            var count = 0;
            var child;
            var i;
            for (i = 0; i < children.length; i++) {
                if (children[i].nodeType === 1) {
                    child = children[i];
                    count++;
                }
            }
            return count === 1 ? child : null;
        }
    },

    cropDomain: function (domain) {
        return domain.replace("www.", "").replace(/:\d+/, '');
    },

    /**
     * Force clear page cache
     * see: https://stackoverflow.com/questions/10719505/force-a-reload-of-page-in-chrome-using-javascript-no-cache/27058362#27058362
     */
    reloadPageBypassCache: function() {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', window.location.href, true);

        xhr.setRequestHeader('Pragma', 'no-cache');
        xhr.setRequestHeader('Expires', -1);
        xhr.setRequestHeader('Cache-Control', 'no-cache');

        xhr.onreadystatechange = function() {
            if (xhr.readyState === 4) {
                window.location.reload(true);
            }
        };

        xhr.send();
    }
};

/**
 * Base64 implementation
 * @type {{_keyStr: string, encode: Base64.encode, decode: Base64.decode, _utf8_encode: Base64._utf8_encode, _utf8_decode: Base64._utf8_decode}}
 */
var Base64 = {
    // private property
    _keyStr: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",

    // public method for encoding
    encode: function (input) {
        var output = "";
        var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
        var i = 0;

        input = Base64._utf8_encode(input);

        while (i < input.length) {

            chr1 = input.charCodeAt(i++);
            chr2 = input.charCodeAt(i++);
            chr3 = input.charCodeAt(i++);

            // jshint ignore:start
            enc1 = chr1 >> 2;
            enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
            enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
            enc4 = chr3 & 63;
            // jshint ignore:end

            if (isNaN(chr2)) {
                enc3 = enc4 = 64;
            } else if (isNaN(chr3)) {
                enc4 = 64;
            }

            output = output +
                Base64._keyStr.charAt(enc1) + Base64._keyStr.charAt(enc2) +
                Base64._keyStr.charAt(enc3) + Base64._keyStr.charAt(enc4);

        }

        return output;
    },

    // public method for decoding
    decode: function (input) {
        var output = "";
        var chr1, chr2, chr3;
        var enc1, enc2, enc3, enc4;
        var i = 0;

        input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

        while (i < input.length) {

            enc1 = Base64._keyStr.indexOf(input.charAt(i++));
            enc2 = Base64._keyStr.indexOf(input.charAt(i++));
            enc3 = Base64._keyStr.indexOf(input.charAt(i++));
            enc4 = Base64._keyStr.indexOf(input.charAt(i++));

            // jshint ignore:start
            chr1 = (enc1 << 2) | (enc2 >> 4);
            chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
            chr3 = ((enc3 & 3) << 6) | enc4;
            // jshint ignore:end

            output = output + String.fromCharCode(chr1);

            if (enc3 !== 64) {
                output = output + String.fromCharCode(chr2);
            }
            if (enc4 !== 64) {
                output = output + String.fromCharCode(chr3);
            }

        }

        output = Base64._utf8_decode(output);

        return output;

    },

    // private method for UTF-8 encoding
    _utf8_encode: function (string) {
        string = string.replace(/\r\n/g, "\n");
        var utftext = "";

        // jshint ignore:start
        for (var n = 0; n < string.length; n++) {

            var c = string.charCodeAt(n);

            if (c < 128) {
                utftext += String.fromCharCode(c);
            } else if ((c > 127) && (c < 2048)) {
                utftext += String.fromCharCode((c >> 6) | 192);
                utftext += String.fromCharCode((c & 63) | 128);
            } else {
                utftext += String.fromCharCode((c >> 12) | 224);
                utftext += String.fromCharCode(((c >> 6) & 63) | 128);
                utftext += String.fromCharCode((c & 63) | 128);
            }
        }
        // jshint ignore:end

        return utftext;
    },

    // private method for UTF-8 decoding
    _utf8_decode: function (utftext) {
        var string = "";
        var i = 0;
        var c = 0;
        var c2 = 0;
        var c3 = 0;

        while (i < utftext.length) {

            c = utftext.charCodeAt(i);

            if (c < 128) {
                string += String.fromCharCode(c);
                i++;
            } else if ((c > 191) && (c < 224)) {
                c2 = utftext.charCodeAt(i + 1);
                string += String.fromCharCode(((c & 31) << 6) | (c2 & 63)); // jshint ignore:line
                i += 2;
            } else {
                c2 = utftext.charCodeAt(i + 1);
                c3 = utftext.charCodeAt(i + 2);
                string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63)); // jshint ignore:line
                i += 3;
            }

        }
        return string;
    }
};

/*! http://mths.be/punycode v1.3.0 by @mathias */
var punycode = (function (root) { //We use local variable because we don't want to spoil global scope

    /** Detect free variables */
    var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
    var freeModule = typeof module == 'object' && module && !module.nodeType && module;
    var freeGlobal = typeof global == 'object' && global;
    if (
        freeGlobal.global === freeGlobal ||
        freeGlobal.window === freeGlobal ||
        freeGlobal.self === freeGlobal
    ) {
        root = freeGlobal;
    }

    /**
     * The `punycode` object.
     * @name punycode
     * @type Object
     */
    var punycode,

        /** Highest positive signed 32-bit float value */
        maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

        /** Bootstring parameters */
        base = 36,
        tMin = 1,
        tMax = 26,
        skew = 38,
        damp = 700,
        initialBias = 72,
        initialN = 128, // 0x80
        delimiter = '-', // '\x2D'

        /** Regular expressions */
        regexPunycode = /^xn--/,
        regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
        regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

        /** Error messages */
        errors = {
            'overflow': 'Overflow: input needs wider integers to process',
            'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
            'invalid-input': 'Invalid input'
        },

        /** Convenience shortcuts */
        baseMinusTMin = base - tMin,
        floor = Math.floor,
        stringFromCharCode = String.fromCharCode,

        /** Temporary variable */
        key;

    /*--------------------------------------------------------------------------*/

    /**
     * A generic error utility function.
     * @private
     * @param {String} type The error type.
     * @returns {Error} Throws a `RangeError` with the applicable error message.
     */
    function error(type) {
        throw RangeError(errors[type]);
    }

    /**
     * A generic `Array#map` utility function.
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} callback The function that gets called for every array
     * item.
     * @returns {Array} A new array of values returned by the callback function.
     */
    function map(array, fn) {
        var length = array.length;
        var result = [];
        while (length--) {
            result[length] = fn(array[length]);
        }
        return result;
    }

    /**
     * A simple `Array#map`-like wrapper to work with domain name strings or email
     * addresses.
     * @private
     * @param {String} domain The domain name or email address.
     * @param {Function} callback The function that gets called for every
     * character.
     * @returns {Array} A new string of characters returned by the callback
     * function.
     */
    function mapDomain(string, fn) {
        var labels = string.split(regexSeparators);
        // Note: each label could still contain `@` in the case of an email address.
        return map(labels, function (label) {
            var parts = label.split('@');
            return map(parts, fn).join('@');
        }).join('.');
    }

    /**
     * Creates an array containing the numeric code points of each Unicode
     * character in the string. While JavaScript uses UCS-2 internally,
     * this function will convert a pair of surrogate halves (each of which
     * UCS-2 exposes as separate characters) into a single code point,
     * matching UTF-16.
     * @see `punycode.ucs2.encode`
     * @see <http://mathiasbynens.be/notes/javascript-encoding>
     * @memberOf punycode.ucs2
     * @name decode
     * @param {String} string The Unicode input string (UCS-2).
     * @returns {Array} The new array of code points.
     */
    function ucs2decode(string) {
        var output = [],
            counter = 0,
            length = string.length,
            value,
            extra;
        while (counter < length) {
            value = string.charCodeAt(counter++);
            if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
                // high surrogate, and there is a next character
                extra = string.charCodeAt(counter++);
                if ((extra & 0xFC00) == 0xDC00) { // low surrogate
                    output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
                } else {
                    // unmatched surrogate; only append this code unit, in case the next
                    // code unit is the high surrogate of a surrogate pair
                    output.push(value);
                    counter--;
                }
            } else {
                output.push(value);
            }
        }
        return output;
    }

    /**
     * Creates a string based on an array of numeric code points.
     * @see `punycode.ucs2.decode`
     * @memberOf punycode.ucs2
     * @name encode
     * @param {Array} codePoints The array of numeric code points.
     * @returns {String} The new Unicode string (UCS-2).
     */
    function ucs2encode(array) {
        return map(array, function (value) {
            var output = '';
            if (value > 0xFFFF) {
                value -= 0x10000;
                output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
                value = 0xDC00 | value & 0x3FF;
            }
            output += stringFromCharCode(value);
            return output;
        }).join('');
    }

    /**
     * Converts a basic code point into a digit/integer.
     * @see `digitToBasic()`
     * @private
     * @param {Number} codePoint The basic numeric code point value.
     * @returns {Number} The numeric value of a basic code point (for use in
     * representing integers) in the range `0` to `base - 1`, or `base` if
     * the code point does not represent a value.
     */
    function basicToDigit(codePoint) {
        if (codePoint - 48 < 10) {
            return codePoint - 22;
        }
        if (codePoint - 65 < 26) {
            return codePoint - 65;
        }
        if (codePoint - 97 < 26) {
            return codePoint - 97;
        }
        return base;
    }

    /**
     * Converts a digit/integer into a basic code point.
     * @see `basicToDigit()`
     * @private
     * @param {Number} digit The numeric value of a basic code point.
     * @returns {Number} The basic code point whose value (when used for
     * representing integers) is `digit`, which needs to be in the range
     * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
     * used; else, the lowercase form is used. The behavior is undefined
     * if `flag` is non-zero and `digit` has no uppercase form.
     */
    function digitToBasic(digit, flag) {
        //  0..25 map to ASCII a..z or A..Z
        // 26..35 map to ASCII 0..9
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    }

    /**
     * Bias adaptation function as per section 3.4 of RFC 3492.
     * http://tools.ietf.org/html/rfc3492#section-3.4
     * @private
     */
    function adapt(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
            delta = floor(delta / baseMinusTMin);
        }
        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
    }

    /**
     * Converts a Punycode string of ASCII-only symbols to a string of Unicode
     * symbols.
     * @memberOf punycode
     * @param {String} input The Punycode string of ASCII-only symbols.
     * @returns {String} The resulting string of Unicode symbols.
     */
    function decode(input) {
        // Don't use UCS-2
        var output = [],
            inputLength = input.length,
            out,
            i = 0,
            n = initialN,
            bias = initialBias,
            basic,
            j,
            index,
            oldi,
            w,
            k,
            digit,
            t,
            /** Cached calculation results */
            baseMinusT;

        // Handle the basic code points: let `basic` be the number of input code
        // points before the last delimiter, or `0` if there is none, then copy
        // the first basic code points to the output.

        basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
            basic = 0;
        }

        for (j = 0; j < basic; ++j) {
            // if it's not a basic code point
            if (input.charCodeAt(j) >= 0x80) {
                error('not-basic');
            }
            output.push(input.charCodeAt(j));
        }

        // Main decoding loop: start just after the last delimiter if any basic code
        // points were copied; start at the beginning otherwise.

        for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

            // `index` is the index of the next character to be consumed.
            // Decode a generalized variable-length integer into `delta`,
            // which gets added to `i`. The overflow checking is easier
            // if we increase `i` as we go, then subtract off its starting
            // value at the end to obtain `delta`.
            for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

                if (index >= inputLength) {
                    error('invalid-input');
                }

                digit = basicToDigit(input.charCodeAt(index++));

                if (digit >= base || digit > floor((maxInt - i) / w)) {
                    error('overflow');
                }

                i += digit * w;
                t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

                if (digit < t) {
                    break;
                }

                baseMinusT = base - t;
                if (w > floor(maxInt / baseMinusT)) {
                    error('overflow');
                }

                w *= baseMinusT;

            }

            out = output.length + 1;
            bias = adapt(i - oldi, out, oldi == 0);

            // `i` was supposed to wrap around from `out` to `0`,
            // incrementing `n` each time, so we'll fix that now:
            if (floor(i / out) > maxInt - n) {
                error('overflow');
            }

            n += floor(i / out);
            i %= out;

            // Insert `n` at position `i` of the output
            output.splice(i++, 0, n);

        }

        return ucs2encode(output);
    }

    /**
     * Converts a string of Unicode symbols (e.g. a domain name label) to a
     * Punycode string of ASCII-only symbols.
     * @memberOf punycode
     * @param {String} input The string of Unicode symbols.
     * @returns {String} The resulting Punycode string of ASCII-only symbols.
     */
    function encode(input) {
        var n,
            delta,
            handledCPCount,
            basicLength,
            bias,
            j,
            m,
            q,
            k,
            t,
            currentValue,
            output = [],
            /** `inputLength` will hold the number of code points in `input`. */
            inputLength,
            /** Cached calculation results */
            handledCPCountPlusOne,
            baseMinusT,
            qMinusT;

        // Convert the input in UCS-2 to Unicode
        input = ucs2decode(input);

        // Cache the length
        inputLength = input.length;

        // Initialize the state
        n = initialN;
        delta = 0;
        bias = initialBias;

        // Handle the basic code points
        for (j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue < 0x80) {
                output.push(stringFromCharCode(currentValue));
            }
        }

        handledCPCount = basicLength = output.length;

        // `handledCPCount` is the number of code points that have been handled;
        // `basicLength` is the number of basic code points.

        // Finish the basic string - if it is not empty - with a delimiter
        if (basicLength) {
            output.push(delimiter);
        }

        // Main encoding loop:
        while (handledCPCount < inputLength) {

            // All non-basic code points < n have been handled already. Find the next
            // larger one:
            for (m = maxInt, j = 0; j < inputLength; ++j) {
                currentValue = input[j];
                if (currentValue >= n && currentValue < m) {
                    m = currentValue;
                }
            }

            // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
            // but guard against overflow
            handledCPCountPlusOne = handledCPCount + 1;
            if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                error('overflow');
            }

            delta += (m - n) * handledCPCountPlusOne;
            n = m;

            for (j = 0; j < inputLength; ++j) {
                currentValue = input[j];

                if (currentValue < n && ++delta > maxInt) {
                    error('overflow');
                }

                if (currentValue == n) {
                    // Represent delta as a generalized variable-length integer
                    for (q = delta, k = base; /* no condition */; k += base) {
                        t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
                        if (q < t) {
                            break;
                        }
                        qMinusT = q - t;
                        baseMinusT = base - t;
                        output.push(
                            stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
                        );
                        q = floor(qMinusT / baseMinusT);
                    }

                    output.push(stringFromCharCode(digitToBasic(q, 0)));
                    bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                    delta = 0;
                    ++handledCPCount;
                }
            }

            ++delta;
            ++n;

        }
        return output.join('');
    }

    /**
     * Converts a Punycode string representing a domain name or an email address
     * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
     * it doesn't matter if you call it on a string that has already been
     * converted to Unicode.
     * @memberOf punycode
     * @param {String} input The Punycoded domain name or email address to
     * convert to Unicode.
     * @returns {String} The Unicode representation of the given Punycode
     * string.
     */
    function toUnicode(input) {
        return mapDomain(input, function (string) {
            return regexPunycode.test(string)
                ? decode(string.slice(4).toLowerCase())
                : string;
        });
    }

    /**
     * Converts a Unicode string representing a domain name or an email address to
     * Punycode. Only the non-ASCII parts of the domain name will be converted,
     * i.e. it doesn't matter if you call it with a domain that's already in
     * ASCII.
     * @memberOf punycode
     * @param {String} input The domain name or email address to convert, as a
     * Unicode string.
     * @returns {String} The Punycode representation of the given domain name or
     * email address.
     */
    function toASCII(input) {
        return mapDomain(input, function (string) {
            return regexNonASCII.test(string)
                ? 'xn--' + encode(string)
                : string;
        });
    }

    /*--------------------------------------------------------------------------*/

    /** Define the public API */
    punycode = {
        /**
         * A string representing the current Punycode.js version number.
         * @memberOf punycode
         * @type String
         */
        'version': '1.3.0',
        /**
         * An object of methods to convert from JavaScript's internal character
         * representation (UCS-2) to Unicode code points, and back.
         * @see <http://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode
         * @type Object
         */
        'ucs2': {
            'decode': ucs2decode,
            'encode': ucs2encode
        },
        'decode': decode,
        'encode': encode,
        'toASCII': toASCII,
        'toUnicode': toUnicode
    };

    /** Expose `punycode` */
    // Some AMD build optimizers, like r.js, check for specific condition patterns
    // like the following:
    // if (typeof exports !== 'undefined') {
    //     exports.punycode = punycode;
    // } else if (
    //     typeof define == 'function' &&
    //     typeof define.amd == 'object' &&
    //     define.amd
    // ) {
    //     define('punycode', function () {
    //         return punycode;
    //     });
    // } else if (freeExports && freeModule) {
    //     if (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+
    //         freeModule.exports = punycode;
    //     } else { // in Narwhal or RingoJS v0.7.0-
    //         for (key in punycode) {
    //             punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
    //         }
    //     }
    // } else { // in Rhino or a web browser
    //     root.punycode = punycode;
    // }
    return punycode;

}(this));
/**
 * Custom event
 * @returns {{attach: attach, notify: notify}}
 * @constructor
 */
var CustomEvent = function () { // jshint ignore:line
    var listeners = [];

    var attach = function (listener) {
        listeners.push(listener);
    };

    var notify = function (args) {
        for (var i = 0; i < listeners.length; i++) {
            listeners[i](args);
        }
    };

    return {
        attach: attach,
        notify: notify
    };
};

/**
 * Diff Match and Patch
 *
 * Copyright 2006 Google Inc.
 * http://code.google.com/p/google-diff-match-patch/
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview Computes the difference between two texts to create a patch.
 * Applies the patch onto another text, allowing for errors.
 * @author fraser@google.com (Neil Fraser)
 */

/**
 * Class containing the diff, match and patch methods.
 * @constructor
 */
function diff_match_patch() {

    // Defaults.
    // Redefine these in your program to override the defaults.

    // Number of seconds to map a diff before giving up (0 for infinity).
    this.Diff_Timeout = 1.0;
    // Cost of an empty edit operation in terms of edit characters.
    this.Diff_EditCost = 4;
    // At what point is no match declared (0.0 = perfection, 1.0 = very loose).
    this.Match_Threshold = 0.5;
    // How far to search for a match (0 = exact location, 1000+ = broad match).
    // A match this many characters away from the expected location will add
    // 1.0 to the score (0.0 is a perfect match).
    this.Match_Distance = 1000;
    // When deleting a large block of text (over ~64 characters), how close do
    // the contents have to be to match the expected contents. (0.0 = perfection,
    // 1.0 = very loose).  Note that Match_Threshold controls how closely the
    // end points of a delete need to match.
    this.Patch_DeleteThreshold = 0.5;
    // Chunk size for context length.
    this.Patch_Margin = 4;

    // The number of bits in an int.
    this.Match_MaxBits = 32;
}


//  DIFF FUNCTIONS


/**
 * The data structure representing a diff is an array of tuples:
 * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
 * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
 */
var DIFF_DELETE = -1;
var DIFF_INSERT = 1;
var DIFF_EQUAL = 0;

/** @typedef {{0: number, 1: string}} */
diff_match_patch.Diff;


/**
 * Find the differences between two texts.  Simplifies the problem by stripping
 * any common prefix or suffix off the texts before diffing.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {boolean=} opt_checklines Optional speedup flag. If present and false,
 *     then don't run a line-level diff first to identify the changed areas.
 *     Defaults to true, which does a faster, slightly less optimal diff.
 * @param {number} opt_deadline Optional time when the diff should be complete
 *     by.  Used internally for recursive calls.  Users should set DiffTimeout
 *     instead.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 */
diff_match_patch.prototype.diff_main = function(text1, text2, opt_checklines,
                                                opt_deadline) {
    // Set a deadline by which time the diff must be complete.
    if (typeof opt_deadline == 'undefined') {
        if (this.Diff_Timeout <= 0) {
            opt_deadline = Number.MAX_VALUE;
        } else {
            opt_deadline = (new Date).getTime() + this.Diff_Timeout * 1000;
        }
    }
    var deadline = opt_deadline;

    // Check for null inputs.
    if (text1 == null || text2 == null) {
        throw new Error('Null input. (diff_main)');
    }

    // Check for equality (speedup).
    if (text1 == text2) {
        if (text1) {
            return [[DIFF_EQUAL, text1]];
        }
        return [];
    }

    if (typeof opt_checklines == 'undefined') {
        opt_checklines = true;
    }
    var checklines = opt_checklines;

    // Trim off common prefix (speedup).
    var commonlength = this.diff_commonPrefix(text1, text2);
    var commonprefix = text1.substring(0, commonlength);
    text1 = text1.substring(commonlength);
    text2 = text2.substring(commonlength);

    // Trim off common suffix (speedup).
    commonlength = this.diff_commonSuffix(text1, text2);
    var commonsuffix = text1.substring(text1.length - commonlength);
    text1 = text1.substring(0, text1.length - commonlength);
    text2 = text2.substring(0, text2.length - commonlength);

    // Compute the diff on the middle block.
    var diffs = this.diff_compute_(text1, text2, checklines, deadline);

    // Restore the prefix and suffix.
    if (commonprefix) {
        diffs.unshift([DIFF_EQUAL, commonprefix]);
    }
    if (commonsuffix) {
        diffs.push([DIFF_EQUAL, commonsuffix]);
    }
    this.diff_cleanupMerge(diffs);
    return diffs;
};


/**
 * Find the differences between two texts.  Assumes that the texts do not
 * have any common prefix or suffix.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {boolean} checklines Speedup flag.  If false, then don't run a
 *     line-level diff first to identify the changed areas.
 *     If true, then run a faster, slightly less optimal diff.
 * @param {number} deadline Time when the diff should be complete by.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_compute_ = function(text1, text2, checklines,
                                                    deadline) {
    var diffs;

    if (!text1) {
        // Just add some text (speedup).
        return [[DIFF_INSERT, text2]];
    }

    if (!text2) {
        // Just delete some text (speedup).
        return [[DIFF_DELETE, text1]];
    }

    var longtext = text1.length > text2.length ? text1 : text2;
    var shorttext = text1.length > text2.length ? text2 : text1;
    var i = longtext.indexOf(shorttext);
    if (i != -1) {
        // Shorter text is inside the longer text (speedup).
        diffs = [[DIFF_INSERT, longtext.substring(0, i)],
            [DIFF_EQUAL, shorttext],
            [DIFF_INSERT, longtext.substring(i + shorttext.length)]];
        // Swap insertions for deletions if diff is reversed.
        if (text1.length > text2.length) {
            diffs[0][0] = diffs[2][0] = DIFF_DELETE;
        }
        return diffs;
    }

    if (shorttext.length == 1) {
        // Single character string.
        // After the previous speedup, the character can't be an equality.
        return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
    }

    // Check to see if the problem can be split in two.
    var hm = this.diff_halfMatch_(text1, text2);
    if (hm) {
        // A half-match was found, sort out the return data.
        var text1_a = hm[0];
        var text1_b = hm[1];
        var text2_a = hm[2];
        var text2_b = hm[3];
        var mid_common = hm[4];
        // Send both pairs off for separate processing.
        var diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);
        var diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);
        // Merge the results.
        return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);
    }

    if (checklines && text1.length > 100 && text2.length > 100) {
        return this.diff_lineMode_(text1, text2, deadline);
    }

    return this.diff_bisect_(text1, text2, deadline);
};


/**
 * Do a quick line-level diff on both strings, then rediff the parts for
 * greater accuracy.
 * This speedup can produce non-minimal diffs.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {number} deadline Time when the diff should be complete by.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_lineMode_ = function(text1, text2, deadline) {
    // Scan the text on a line-by-line basis first.
    var a = this.diff_linesToChars_(text1, text2);
    text1 = a.chars1;
    text2 = a.chars2;
    var linearray = a.lineArray;

    var diffs = this.diff_main(text1, text2, false, deadline);

    // Convert the diff back to original text.
    this.diff_charsToLines_(diffs, linearray);
    // Eliminate freak matches (e.g. blank lines)
    this.diff_cleanupSemantic(diffs);

    // Rediff any replacement blocks, this time character-by-character.
    // Add a dummy entry at the end.
    diffs.push([DIFF_EQUAL, '']);
    var pointer = 0;
    var count_delete = 0;
    var count_insert = 0;
    var text_delete = '';
    var text_insert = '';
    while (pointer < diffs.length) {
        switch (diffs[pointer][0]) {
            case DIFF_INSERT:
                count_insert++;
                text_insert += diffs[pointer][1];
                break;
            case DIFF_DELETE:
                count_delete++;
                text_delete += diffs[pointer][1];
                break;
            case DIFF_EQUAL:
                // Upon reaching an equality, check for prior redundancies.
                if (count_delete >= 1 && count_insert >= 1) {
                    // Delete the offending records and add the merged ones.
                    diffs.splice(pointer - count_delete - count_insert,
                        count_delete + count_insert);
                    pointer = pointer - count_delete - count_insert;
                    var a = this.diff_main(text_delete, text_insert, false, deadline);
                    for (var j = a.length - 1; j >= 0; j--) {
                        diffs.splice(pointer, 0, a[j]);
                    }
                    pointer = pointer + a.length;
                }
                count_insert = 0;
                count_delete = 0;
                text_delete = '';
                text_insert = '';
                break;
        }
        pointer++;
    }
    diffs.pop();  // Remove the dummy entry at the end.

    return diffs;
};


/**
 * Find the 'middle snake' of a diff, split the problem in two
 * and return the recursively constructed diff.
 * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {number} deadline Time at which to bail if not yet complete.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_bisect_ = function(text1, text2, deadline) {
    // Cache the text lengths to prevent multiple calls.
    var text1_length = text1.length;
    var text2_length = text2.length;
    var max_d = Math.ceil((text1_length + text2_length) / 2);
    var v_offset = max_d;
    var v_length = 2 * max_d;
    var v1 = new Array(v_length);
    var v2 = new Array(v_length);
    // Setting all elements to -1 is faster in Chrome & Firefox than mixing
    // integers and undefined.
    for (var x = 0; x < v_length; x++) {
        v1[x] = -1;
        v2[x] = -1;
    }
    v1[v_offset + 1] = 0;
    v2[v_offset + 1] = 0;
    var delta = text1_length - text2_length;
    // If the total number of characters is odd, then the front path will collide
    // with the reverse path.
    var front = (delta % 2 != 0);
    // Offsets for start and end of k loop.
    // Prevents mapping of space beyond the grid.
    var k1start = 0;
    var k1end = 0;
    var k2start = 0;
    var k2end = 0;
    for (var d = 0; d < max_d; d++) {
        // Bail out if deadline is reached.
        if ((new Date()).getTime() > deadline) {
            break;
        }

        // Walk the front path one step.
        for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
            var k1_offset = v_offset + k1;
            var x1;
            if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {
                x1 = v1[k1_offset + 1];
            } else {
                x1 = v1[k1_offset - 1] + 1;
            }
            var y1 = x1 - k1;
            while (x1 < text1_length && y1 < text2_length &&
            text1.charAt(x1) == text2.charAt(y1)) {
                x1++;
                y1++;
            }
            v1[k1_offset] = x1;
            if (x1 > text1_length) {
                // Ran off the right of the graph.
                k1end += 2;
            } else if (y1 > text2_length) {
                // Ran off the bottom of the graph.
                k1start += 2;
            } else if (front) {
                var k2_offset = v_offset + delta - k1;
                if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
                    // Mirror x2 onto top-left coordinate system.
                    var x2 = text1_length - v2[k2_offset];
                    if (x1 >= x2) {
                        // Overlap detected.
                        return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
                    }
                }
            }
        }

        // Walk the reverse path one step.
        for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
            var k2_offset = v_offset + k2;
            var x2;
            if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {
                x2 = v2[k2_offset + 1];
            } else {
                x2 = v2[k2_offset - 1] + 1;
            }
            var y2 = x2 - k2;
            while (x2 < text1_length && y2 < text2_length &&
            text1.charAt(text1_length - x2 - 1) ==
            text2.charAt(text2_length - y2 - 1)) {
                x2++;
                y2++;
            }
            v2[k2_offset] = x2;
            if (x2 > text1_length) {
                // Ran off the left of the graph.
                k2end += 2;
            } else if (y2 > text2_length) {
                // Ran off the top of the graph.
                k2start += 2;
            } else if (!front) {
                var k1_offset = v_offset + delta - k2;
                if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
                    var x1 = v1[k1_offset];
                    var y1 = v_offset + x1 - k1_offset;
                    // Mirror x2 onto top-left coordinate system.
                    x2 = text1_length - x2;
                    if (x1 >= x2) {
                        // Overlap detected.
                        return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
                    }
                }
            }
        }
    }
    // Diff took too long and hit the deadline or
    // number of diffs equals number of characters, no commonality at all.
    return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
};


/**
 * Given the location of the 'middle snake', split the diff in two parts
 * and recurse.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {number} x Index of split point in text1.
 * @param {number} y Index of split point in text2.
 * @param {number} deadline Time at which to bail if not yet complete.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_bisectSplit_ = function(text1, text2, x, y,
                                                        deadline) {
    var text1a = text1.substring(0, x);
    var text2a = text2.substring(0, y);
    var text1b = text1.substring(x);
    var text2b = text2.substring(y);

    // Compute both diffs serially.
    var diffs = this.diff_main(text1a, text2a, false, deadline);
    var diffsb = this.diff_main(text1b, text2b, false, deadline);

    return diffs.concat(diffsb);
};


/**
 * Split two texts into an array of strings.  Reduce the texts to a string of
 * hashes where each Unicode character represents one line.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}
 *     An object containing the encoded text1, the encoded text2 and
 *     the array of unique strings.
 *     The zeroth element of the array of unique strings is intentionally blank.
 * @private
 */
diff_match_patch.prototype.diff_linesToChars_ = function(text1, text2) {
    var lineArray = [];  // e.g. lineArray[4] == 'Hello\n'
    var lineHash = {};   // e.g. lineHash['Hello\n'] == 4

    // '\x00' is a valid character, but various debuggers don't like it.
    // So we'll insert a junk entry to avoid generating a null character.
    lineArray[0] = '';

    /**
     * Split a text into an array of strings.  Reduce the texts to a string of
     * hashes where each Unicode character represents one line.
     * Modifies linearray and linehash through being a closure.
     * @param {string} text String to encode.
     * @return {string} Encoded string.
     * @private
     */
    function diff_linesToCharsMunge_(text) {
        var chars = '';
        // Walk the text, pulling out a substring for each line.
        // text.split('\n') would would temporarily double our memory footprint.
        // Modifying text would create many large strings to garbage collect.
        var lineStart = 0;
        var lineEnd = -1;
        // Keeping our own length variable is faster than looking it up.
        var lineArrayLength = lineArray.length;
        while (lineEnd < text.length - 1) {
            lineEnd = text.indexOf('\n', lineStart);
            if (lineEnd == -1) {
                lineEnd = text.length - 1;
            }
            var line = text.substring(lineStart, lineEnd + 1);
            lineStart = lineEnd + 1;

            if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) :
                    (lineHash[line] !== undefined)) {
                chars += String.fromCharCode(lineHash[line]);
            } else {
                chars += String.fromCharCode(lineArrayLength);
                lineHash[line] = lineArrayLength;
                lineArray[lineArrayLength++] = line;
            }
        }
        return chars;
    }

    var chars1 = diff_linesToCharsMunge_(text1);
    var chars2 = diff_linesToCharsMunge_(text2);
    return {chars1: chars1, chars2: chars2, lineArray: lineArray};
};


/**
 * Rehydrate the text in a diff from a string of line hashes to real lines of
 * text.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @param {!Array.<string>} lineArray Array of unique strings.
 * @private
 */
diff_match_patch.prototype.diff_charsToLines_ = function(diffs, lineArray) {
    for (var x = 0; x < diffs.length; x++) {
        var chars = diffs[x][1];
        var text = [];
        for (var y = 0; y < chars.length; y++) {
            text[y] = lineArray[chars.charCodeAt(y)];
        }
        diffs[x][1] = text.join('');
    }
};


/**
 * Determine the common prefix of two strings.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the start of each
 *     string.
 */
diff_match_patch.prototype.diff_commonPrefix = function(text1, text2) {
    // Quick check for common null cases.
    if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
        return 0;
    }
    // Binary search.
    // Performance analysis: http://neil.fraser.name/news/2007/10/09/
    var pointermin = 0;
    var pointermax = Math.min(text1.length, text2.length);
    var pointermid = pointermax;
    var pointerstart = 0;
    while (pointermin < pointermid) {
        if (text1.substring(pointerstart, pointermid) ==
            text2.substring(pointerstart, pointermid)) {
            pointermin = pointermid;
            pointerstart = pointermin;
        } else {
            pointermax = pointermid;
        }
        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
    }
    return pointermid;
};


/**
 * Determine the common suffix of two strings.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the end of each string.
 */
diff_match_patch.prototype.diff_commonSuffix = function(text1, text2) {
    // Quick check for common null cases.
    if (!text1 || !text2 ||
        text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
        return 0;
    }
    // Binary search.
    // Performance analysis: http://neil.fraser.name/news/2007/10/09/
    var pointermin = 0;
    var pointermax = Math.min(text1.length, text2.length);
    var pointermid = pointermax;
    var pointerend = 0;
    while (pointermin < pointermid) {
        if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==
            text2.substring(text2.length - pointermid, text2.length - pointerend)) {
            pointermin = pointermid;
            pointerend = pointermin;
        } else {
            pointermax = pointermid;
        }
        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
    }
    return pointermid;
};


/**
 * Determine if the suffix of one string is the prefix of another.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the end of the first
 *     string and the start of the second string.
 * @private
 */
diff_match_patch.prototype.diff_commonOverlap_ = function(text1, text2) {
    // Cache the text lengths to prevent multiple calls.
    var text1_length = text1.length;
    var text2_length = text2.length;
    // Eliminate the null case.
    if (text1_length == 0 || text2_length == 0) {
        return 0;
    }
    // Truncate the longer string.
    if (text1_length > text2_length) {
        text1 = text1.substring(text1_length - text2_length);
    } else if (text1_length < text2_length) {
        text2 = text2.substring(0, text1_length);
    }
    var text_length = Math.min(text1_length, text2_length);
    // Quick check for the worst case.
    if (text1 == text2) {
        return text_length;
    }

    // Start by looking for a single character match
    // and increase length until no match is found.
    // Performance analysis: http://neil.fraser.name/news/2010/11/04/
    var best = 0;
    var length = 1;
    while (true) {
        var pattern = text1.substring(text_length - length);
        var found = text2.indexOf(pattern);
        if (found == -1) {
            return best;
        }
        length += found;
        if (found == 0 || text1.substring(text_length - length) ==
            text2.substring(0, length)) {
            best = length;
            length++;
        }
    }
};


/**
 * Do the two texts share a substring which is at least half the length of the
 * longer text?
 * This speedup can produce non-minimal diffs.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {Array.<string>} Five element Array, containing the prefix of
 *     text1, the suffix of text1, the prefix of text2, the suffix of
 *     text2 and the common middle.  Or null if there was no match.
 * @private
 */
diff_match_patch.prototype.diff_halfMatch_ = function(text1, text2) {
    if (this.Diff_Timeout <= 0) {
        // Don't risk returning a non-optimal diff if we have unlimited time.
        return null;
    }
    var longtext = text1.length > text2.length ? text1 : text2;
    var shorttext = text1.length > text2.length ? text2 : text1;
    if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
        return null;  // Pointless.
    }
    var dmp = this;  // 'this' becomes 'window' in a closure.

    /**
     * Does a substring of shorttext exist within longtext such that the substring
     * is at least half the length of longtext?
     * Closure, but does not reference any external variables.
     * @param {string} longtext Longer string.
     * @param {string} shorttext Shorter string.
     * @param {number} i Start index of quarter length substring within longtext.
     * @return {Array.<string>} Five element Array, containing the prefix of
     *     longtext, the suffix of longtext, the prefix of shorttext, the suffix
     *     of shorttext and the common middle.  Or null if there was no match.
     * @private
     */
    function diff_halfMatchI_(longtext, shorttext, i) {
        // Start with a 1/4 length substring at position i as a seed.
        var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
        var j = -1;
        var best_common = '';
        var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
        while ((j = shorttext.indexOf(seed, j + 1)) != -1) {
            var prefixLength = dmp.diff_commonPrefix(longtext.substring(i),
                shorttext.substring(j));
            var suffixLength = dmp.diff_commonSuffix(longtext.substring(0, i),
                shorttext.substring(0, j));
            if (best_common.length < suffixLength + prefixLength) {
                best_common = shorttext.substring(j - suffixLength, j) +
                    shorttext.substring(j, j + prefixLength);
                best_longtext_a = longtext.substring(0, i - suffixLength);
                best_longtext_b = longtext.substring(i + prefixLength);
                best_shorttext_a = shorttext.substring(0, j - suffixLength);
                best_shorttext_b = shorttext.substring(j + prefixLength);
            }
        }
        if (best_common.length * 2 >= longtext.length) {
            return [best_longtext_a, best_longtext_b,
                best_shorttext_a, best_shorttext_b, best_common];
        } else {
            return null;
        }
    }

    // First check if the second quarter is the seed for a half-match.
    var hm1 = diff_halfMatchI_(longtext, shorttext,
        Math.ceil(longtext.length / 4));
    // Check again based on the third quarter.
    var hm2 = diff_halfMatchI_(longtext, shorttext,
        Math.ceil(longtext.length / 2));
    var hm;
    if (!hm1 && !hm2) {
        return null;
    } else if (!hm2) {
        hm = hm1;
    } else if (!hm1) {
        hm = hm2;
    } else {
        // Both matched.  Select the longest.
        hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
    }

    // A half-match was found, sort out the return data.
    var text1_a, text1_b, text2_a, text2_b;
    if (text1.length > text2.length) {
        text1_a = hm[0];
        text1_b = hm[1];
        text2_a = hm[2];
        text2_b = hm[3];
    } else {
        text2_a = hm[0];
        text2_b = hm[1];
        text1_a = hm[2];
        text1_b = hm[3];
    }
    var mid_common = hm[4];
    return [text1_a, text1_b, text2_a, text2_b, mid_common];
};


/**
 * Reduce the number of edits by eliminating semantically trivial equalities.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupSemantic = function(diffs) {
    var changes = false;
    var equalities = [];  // Stack of indices where equalities are found.
    var equalitiesLength = 0;  // Keeping our own length var is faster in JS.
    /** @type {?string} */
    var lastequality = null;
    // Always equal to diffs[equalities[equalitiesLength - 1]][1]
    var pointer = 0;  // Index of current position.
    // Number of characters that changed prior to the equality.
    var length_insertions1 = 0;
    var length_deletions1 = 0;
    // Number of characters that changed after the equality.
    var length_insertions2 = 0;
    var length_deletions2 = 0;
    while (pointer < diffs.length) {
        if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.
            equalities[equalitiesLength++] = pointer;
            length_insertions1 = length_insertions2;
            length_deletions1 = length_deletions2;
            length_insertions2 = 0;
            length_deletions2 = 0;
            lastequality = diffs[pointer][1];
        } else {  // An insertion or deletion.
            if (diffs[pointer][0] == DIFF_INSERT) {
                length_insertions2 += diffs[pointer][1].length;
            } else {
                length_deletions2 += diffs[pointer][1].length;
            }
            // Eliminate an equality that is smaller or equal to the edits on both
            // sides of it.
            if (lastequality && (lastequality.length <=
                Math.max(length_insertions1, length_deletions1)) &&
                (lastequality.length <= Math.max(length_insertions2,
                    length_deletions2))) {
                // Duplicate record.
                diffs.splice(equalities[equalitiesLength - 1], 0,
                    [DIFF_DELETE, lastequality]);
                // Change second copy to insert.
                diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
                // Throw away the equality we just deleted.
                equalitiesLength--;
                // Throw away the previous equality (it needs to be reevaluated).
                equalitiesLength--;
                pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
                length_insertions1 = 0;  // Reset the counters.
                length_deletions1 = 0;
                length_insertions2 = 0;
                length_deletions2 = 0;
                lastequality = null;
                changes = true;
            }
        }
        pointer++;
    }

    // Normalize the diff.
    if (changes) {
        this.diff_cleanupMerge(diffs);
    }
    this.diff_cleanupSemanticLossless(diffs);

    // Find any overlaps between deletions and insertions.
    // e.g: <del>abcxxx</del><ins>xxxdef</ins>
    //   -> <del>abc</del>xxx<ins>def</ins>
    // e.g: <del>xxxabc</del><ins>defxxx</ins>
    //   -> <ins>def</ins>xxx<del>abc</del>
    // Only extract an overlap if it is as big as the edit ahead or behind it.
    pointer = 1;
    while (pointer < diffs.length) {
        if (diffs[pointer - 1][0] == DIFF_DELETE &&
            diffs[pointer][0] == DIFF_INSERT) {
            var deletion = diffs[pointer - 1][1];
            var insertion = diffs[pointer][1];
            var overlap_length1 = this.diff_commonOverlap_(deletion, insertion);
            var overlap_length2 = this.diff_commonOverlap_(insertion, deletion);
            if (overlap_length1 >= overlap_length2) {
                if (overlap_length1 >= deletion.length / 2 ||
                    overlap_length1 >= insertion.length / 2) {
                    // Overlap found.  Insert an equality and trim the surrounding edits.
                    diffs.splice(pointer, 0,
                        [DIFF_EQUAL, insertion.substring(0, overlap_length1)]);
                    diffs[pointer - 1][1] =
                        deletion.substring(0, deletion.length - overlap_length1);
                    diffs[pointer + 1][1] = insertion.substring(overlap_length1);
                    pointer++;
                }
            } else {
                if (overlap_length2 >= deletion.length / 2 ||
                    overlap_length2 >= insertion.length / 2) {
                    // Reverse overlap found.
                    // Insert an equality and swap and trim the surrounding edits.
                    diffs.splice(pointer, 0,
                        [DIFF_EQUAL, deletion.substring(0, overlap_length2)]);
                    diffs[pointer - 1][0] = DIFF_INSERT;
                    diffs[pointer - 1][1] =
                        insertion.substring(0, insertion.length - overlap_length2);
                    diffs[pointer + 1][0] = DIFF_DELETE;
                    diffs[pointer + 1][1] =
                        deletion.substring(overlap_length2);
                    pointer++;
                }
            }
            pointer++;
        }
        pointer++;
    }
};


/**
 * Look for single edits surrounded on both sides by equalities
 * which can be shifted sideways to align the edit to a word boundary.
 * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupSemanticLossless = function(diffs) {
    /**
     * Given two strings, compute a score representing whether the internal
     * boundary falls on logical boundaries.
     * Scores range from 6 (best) to 0 (worst).
     * Closure, but does not reference any external variables.
     * @param {string} one First string.
     * @param {string} two Second string.
     * @return {number} The score.
     * @private
     */
    function diff_cleanupSemanticScore_(one, two) {
        if (!one || !two) {
            // Edges are the best.
            return 6;
        }

        // Each port of this function behaves slightly differently due to
        // subtle differences in each language's definition of things like
        // 'whitespace'.  Since this function's purpose is largely cosmetic,
        // the choice has been made to use each language's native features
        // rather than force total conformity.
        var char1 = one.charAt(one.length - 1);
        var char2 = two.charAt(0);
        var nonAlphaNumeric1 = char1.match(diff_match_patch.nonAlphaNumericRegex_);
        var nonAlphaNumeric2 = char2.match(diff_match_patch.nonAlphaNumericRegex_);
        var whitespace1 = nonAlphaNumeric1 &&
            char1.match(diff_match_patch.whitespaceRegex_);
        var whitespace2 = nonAlphaNumeric2 &&
            char2.match(diff_match_patch.whitespaceRegex_);
        var lineBreak1 = whitespace1 &&
            char1.match(diff_match_patch.linebreakRegex_);
        var lineBreak2 = whitespace2 &&
            char2.match(diff_match_patch.linebreakRegex_);
        var blankLine1 = lineBreak1 &&
            one.match(diff_match_patch.blanklineEndRegex_);
        var blankLine2 = lineBreak2 &&
            two.match(diff_match_patch.blanklineStartRegex_);

        if (blankLine1 || blankLine2) {
            // Five points for blank lines.
            return 5;
        } else if (lineBreak1 || lineBreak2) {
            // Four points for line breaks.
            return 4;
        } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {
            // Three points for end of sentences.
            return 3;
        } else if (whitespace1 || whitespace2) {
            // Two points for whitespace.
            return 2;
        } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {
            // One point for non-alphanumeric.
            return 1;
        }
        return 0;
    }

    var pointer = 1;
    // Intentionally ignore the first and last element (don't need checking).
    while (pointer < diffs.length - 1) {
        if (diffs[pointer - 1][0] == DIFF_EQUAL &&
            diffs[pointer + 1][0] == DIFF_EQUAL) {
            // This is a single edit surrounded by equalities.
            var equality1 = diffs[pointer - 1][1];
            var edit = diffs[pointer][1];
            var equality2 = diffs[pointer + 1][1];

            // First, shift the edit as far left as possible.
            var commonOffset = this.diff_commonSuffix(equality1, edit);
            if (commonOffset) {
                var commonString = edit.substring(edit.length - commonOffset);
                equality1 = equality1.substring(0, equality1.length - commonOffset);
                edit = commonString + edit.substring(0, edit.length - commonOffset);
                equality2 = commonString + equality2;
            }

            // Second, step character by character right, looking for the best fit.
            var bestEquality1 = equality1;
            var bestEdit = edit;
            var bestEquality2 = equality2;
            var bestScore = diff_cleanupSemanticScore_(equality1, edit) +
                diff_cleanupSemanticScore_(edit, equality2);
            while (edit.charAt(0) === equality2.charAt(0)) {
                equality1 += edit.charAt(0);
                edit = edit.substring(1) + equality2.charAt(0);
                equality2 = equality2.substring(1);
                var score = diff_cleanupSemanticScore_(equality1, edit) +
                    diff_cleanupSemanticScore_(edit, equality2);
                // The >= encourages trailing rather than leading whitespace on edits.
                if (score >= bestScore) {
                    bestScore = score;
                    bestEquality1 = equality1;
                    bestEdit = edit;
                    bestEquality2 = equality2;
                }
            }

            if (diffs[pointer - 1][1] != bestEquality1) {
                // We have an improvement, save it back to the diff.
                if (bestEquality1) {
                    diffs[pointer - 1][1] = bestEquality1;
                } else {
                    diffs.splice(pointer - 1, 1);
                    pointer--;
                }
                diffs[pointer][1] = bestEdit;
                if (bestEquality2) {
                    diffs[pointer + 1][1] = bestEquality2;
                } else {
                    diffs.splice(pointer + 1, 1);
                    pointer--;
                }
            }
        }
        pointer++;
    }
};

// Define some regex patterns for matching boundaries.
diff_match_patch.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;
diff_match_patch.whitespaceRegex_ = /\s/;
diff_match_patch.linebreakRegex_ = /[\r\n]/;
diff_match_patch.blanklineEndRegex_ = /\n\r?\n$/;
diff_match_patch.blanklineStartRegex_ = /^\r?\n\r?\n/;

/**
 * Reduce the number of edits by eliminating operationally trivial equalities.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupEfficiency = function(diffs) {
    var changes = false;
    var equalities = [];  // Stack of indices where equalities are found.
    var equalitiesLength = 0;  // Keeping our own length var is faster in JS.
    /** @type {?string} */
    var lastequality = null;
    // Always equal to diffs[equalities[equalitiesLength - 1]][1]
    var pointer = 0;  // Index of current position.
    // Is there an insertion operation before the last equality.
    var pre_ins = false;
    // Is there a deletion operation before the last equality.
    var pre_del = false;
    // Is there an insertion operation after the last equality.
    var post_ins = false;
    // Is there a deletion operation after the last equality.
    var post_del = false;
    while (pointer < diffs.length) {
        if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.
            if (diffs[pointer][1].length < this.Diff_EditCost &&
                (post_ins || post_del)) {
                // Candidate found.
                equalities[equalitiesLength++] = pointer;
                pre_ins = post_ins;
                pre_del = post_del;
                lastequality = diffs[pointer][1];
            } else {
                // Not a candidate, and can never become one.
                equalitiesLength = 0;
                lastequality = null;
            }
            post_ins = post_del = false;
        } else {  // An insertion or deletion.
            if (diffs[pointer][0] == DIFF_DELETE) {
                post_del = true;
            } else {
                post_ins = true;
            }
            /*
             * Five types to be split:
             * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>
             * <ins>A</ins>X<ins>C</ins><del>D</del>
             * <ins>A</ins><del>B</del>X<ins>C</ins>
             * <ins>A</del>X<ins>C</ins><del>D</del>
             * <ins>A</ins><del>B</del>X<del>C</del>
             */
            if (lastequality && ((pre_ins && pre_del && post_ins && post_del) ||
                ((lastequality.length < this.Diff_EditCost / 2) &&
                (pre_ins + pre_del + post_ins + post_del) == 3))) {
                // Duplicate record.
                diffs.splice(equalities[equalitiesLength - 1], 0,
                    [DIFF_DELETE, lastequality]);
                // Change second copy to insert.
                diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
                equalitiesLength--;  // Throw away the equality we just deleted;
                lastequality = null;
                if (pre_ins && pre_del) {
                    // No changes made which could affect previous entry, keep going.
                    post_ins = post_del = true;
                    equalitiesLength = 0;
                } else {
                    equalitiesLength--;  // Throw away the previous equality.
                    pointer = equalitiesLength > 0 ?
                        equalities[equalitiesLength - 1] : -1;
                    post_ins = post_del = false;
                }
                changes = true;
            }
        }
        pointer++;
    }

    if (changes) {
        this.diff_cleanupMerge(diffs);
    }
};


/**
 * Reorder and merge like edit sections.  Merge equalities.
 * Any edit section can move as long as it doesn't cross an equality.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupMerge = function(diffs) {
    diffs.push([DIFF_EQUAL, '']);  // Add a dummy entry at the end.
    var pointer = 0;
    var count_delete = 0;
    var count_insert = 0;
    var text_delete = '';
    var text_insert = '';
    var commonlength;
    while (pointer < diffs.length) {
        switch (diffs[pointer][0]) {
            case DIFF_INSERT:
                count_insert++;
                text_insert += diffs[pointer][1];
                pointer++;
                break;
            case DIFF_DELETE:
                count_delete++;
                text_delete += diffs[pointer][1];
                pointer++;
                break;
            case DIFF_EQUAL:
                // Upon reaching an equality, check for prior redundancies.
                if (count_delete + count_insert > 1) {
                    if (count_delete !== 0 && count_insert !== 0) {
                        // Factor out any common prefixies.
                        commonlength = this.diff_commonPrefix(text_insert, text_delete);
                        if (commonlength !== 0) {
                            if ((pointer - count_delete - count_insert) > 0 &&
                                diffs[pointer - count_delete - count_insert - 1][0] ==
                                DIFF_EQUAL) {
                                diffs[pointer - count_delete - count_insert - 1][1] +=
                                    text_insert.substring(0, commonlength);
                            } else {
                                diffs.splice(0, 0, [DIFF_EQUAL,
                                    text_insert.substring(0, commonlength)]);
                                pointer++;
                            }
                            text_insert = text_insert.substring(commonlength);
                            text_delete = text_delete.substring(commonlength);
                        }
                        // Factor out any common suffixies.
                        commonlength = this.diff_commonSuffix(text_insert, text_delete);
                        if (commonlength !== 0) {
                            diffs[pointer][1] = text_insert.substring(text_insert.length -
                                    commonlength) + diffs[pointer][1];
                            text_insert = text_insert.substring(0, text_insert.length -
                                commonlength);
                            text_delete = text_delete.substring(0, text_delete.length -
                                commonlength);
                        }
                    }
                    // Delete the offending records and add the merged ones.
                    if (count_delete === 0) {
                        diffs.splice(pointer - count_insert,
                            count_delete + count_insert, [DIFF_INSERT, text_insert]);
                    } else if (count_insert === 0) {
                        diffs.splice(pointer - count_delete,
                            count_delete + count_insert, [DIFF_DELETE, text_delete]);
                    } else {
                        diffs.splice(pointer - count_delete - count_insert,
                            count_delete + count_insert, [DIFF_DELETE, text_delete],
                            [DIFF_INSERT, text_insert]);
                    }
                    pointer = pointer - count_delete - count_insert +
                        (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;
                } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {
                    // Merge this equality with the previous one.
                    diffs[pointer - 1][1] += diffs[pointer][1];
                    diffs.splice(pointer, 1);
                } else {
                    pointer++;
                }
                count_insert = 0;
                count_delete = 0;
                text_delete = '';
                text_insert = '';
                break;
        }
    }
    if (diffs[diffs.length - 1][1] === '') {
        diffs.pop();  // Remove the dummy entry at the end.
    }

    // Second pass: look for single edits surrounded on both sides by equalities
    // which can be shifted sideways to eliminate an equality.
    // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
    var changes = false;
    pointer = 1;
    // Intentionally ignore the first and last element (don't need checking).
    while (pointer < diffs.length - 1) {
        if (diffs[pointer - 1][0] == DIFF_EQUAL &&
            diffs[pointer + 1][0] == DIFF_EQUAL) {
            // This is a single edit surrounded by equalities.
            if (diffs[pointer][1].substring(diffs[pointer][1].length -
                    diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
                // Shift the edit over the previous equality.
                diffs[pointer][1] = diffs[pointer - 1][1] +
                    diffs[pointer][1].substring(0, diffs[pointer][1].length -
                        diffs[pointer - 1][1].length);
                diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
                diffs.splice(pointer - 1, 1);
                changes = true;
            } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==
                diffs[pointer + 1][1]) {
                // Shift the edit over the next equality.
                diffs[pointer - 1][1] += diffs[pointer + 1][1];
                diffs[pointer][1] =
                    diffs[pointer][1].substring(diffs[pointer + 1][1].length) +
                    diffs[pointer + 1][1];
                diffs.splice(pointer + 1, 1);
                changes = true;
            }
        }
        pointer++;
    }
    // If shifts were made, the diff needs reordering and another shift sweep.
    if (changes) {
        this.diff_cleanupMerge(diffs);
    }
};


/**
 * loc is a location in text1, compute and return the equivalent location in
 * text2.
 * e.g. 'The cat' vs 'The big cat', 1->1, 5->8
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @param {number} loc Location within text1.
 * @return {number} Location within text2.
 */
diff_match_patch.prototype.diff_xIndex = function(diffs, loc) {
    var chars1 = 0;
    var chars2 = 0;
    var last_chars1 = 0;
    var last_chars2 = 0;
    var x;
    for (x = 0; x < diffs.length; x++) {
        if (diffs[x][0] !== DIFF_INSERT) {  // Equality or deletion.
            chars1 += diffs[x][1].length;
        }
        if (diffs[x][0] !== DIFF_DELETE) {  // Equality or insertion.
            chars2 += diffs[x][1].length;
        }
        if (chars1 > loc) {  // Overshot the location.
            break;
        }
        last_chars1 = chars1;
        last_chars2 = chars2;
    }
    // Was the location was deleted?
    if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {
        return last_chars2;
    }
    // Add the remaining character length.
    return last_chars2 + (loc - last_chars1);
};


/**
 * Convert a diff array into a pretty HTML report.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {string} HTML representation.
 */
diff_match_patch.prototype.diff_prettyHtml = function(diffs) {
    var html = [];
    var pattern_amp = /&/g;
    var pattern_lt = /</g;
    var pattern_gt = />/g;
    var pattern_para = /\n/g;
    for (var x = 0; x < diffs.length; x++) {
        var op = diffs[x][0];    // Operation (insert, delete, equal)
        var data = diffs[x][1];  // Text of change.
        var text = data.replace(pattern_amp, '&amp;').replace(pattern_lt, '&lt;')
            .replace(pattern_gt, '&gt;').replace(pattern_para, '&para;<br>');
        switch (op) {
            case DIFF_INSERT:
                html[x] = '<ins style="background:#e6ffe6;">' + text + '</ins>';
                break;
            case DIFF_DELETE:
                html[x] = '<del style="background:#ffe6e6;">' + text + '</del>';
                break;
            case DIFF_EQUAL:
                html[x] = '<span>' + text + '</span>';
                break;
        }
    }
    return html.join('');
};


/**
 * Compute and return the source text (all equalities and deletions).
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {string} Source text.
 */
diff_match_patch.prototype.diff_text1 = function(diffs) {
    var text = [];
    for (var x = 0; x < diffs.length; x++) {
        if (diffs[x][0] !== DIFF_INSERT) {
            text[x] = diffs[x][1];
        }
    }
    return text.join('');
};


/**
 * Compute and return the destination text (all equalities and insertions).
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {string} Destination text.
 */
diff_match_patch.prototype.diff_text2 = function(diffs) {
    var text = [];
    for (var x = 0; x < diffs.length; x++) {
        if (diffs[x][0] !== DIFF_DELETE) {
            text[x] = diffs[x][1];
        }
    }
    return text.join('');
};


/**
 * Compute the Levenshtein distance; the number of inserted, deleted or
 * substituted characters.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {number} Number of changes.
 */
diff_match_patch.prototype.diff_levenshtein = function(diffs) {
    var levenshtein = 0;
    var insertions = 0;
    var deletions = 0;
    for (var x = 0; x < diffs.length; x++) {
        var op = diffs[x][0];
        var data = diffs[x][1];
        switch (op) {
            case DIFF_INSERT:
                insertions += data.length;
                break;
            case DIFF_DELETE:
                deletions += data.length;
                break;
            case DIFF_EQUAL:
                // A deletion and an insertion is one substitution.
                levenshtein += Math.max(insertions, deletions);
                insertions = 0;
                deletions = 0;
                break;
        }
    }
    levenshtein += Math.max(insertions, deletions);
    return levenshtein;
};


/**
 * Crush the diff into an encoded string which describes the operations
 * required to transform text1 into text2.
 * E.g. =3\t-2\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.
 * Operations are tab-separated.  Inserted text is escaped using %xx notation.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {string} Delta text.
 */
diff_match_patch.prototype.diff_toDelta = function(diffs) {
    var text = [];
    for (var x = 0; x < diffs.length; x++) {
        switch (diffs[x][0]) {
            case DIFF_INSERT:
                text[x] = '+' + encodeURI(diffs[x][1]);
                break;
            case DIFF_DELETE:
                text[x] = '-' + diffs[x][1].length;
                break;
            case DIFF_EQUAL:
                text[x] = '=' + diffs[x][1].length;
                break;
        }
    }
    return text.join('\t').replace(/%20/g, ' ');
};


/**
 * Given the original text1, and an encoded string which describes the
 * operations required to transform text1 into text2, compute the full diff.
 * @param {string} text1 Source string for the diff.
 * @param {string} delta Delta text.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @throws {!Error} If invalid input.
 */
diff_match_patch.prototype.diff_fromDelta = function(text1, delta) {
    var diffs = [];
    var diffsLength = 0;  // Keeping our own length var is faster in JS.
    var pointer = 0;  // Cursor in text1
    var tokens = delta.split(/\t/g);
    for (var x = 0; x < tokens.length; x++) {
        // Each token begins with a one character parameter which specifies the
        // operation of this token (delete, insert, equality).
        var param = tokens[x].substring(1);
        switch (tokens[x].charAt(0)) {
            case '+':
                try {
                    diffs[diffsLength++] = [DIFF_INSERT, decodeURI(param)];
                } catch (ex) {
                    // Malformed URI sequence.
                    throw new Error('Illegal escape in diff_fromDelta: ' + param);
                }
                break;
            case '-':
            // Fall through.
            case '=':
                var n = parseInt(param, 10);
                if (isNaN(n) || n < 0) {
                    throw new Error('Invalid number in diff_fromDelta: ' + param);
                }
                var text = text1.substring(pointer, pointer += n);
                if (tokens[x].charAt(0) == '=') {
                    diffs[diffsLength++] = [DIFF_EQUAL, text];
                } else {
                    diffs[diffsLength++] = [DIFF_DELETE, text];
                }
                break;
            default:
                // Blank tokens are ok (from a trailing \t).
                // Anything else is an error.
                if (tokens[x]) {
                    throw new Error('Invalid diff operation in diff_fromDelta: ' +
                        tokens[x]);
                }
        }
    }
    if (pointer != text1.length) {
        throw new Error('Delta length (' + pointer +
            ') does not equal source text length (' + text1.length + ').');
    }
    return diffs;
};


//  MATCH FUNCTIONS


/**
 * Locate the best instance of 'pattern' in 'text' near 'loc'.
 * @param {string} text The text to search.
 * @param {string} pattern The pattern to search for.
 * @param {number} loc The location to search around.
 * @return {number} Best match index or -1.
 */
diff_match_patch.prototype.match_main = function(text, pattern, loc) {
    // Check for null inputs.
    if (text == null || pattern == null || loc == null) {
        throw new Error('Null input. (match_main)');
    }

    loc = Math.max(0, Math.min(loc, text.length));
    if (text == pattern) {
        // Shortcut (potentially not guaranteed by the algorithm)
        return 0;
    } else if (!text.length) {
        // Nothing to match.
        return -1;
    } else if (text.substring(loc, loc + pattern.length) == pattern) {
        // Perfect match at the perfect spot!  (Includes case of null pattern)
        return loc;
    } else {
        // Do a fuzzy compare.
        return this.match_bitap_(text, pattern, loc);
    }
};


/**
 * Locate the best instance of 'pattern' in 'text' near 'loc' using the
 * Bitap algorithm.
 * @param {string} text The text to search.
 * @param {string} pattern The pattern to search for.
 * @param {number} loc The location to search around.
 * @return {number} Best match index or -1.
 * @private
 */
diff_match_patch.prototype.match_bitap_ = function(text, pattern, loc) {
    if (pattern.length > this.Match_MaxBits) {
        throw new Error('Pattern too long for this browser.');
    }

    // Initialise the alphabet.
    var s = this.match_alphabet_(pattern);

    var dmp = this;  // 'this' becomes 'window' in a closure.

    /**
     * Compute and return the score for a match with e errors and x location.
     * Accesses loc and pattern through being a closure.
     * @param {number} e Number of errors in match.
     * @param {number} x Location of match.
     * @return {number} Overall score for match (0.0 = good, 1.0 = bad).
     * @private
     */
    function match_bitapScore_(e, x) {
        var accuracy = e / pattern.length;
        var proximity = Math.abs(loc - x);
        if (!dmp.Match_Distance) {
            // Dodge divide by zero error.
            return proximity ? 1.0 : accuracy;
        }
        return accuracy + (proximity / dmp.Match_Distance);
    }

    // Highest score beyond which we give up.
    var score_threshold = this.Match_Threshold;
    // Is there a nearby exact match? (speedup)
    var best_loc = text.indexOf(pattern, loc);
    if (best_loc != -1) {
        score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);
        // What about in the other direction? (speedup)
        best_loc = text.lastIndexOf(pattern, loc + pattern.length);
        if (best_loc != -1) {
            score_threshold =
                Math.min(match_bitapScore_(0, best_loc), score_threshold);
        }
    }

    // Initialise the bit arrays.
    var matchmask = 1 << (pattern.length - 1);
    best_loc = -1;

    var bin_min, bin_mid;
    var bin_max = pattern.length + text.length;
    var last_rd;
    for (var d = 0; d < pattern.length; d++) {
        // Scan for the best match; each iteration allows for one more error.
        // Run a binary search to determine how far from 'loc' we can stray at this
        // error level.
        bin_min = 0;
        bin_mid = bin_max;
        while (bin_min < bin_mid) {
            if (match_bitapScore_(d, loc + bin_mid) <= score_threshold) {
                bin_min = bin_mid;
            } else {
                bin_max = bin_mid;
            }
            bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);
        }
        // Use the result from this iteration as the maximum for the next.
        bin_max = bin_mid;
        var start = Math.max(1, loc - bin_mid + 1);
        var finish = Math.min(loc + bin_mid, text.length) + pattern.length;

        var rd = Array(finish + 2);
        rd[finish + 1] = (1 << d) - 1;
        for (var j = finish; j >= start; j--) {
            // The alphabet (s) is a sparse hash, so the following line generates
            // warnings.
            var charMatch = s[text.charAt(j - 1)];
            if (d === 0) {  // First pass: exact match.
                rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;
            } else {  // Subsequent passes: fuzzy match.
                rd[j] = (((rd[j + 1] << 1) | 1) & charMatch) |
                    (((last_rd[j + 1] | last_rd[j]) << 1) | 1) |
                    last_rd[j + 1];
            }
            if (rd[j] & matchmask) {
                var score = match_bitapScore_(d, j - 1);
                // This match will almost certainly be better than any existing match.
                // But check anyway.
                if (score <= score_threshold) {
                    // Told you so.
                    score_threshold = score;
                    best_loc = j - 1;
                    if (best_loc > loc) {
                        // When passing loc, don't exceed our current distance from loc.
                        start = Math.max(1, 2 * loc - best_loc);
                    } else {
                        // Already passed loc, downhill from here on in.
                        break;
                    }
                }
            }
        }
        // No hope for a (better) match at greater error levels.
        if (match_bitapScore_(d + 1, loc) > score_threshold) {
            break;
        }
        last_rd = rd;
    }
    return best_loc;
};


/**
 * Initialise the alphabet for the Bitap algorithm.
 * @param {string} pattern The text to encode.
 * @return {!Object} Hash of character locations.
 * @private
 */
diff_match_patch.prototype.match_alphabet_ = function(pattern) {
    var s = {};
    for (var i = 0; i < pattern.length; i++) {
        s[pattern.charAt(i)] = 0;
    }
    for (var i = 0; i < pattern.length; i++) {
        s[pattern.charAt(i)] |= 1 << (pattern.length - i - 1);
    }
    return s;
};


//  PATCH FUNCTIONS


/**
 * Increase the context until it is unique,
 * but don't let the pattern expand beyond Match_MaxBits.
 * @param {!diff_match_patch.patch_obj} patch The patch to grow.
 * @param {string} text Source text.
 * @private
 */
diff_match_patch.prototype.patch_addContext_ = function(patch, text) {
    if (text.length == 0) {
        return;
    }
    var pattern = text.substring(patch.start2, patch.start2 + patch.length1);
    var padding = 0;

    // Look for the first and last matches of pattern in text.  If two different
    // matches are found, increase the pattern length.
    while (text.indexOf(pattern) != text.lastIndexOf(pattern) &&
    pattern.length < this.Match_MaxBits - this.Patch_Margin -
    this.Patch_Margin) {
        padding += this.Patch_Margin;
        pattern = text.substring(patch.start2 - padding,
            patch.start2 + patch.length1 + padding);
    }
    // Add one chunk for good luck.
    padding += this.Patch_Margin;

    // Add the prefix.
    var prefix = text.substring(patch.start2 - padding, patch.start2);
    if (prefix) {
        patch.diffs.unshift([DIFF_EQUAL, prefix]);
    }
    // Add the suffix.
    var suffix = text.substring(patch.start2 + patch.length1,
        patch.start2 + patch.length1 + padding);
    if (suffix) {
        patch.diffs.push([DIFF_EQUAL, suffix]);
    }

    // Roll back the start points.
    patch.start1 -= prefix.length;
    patch.start2 -= prefix.length;
    // Extend the lengths.
    patch.length1 += prefix.length + suffix.length;
    patch.length2 += prefix.length + suffix.length;
};


/**
 * Compute a list of patches to turn text1 into text2.
 * Use diffs if provided, otherwise compute it ourselves.
 * There are four ways to call this function, depending on what data is
 * available to the caller:
 * Method 1:
 * a = text1, b = text2
 * Method 2:
 * a = diffs
 * Method 3 (optimal):
 * a = text1, b = diffs
 * Method 4 (deprecated, use method 3):
 * a = text1, b = text2, c = diffs
 *
 * @param {string|!Array.<!diff_match_patch.Diff>} a text1 (methods 1,3,4) or
 * Array of diff tuples for text1 to text2 (method 2).
 * @param {string|!Array.<!diff_match_patch.Diff>} opt_b text2 (methods 1,4) or
 * Array of diff tuples for text1 to text2 (method 3) or undefined (method 2).
 * @param {string|!Array.<!diff_match_patch.Diff>} opt_c Array of diff tuples
 * for text1 to text2 (method 4) or undefined (methods 1,2,3).
 * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
 */
diff_match_patch.prototype.patch_make = function(a, opt_b, opt_c) {
    var text1, diffs;
    if (typeof a == 'string' && typeof opt_b == 'string' &&
        typeof opt_c == 'undefined') {
        // Method 1: text1, text2
        // Compute diffs from text1 and text2.
        text1 = /** @type {string} */(a);
        diffs = this.diff_main(text1, /** @type {string} */(opt_b), true);
        if (diffs.length > 2) {
            this.diff_cleanupSemantic(diffs);
            this.diff_cleanupEfficiency(diffs);
        }
    } else if (a && typeof a == 'object' && typeof opt_b == 'undefined' &&
        typeof opt_c == 'undefined') {
        // Method 2: diffs
        // Compute text1 from diffs.
        diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(a);
        text1 = this.diff_text1(diffs);
    } else if (typeof a == 'string' && opt_b && typeof opt_b == 'object' &&
        typeof opt_c == 'undefined') {
        // Method 3: text1, diffs
        text1 = /** @type {string} */(a);
        diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_b);
    } else if (typeof a == 'string' && typeof opt_b == 'string' &&
        opt_c && typeof opt_c == 'object') {
        // Method 4: text1, text2, diffs
        // text2 is not used.
        text1 = /** @type {string} */(a);
        diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_c);
    } else {
        throw new Error('Unknown call format to patch_make.');
    }

    if (diffs.length === 0) {
        return [];  // Get rid of the null case.
    }
    var patches = [];
    var patch = new diff_match_patch.patch_obj();
    var patchDiffLength = 0;  // Keeping our own length var is faster in JS.
    var char_count1 = 0;  // Number of characters into the text1 string.
    var char_count2 = 0;  // Number of characters into the text2 string.
    // Start with text1 (prepatch_text) and apply the diffs until we arrive at
    // text2 (postpatch_text).  We recreate the patches one by one to determine
    // context info.
    var prepatch_text = text1;
    var postpatch_text = text1;
    for (var x = 0; x < diffs.length; x++) {
        var diff_type = diffs[x][0];
        var diff_text = diffs[x][1];

        if (!patchDiffLength && diff_type !== DIFF_EQUAL) {
            // A new patch starts here.
            patch.start1 = char_count1;
            patch.start2 = char_count2;
        }

        switch (diff_type) {
            case DIFF_INSERT:
                patch.diffs[patchDiffLength++] = diffs[x];
                patch.length2 += diff_text.length;
                postpatch_text = postpatch_text.substring(0, char_count2) + diff_text +
                    postpatch_text.substring(char_count2);
                break;
            case DIFF_DELETE:
                patch.length1 += diff_text.length;
                patch.diffs[patchDiffLength++] = diffs[x];
                postpatch_text = postpatch_text.substring(0, char_count2) +
                    postpatch_text.substring(char_count2 +
                        diff_text.length);
                break;
            case DIFF_EQUAL:
                if (diff_text.length <= 2 * this.Patch_Margin &&
                    patchDiffLength && diffs.length != x + 1) {
                    // Small equality inside a patch.
                    patch.diffs[patchDiffLength++] = diffs[x];
                    patch.length1 += diff_text.length;
                    patch.length2 += diff_text.length;
                } else if (diff_text.length >= 2 * this.Patch_Margin) {
                    // Time for a new patch.
                    if (patchDiffLength) {
                        this.patch_addContext_(patch, prepatch_text);
                        patches.push(patch);
                        patch = new diff_match_patch.patch_obj();
                        patchDiffLength = 0;
                        // Unlike Unidiff, our patch lists have a rolling context.
                        // http://code.google.com/p/google-diff-match-patch/wiki/Unidiff
                        // Update prepatch text & pos to reflect the application of the
                        // just completed patch.
                        prepatch_text = postpatch_text;
                        char_count1 = char_count2;
                    }
                }
                break;
        }

        // Update the current character count.
        if (diff_type !== DIFF_INSERT) {
            char_count1 += diff_text.length;
        }
        if (diff_type !== DIFF_DELETE) {
            char_count2 += diff_text.length;
        }
    }
    // Pick up the leftover patch if not empty.
    if (patchDiffLength) {
        this.patch_addContext_(patch, prepatch_text);
        patches.push(patch);
    }

    return patches;
};


/**
 * Given an array of patches, return another array that is identical.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
 */
diff_match_patch.prototype.patch_deepCopy = function(patches) {
    // Making deep copies is hard in JavaScript.
    var patchesCopy = [];
    for (var x = 0; x < patches.length; x++) {
        var patch = patches[x];
        var patchCopy = new diff_match_patch.patch_obj();
        patchCopy.diffs = [];
        for (var y = 0; y < patch.diffs.length; y++) {
            patchCopy.diffs[y] = patch.diffs[y].slice();
        }
        patchCopy.start1 = patch.start1;
        patchCopy.start2 = patch.start2;
        patchCopy.length1 = patch.length1;
        patchCopy.length2 = patch.length2;
        patchesCopy[x] = patchCopy;
    }
    return patchesCopy;
};


/**
 * Merge a set of patches onto the text.  Return a patched text, as well
 * as a list of true/false values indicating which patches were applied.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 * @param {string} text Old text.
 * @return {!Array.<string|!Array.<boolean>>} Two element Array, containing the
 *      new text and an array of boolean values.
 */
diff_match_patch.prototype.patch_apply = function(patches, text) {
    if (patches.length == 0) {
        return [text, []];
    }

    // Deep copy the patches so that no changes are made to originals.
    patches = this.patch_deepCopy(patches);

    var nullPadding = this.patch_addPadding(patches);
    text = nullPadding + text + nullPadding;

    this.patch_splitMax(patches);
    // delta keeps track of the offset between the expected and actual location
    // of the previous patch.  If there are patches expected at positions 10 and
    // 20, but the first patch was found at 12, delta is 2 and the second patch
    // has an effective expected position of 22.
    var delta = 0;
    var results = [];
    for (var x = 0; x < patches.length; x++) {
        var expected_loc = patches[x].start2 + delta;
        var text1 = this.diff_text1(patches[x].diffs);
        var start_loc;
        var end_loc = -1;
        if (text1.length > this.Match_MaxBits) {
            // patch_splitMax will only provide an oversized pattern in the case of
            // a monster delete.
            start_loc = this.match_main(text, text1.substring(0, this.Match_MaxBits),
                expected_loc);
            if (start_loc != -1) {
                end_loc = this.match_main(text,
                    text1.substring(text1.length - this.Match_MaxBits),
                    expected_loc + text1.length - this.Match_MaxBits);
                if (end_loc == -1 || start_loc >= end_loc) {
                    // Can't find valid trailing context.  Drop this patch.
                    start_loc = -1;
                }
            }
        } else {
            start_loc = this.match_main(text, text1, expected_loc);
        }
        if (start_loc == -1) {
            // No match found.  :(
            results[x] = false;
            // Subtract the delta for this failed patch from subsequent patches.
            delta -= patches[x].length2 - patches[x].length1;
        } else {
            // Found a match.  :)
            results[x] = true;
            delta = start_loc - expected_loc;
            var text2;
            if (end_loc == -1) {
                text2 = text.substring(start_loc, start_loc + text1.length);
            } else {
                text2 = text.substring(start_loc, end_loc + this.Match_MaxBits);
            }
            if (text1 == text2) {
                // Perfect match, just shove the replacement text in.
                text = text.substring(0, start_loc) +
                    this.diff_text2(patches[x].diffs) +
                    text.substring(start_loc + text1.length);
            } else {
                // Imperfect match.  Run a diff to get a framework of equivalent
                // indices.
                var diffs = this.diff_main(text1, text2, false);
                if (text1.length > this.Match_MaxBits &&
                    this.diff_levenshtein(diffs) / text1.length >
                    this.Patch_DeleteThreshold) {
                    // The end points match, but the content is unacceptably bad.
                    results[x] = false;
                } else {
                    this.diff_cleanupSemanticLossless(diffs);
                    var index1 = 0;
                    var index2;
                    for (var y = 0; y < patches[x].diffs.length; y++) {
                        var mod = patches[x].diffs[y];
                        if (mod[0] !== DIFF_EQUAL) {
                            index2 = this.diff_xIndex(diffs, index1);
                        }
                        if (mod[0] === DIFF_INSERT) {  // Insertion
                            text = text.substring(0, start_loc + index2) + mod[1] +
                                text.substring(start_loc + index2);
                        } else if (mod[0] === DIFF_DELETE) {  // Deletion
                            text = text.substring(0, start_loc + index2) +
                                text.substring(start_loc + this.diff_xIndex(diffs,
                                        index1 + mod[1].length));
                        }
                        if (mod[0] !== DIFF_DELETE) {
                            index1 += mod[1].length;
                        }
                    }
                }
            }
        }
    }
    // Strip the padding off.
    text = text.substring(nullPadding.length, text.length - nullPadding.length);
    return [text, results];
};


/**
 * Add some padding on text start and end so that edges can match something.
 * Intended to be called only from within patch_apply.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 * @return {string} The padding string added to each side.
 */
diff_match_patch.prototype.patch_addPadding = function(patches) {
    var paddingLength = this.Patch_Margin;
    var nullPadding = '';
    for (var x = 1; x <= paddingLength; x++) {
        nullPadding += String.fromCharCode(x);
    }

    // Bump all the patches forward.
    for (var x = 0; x < patches.length; x++) {
        patches[x].start1 += paddingLength;
        patches[x].start2 += paddingLength;
    }

    // Add some padding on start of first diff.
    var patch = patches[0];
    var diffs = patch.diffs;
    if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {
        // Add nullPadding equality.
        diffs.unshift([DIFF_EQUAL, nullPadding]);
        patch.start1 -= paddingLength;  // Should be 0.
        patch.start2 -= paddingLength;  // Should be 0.
        patch.length1 += paddingLength;
        patch.length2 += paddingLength;
    } else if (paddingLength > diffs[0][1].length) {
        // Grow first equality.
        var extraLength = paddingLength - diffs[0][1].length;
        diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];
        patch.start1 -= extraLength;
        patch.start2 -= extraLength;
        patch.length1 += extraLength;
        patch.length2 += extraLength;
    }

    // Add some padding on end of last diff.
    patch = patches[patches.length - 1];
    diffs = patch.diffs;
    if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {
        // Add nullPadding equality.
        diffs.push([DIFF_EQUAL, nullPadding]);
        patch.length1 += paddingLength;
        patch.length2 += paddingLength;
    } else if (paddingLength > diffs[diffs.length - 1][1].length) {
        // Grow last equality.
        var extraLength = paddingLength - diffs[diffs.length - 1][1].length;
        diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);
        patch.length1 += extraLength;
        patch.length2 += extraLength;
    }

    return nullPadding;
};


/**
 * Look through the patches and break up any which are longer than the maximum
 * limit of the match algorithm.
 * Intended to be called only from within patch_apply.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 */
diff_match_patch.prototype.patch_splitMax = function(patches) {
    var patch_size = this.Match_MaxBits;
    for (var x = 0; x < patches.length; x++) {
        if (patches[x].length1 <= patch_size) {
            continue;
        }
        var bigpatch = patches[x];
        // Remove the big old patch.
        patches.splice(x--, 1);
        var start1 = bigpatch.start1;
        var start2 = bigpatch.start2;
        var precontext = '';
        while (bigpatch.diffs.length !== 0) {
            // Create one of several smaller patches.
            var patch = new diff_match_patch.patch_obj();
            var empty = true;
            patch.start1 = start1 - precontext.length;
            patch.start2 = start2 - precontext.length;
            if (precontext !== '') {
                patch.length1 = patch.length2 = precontext.length;
                patch.diffs.push([DIFF_EQUAL, precontext]);
            }
            while (bigpatch.diffs.length !== 0 &&
            patch.length1 < patch_size - this.Patch_Margin) {
                var diff_type = bigpatch.diffs[0][0];
                var diff_text = bigpatch.diffs[0][1];
                if (diff_type === DIFF_INSERT) {
                    // Insertions are harmless.
                    patch.length2 += diff_text.length;
                    start2 += diff_text.length;
                    patch.diffs.push(bigpatch.diffs.shift());
                    empty = false;
                } else if (diff_type === DIFF_DELETE && patch.diffs.length == 1 &&
                    patch.diffs[0][0] == DIFF_EQUAL &&
                    diff_text.length > 2 * patch_size) {
                    // This is a large deletion.  Let it pass in one chunk.
                    patch.length1 += diff_text.length;
                    start1 += diff_text.length;
                    empty = false;
                    patch.diffs.push([diff_type, diff_text]);
                    bigpatch.diffs.shift();
                } else {
                    // Deletion or equality.  Only take as much as we can stomach.
                    diff_text = diff_text.substring(0,
                        patch_size - patch.length1 - this.Patch_Margin);
                    patch.length1 += diff_text.length;
                    start1 += diff_text.length;
                    if (diff_type === DIFF_EQUAL) {
                        patch.length2 += diff_text.length;
                        start2 += diff_text.length;
                    } else {
                        empty = false;
                    }
                    patch.diffs.push([diff_type, diff_text]);
                    if (diff_text == bigpatch.diffs[0][1]) {
                        bigpatch.diffs.shift();
                    } else {
                        bigpatch.diffs[0][1] =
                            bigpatch.diffs[0][1].substring(diff_text.length);
                    }
                }
            }
            // Compute the head context for the next patch.
            precontext = this.diff_text2(patch.diffs);
            precontext =
                precontext.substring(precontext.length - this.Patch_Margin);
            // Append the end context for this patch.
            var postcontext = this.diff_text1(bigpatch.diffs)
                .substring(0, this.Patch_Margin);
            if (postcontext !== '') {
                patch.length1 += postcontext.length;
                patch.length2 += postcontext.length;
                if (patch.diffs.length !== 0 &&
                    patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {
                    patch.diffs[patch.diffs.length - 1][1] += postcontext;
                } else {
                    patch.diffs.push([DIFF_EQUAL, postcontext]);
                }
            }
            if (!empty) {
                patches.splice(++x, 0, patch);
            }
        }
    }
};


/**
 * Take a list of patches and return a textual representation.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 * @return {string} Text representation of patches.
 */
diff_match_patch.prototype.patch_toText = function(patches) {
    var text = [];
    for (var x = 0; x < patches.length; x++) {
        text[x] = patches[x];
    }
    return text.join('');
};


/**
 * Parse a textual representation of patches and return a list of Patch objects.
 * @param {string} textline Text representation of patches.
 * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
 * @throws {!Error} If invalid input.
 */
diff_match_patch.prototype.patch_fromText = function(textline) {
    var patches = [];
    if (!textline) {
        return patches;
    }
    var text = textline.split('\n');
    var textPointer = 0;
    var patchHeader = /^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/;
    while (textPointer < text.length) {
        var m = text[textPointer].match(patchHeader);
        if (!m) {
            throw new Error('Invalid patch string: ' + text[textPointer]);
        }
        var patch = new diff_match_patch.patch_obj();
        patches.push(patch);
        patch.start1 = parseInt(m[1], 10);
        if (m[2] === '') {
            patch.start1--;
            patch.length1 = 1;
        } else if (m[2] == '0') {
            patch.length1 = 0;
        } else {
            patch.start1--;
            patch.length1 = parseInt(m[2], 10);
        }

        patch.start2 = parseInt(m[3], 10);
        if (m[4] === '') {
            patch.start2--;
            patch.length2 = 1;
        } else if (m[4] == '0') {
            patch.length2 = 0;
        } else {
            patch.start2--;
            patch.length2 = parseInt(m[4], 10);
        }
        textPointer++;

        while (textPointer < text.length) {
            var sign = text[textPointer].charAt(0);
            try {
                var line = decodeURI(text[textPointer].substring(1));
            } catch (ex) {
                // Malformed URI sequence.
                throw new Error('Illegal escape in patch_fromText: ' + line);
            }
            if (sign == '-') {
                // Deletion.
                patch.diffs.push([DIFF_DELETE, line]);
            } else if (sign == '+') {
                // Insertion.
                patch.diffs.push([DIFF_INSERT, line]);
            } else if (sign == ' ') {
                // Minor equality.
                patch.diffs.push([DIFF_EQUAL, line]);
            } else if (sign == '@') {
                // Start of next patch.
                break;
            } else if (sign === '') {
                // Blank line?  Whatever.
            } else {
                // WTF?
                throw new Error('Invalid patch mode "' + sign + '" in: ' + line);
            }
            textPointer++;
        }
    }
    return patches;
};


/**
 * Class representing one patch operation.
 * @constructor
 */
diff_match_patch.patch_obj = function() {
    /** @type {!Array.<!diff_match_patch.Diff>} */
    this.diffs = [];
    /** @type {?number} */
    this.start1 = null;
    /** @type {?number} */
    this.start2 = null;
    /** @type {number} */
    this.length1 = 0;
    /** @type {number} */
    this.length2 = 0;
};


/**
 * Emmulate GNU diff's format.
 * Header: @@ -382,8 +481,9 @@
 * Indicies are printed as 1-based, not 0-based.
 * @return {string} The GNU diff string.
 */
diff_match_patch.patch_obj.prototype.toString = function() {
    var coords1, coords2;
    if (this.length1 === 0) {
        coords1 = this.start1 + ',0';
    } else if (this.length1 == 1) {
        coords1 = this.start1 + 1;
    } else {
        coords1 = (this.start1 + 1) + ',' + this.length1;
    }
    if (this.length2 === 0) {
        coords2 = this.start2 + ',0';
    } else if (this.length2 == 1) {
        coords2 = this.start2 + 1;
    } else {
        coords2 = (this.start2 + 1) + ',' + this.length2;
    }
    var text = ['@@ -' + coords1 + ' +' + coords2 + ' @@\n'];
    var op;
    // Escape the body of the patch with %xx notation.
    for (var x = 0; x < this.diffs.length; x++) {
        switch (this.diffs[x][0]) {
            case DIFF_INSERT:
                op = '+';
                break;
            case DIFF_DELETE:
                op = '-';
                break;
            case DIFF_EQUAL:
                op = ' ';
                break;
        }
        text[x + 1] = op + encodeURI(this.diffs[x][1]) + '\n';
    }
    return text.join('').replace(/%20/g, ' ');
};


// Export these global variables so that they survive Google's JS compiler.
// In a browser, 'this' will be 'window'.
// Users of node.js should 'require' the uncompressed version since Google's
// JS compiler may break the following exports for non-browser environments.
this['diff_match_patch'] = diff_match_patch;
this['DIFF_DELETE'] = DIFF_DELETE;
this['DIFF_INSERT'] = DIFF_INSERT;
this['DIFF_EQUAL'] = DIFF_EQUAL;

// Copyright (c) 2008, 2009 Andrew Cantino
// Copyright (c) 2008, 2009 Kyle Maxwell

/**
 * Patched to exclude jquery usages.
 *
 */

function DomPredictionHelper() {
};
DomPredictionHelper.prototype = new Object();

DomPredictionHelper.prototype.recursiveNodes = function (e) {
    var n;
    if (e.nodeName && e.parentNode && e != document.body) {
        n = this.recursiveNodes(e.parentNode);
    } else {
        n = new Array();
    }
    n.push(e);
    return n;
};

DomPredictionHelper.prototype.escapeCssNames = function (name) {
    if (name) {
        try {
            return name.replace(/\s*sg_\w+\s*/g, '').replace(/\\/g, '\\\\').
                replace(/\./g, '\\.').replace(/#/g, '\\#').replace(/\>/g, '\\>').replace(/\,/g, '\\,').replace(/\:/g, '\\:');
        } catch (e) {
            console.log('---');
            console.log("exception in escapeCssNames");
            console.log(name);
            console.log('---');
            return '';
        }
    } else {
        return '';
    }
};

DomPredictionHelper.prototype.childElemNumber = function (elem) {
    var count = 0;
    while (elem.previousSibling && (elem = elem.previousSibling)) {
        if (elem.nodeType == 1) count++;
    }
    return count;
};

DomPredictionHelper.prototype.pathOf = function (elem) {
    var nodes = this.recursiveNodes(elem);
    var self = this;
    var path = "";
    for (var i = 0; i < nodes.length; i++) {
        var e = nodes[i];
        if (e) {
            path += e.nodeName.toLowerCase();
            var escaped = e.id && self.escapeCssNames(new String(e.id));
            if (escaped && escaped.length > 0) path += '#' + escaped;

            if (e.className) {
                var split = e.className.split(/ /);

                for (var j = 0; j < split.length; j++) {
                    var escaped = self.escapeCssNames(split[j]);
                    if (split[j] && escaped.length > 0) {
                        path += '.' + escaped;
                    }
                }
            }

            path += ':nth-child(' + (self.childElemNumber(e) + 1) + ')';
            path += ' '
        }
    }
    if (path.charAt(path.length - 1) == ' ') path = path.substring(0, path.length - 1);
    return path;
};

DomPredictionHelper.prototype.commonCss = function (array) {
    try {
        var dmp = new diff_match_patch();
    } catch (e) {
        throw "Please include the diff_match_patch library.";
    }

    if (typeof array == 'undefined' || array.length == 0) return '';

    var existing_tokens = {};
    var encoded_css_array = this.encodeCssForDiff(array, existing_tokens);

    var collective_common = encoded_css_array.pop();

    encoded_css_array.forEach(function(el) {
        var diff = dmp.diff_main(collective_common, el);
        collective_common = '';

        diff.forEach(function(d) {
            if (d[0] == 0) {
                collective_common += d[1];
            }
        });
    });

    return this.decodeCss(collective_common, existing_tokens);
};

DomPredictionHelper.prototype.tokenizeCss = function (css_string) {
    var skip = false;
    var word = '';
    var tokens = [];

    var css_string = css_string.replace(/,/, ' , ').replace(/\s+/g, ' ');
    var length = css_string.length;
    var c = '';

    for (var i = 0; i < length; i++) {
        c = css_string[i];

        if (skip) {
            skip = false;
        } else if (c == '\\') {
            skip = true;
        } else if (c == '.' || c == ' ' || c == '#' || c == '>' || c == ':' || c == ',') {
            if (word.length > 0) tokens.push(word);
            word = '';
        }
        word += c;
        if (c == ' ' || c == ',') {
            tokens.push(word);
            word = '';
        }
    }
    if (word.length > 0) tokens.push(word);
    return tokens;
};

DomPredictionHelper.prototype.decodeCss = function (string, existing_tokens) {
    var inverted = this.invertObject(existing_tokens);
    var out = '';
    var split = string.split('');
    for (var i = 0; i < split.length; i++) {
        out += inverted[split[i]];
    }

    return this.cleanCss(out);
};

// Encode css paths for diff using unicode codepoints to allow for a large number of tokens.
DomPredictionHelper.prototype.encodeCssForDiff = function (strings, existing_tokens) {
    var codepoint = 50;
    var self = this;
    var strings_out = [];
    for (var i = 0; i < strings.length; i++) {
        var out = new String();

        var tokenizeCss = self.tokenizeCss(strings[i]);
        for (var j = 0; j < tokenizeCss.length; j++) {
            var s = tokenizeCss[j];

            if (!existing_tokens[s]) {
                existing_tokens[s] = String.fromCharCode(codepoint++);
            }

            out += existing_tokens[s];
        }

        strings_out.push(out);
    }

    return strings_out;
};

DomPredictionHelper.prototype.simplifyCss = function (css, selected_paths, rejected_paths) {
    var self = this;
    var parts = self.tokenizeCss(css);
    var best_so_far = "";
    if (self.selectorGets('all', selected_paths, css) && self.selectorGets('none', rejected_paths, css)) best_so_far = css;
    for (var pass = 0; pass < 4; pass++) {
        for (var part = 0; part < parts.length; part++) {
            var first = parts[part].substring(0, 1);
            if (self.wouldLeaveFreeFloatingNthChild(parts, part)) continue;
            if ((pass == 0 && first == ':') || // :nth-child
                (pass == 1 && first != ':' && first != '.' && first != '#' && first != ' ') || // elem, etc.
                (pass == 2 && first == '.') || // classes
                (pass == 3 && first == '#')) // ids
            {
                var tmp = parts[part];
                parts[part] = '';
                var selector = self.cleanCss(parts.join(''));
                if (selector == '') {
                    parts[part] = tmp;
                    continue;
                }
                if (self.selectorGets('all', selected_paths, selector) && self.selectorGets('none', rejected_paths, selector)) {
                    best_so_far = selector;
                } else {
                    parts[part] = tmp;
                }
            }
        }
    }
    return self.cleanCss(best_so_far);
};

DomPredictionHelper.prototype.wouldLeaveFreeFloatingNthChild = function (parts, part) {
    return (((part - 1 >= 0 && parts[part - 1].substring(0, 1) == ':') &&
    (part - 2 < 0 || parts[part - 2] == ' ') &&
    (part + 1 >= parts.length || parts[part + 1] == ' ')) ||
    ((part + 1 < parts.length && parts[part + 1].substring(0, 1) == ':') &&
    (part + 2 >= parts.length || parts[part + 2] == ' ') &&
    (part - 1 < 0 || parts[part - 1] == ' ')));
};

DomPredictionHelper.prototype.cleanCss = function (css) {
    return css.replace(/\>/, ' > ').replace(/,/, ' , ').replace(/\s+/g, ' ').replace(/^\s+|\s+$/g, '').replace(/,$/, '');
};

DomPredictionHelper.prototype.getPathsFor = function (arr) {
    var self = this;
    var out = [];

    for (var i = 0; i < arr.length; i++) {
        var s = arr[i];

        if (s && s.nodeName) {
            out.push(self.pathOf(s));
        }
    }

    return out;
};

DomPredictionHelper.prototype.predictCss = function (s, r) {
    var self = this;

    if (s.length == 0) return '';
    var selected_paths = self.getPathsFor(s);
    var rejected_paths = self.getPathsFor(r);

    var css = self.commonCss(selected_paths);
    var simplest = self.simplifyCss(css, selected_paths, rejected_paths);

    // Do we get off easy?
    if (simplest.length > 0) return simplest;

    // Okay, then make a union and possibly try to reduce subsets.
    var union = '';
    for (var i = 0; i < s.length; i++) {
        union = self.pathOf(s[i]) + ", " + union;
    }

    union = self.cleanCss(union);

    return self.simplifyCss(union, selected_paths, rejected_paths);
};

DomPredictionHelper.prototype.fragmentSelector = function (selector) {
    var self = this;
    var out = [];
    var split = selector.split(/\,/);

    for (var i = 0; i < split.length; i++) {
        var out2 = [];
        var splitInner = self.cleanCss(split[i]).split(/\s+/);

        for (var j = 0; j < splitInner.length; j++) {
            out2.push(self.tokenizeCss(splitInner[j]));
        }

        out.push(out2);
    }

    return out;
};

// Everything in the first selector must be present in the second.
DomPredictionHelper.prototype.selectorBlockMatchesSelectorBlock = function (selector_block1, selector_block2) {
    for (var j = 0; j < selector_block1.length; j++) {
        if (selector_block2.indexOf(selector_block1[j]) == -1) {
            return false;
        }
    }
    return true;
};

// Assumes list is an array of complete CSS selectors represented as strings.
DomPredictionHelper.prototype.selectorGets = function (type, list, the_selector) {
    var self = this;
    var result = true;

    if (list.length == 0 && type == 'all') return false;
    if (list.length == 0 && type == 'none') return true;

    var selectors = self.fragmentSelector(the_selector);

    var cleaned_list = [];
    for (var i = 0; i < list.length; i++) {
        cleaned_list.push(self.fragmentSelector(list[i])[0]);
    }

    for (var i = 0; i < selectors.length; i++) {
        if (!result) return;
        var selector = selectors[i];

        for (var j = 0; j < cleaned_list.length; i++) {
            if (!result || cleaned_list[j] == '') return;

            if (self._selectorGets(cleaned_list[j], selector)) {
                if (type == 'none') result = false;
                cleaned_list[j] = '';
            }
        }
    }

    if (type == 'all' && cleaned_list.join('').length > 0) { // Some candidates didn't get matched.
        result = false;
    }

    return result;
};

DomPredictionHelper.prototype._selectorGets = function (candidate_as_blocks, selector_as_blocks) {
    var cannot_match = false;
    var position = candidate_as_blocks.length - 1;
    for (var i = selector_as_blocks.length - 1; i > -1; i--) {
        if (cannot_match) break;
        if (i == selector_as_blocks.length - 1) { // First element on right.
            // If we don't match the first element, we cannot match.
            if (!this.selectorBlockMatchesSelectorBlock(selector_as_blocks[i], candidate_as_blocks[position])) cannot_match = true;
            position--;
        } else {
            var found = false;
            while (position > -1 && !found) {
                found = this.selectorBlockMatchesSelectorBlock(selector_as_blocks[i], candidate_as_blocks[position]);
                position--;
            }
            if (!found) cannot_match = true;
        }
    }
    return !cannot_match;
};

DomPredictionHelper.prototype.invertObject = function (object) {
    var new_object = {};

    for(var key in object) {
        var value = object[key];
        new_object[value] = key;
    }

    return new_object;
};

DomPredictionHelper.prototype.cssToXPath = function (css_string) {
    var tokens = this.tokenizeCss(css_string);
    if (tokens[0] && tokens[0] == ' ') tokens.splice(0, 1);
    if (tokens[tokens.length - 1] && tokens[tokens.length - 1] == ' ') tokens.splice(tokens.length - 1, 1);

    var css_block = [];
    var out = "";

    for (var i = 0; i < tokens.length; i++) {
        if (tokens[i] == ' ') {
            out += this.cssToXPathBlockHelper(css_block);
            css_block = [];
        } else {
            css_block.push(tokens[i]);
        }
    }

    return out + this.cssToXPathBlockHelper(css_block);
};

// Process a block (html entity, class(es), id, :nth-child()) of css
DomPredictionHelper.prototype.cssToXPathBlockHelper = function (css_block) {
    if (css_block.length == 0) return '//';
    var out = '//';
    var first = css_block[0].substring(0, 1);

    if (first == ',') return " | ";

    if (first == ':' || first == '#' || first == '.') {
        out += '*';
    }

    var expressions = [];
    var re = null;

    for (var i = 0; i < css_block.length; i++) {
        var current = css_block[i];
        first = current.substring(0, 1);
        var rest = current.substring(1);

        if (first == ':') {
            // We only support :nth-child(n) at the moment.
            if (re = rest.match(/^nth-child\((\d+)\)$/))
                expressions.push('(((count(preceding-sibling::*) + 1) = ' + re[1] + ') and parent::*)');
        } else if (first == '.') {
            expressions.push('contains(concat( " ", @class, " " ), concat( " ", "' + rest + '", " " ))');
        } else if (first == '#') {
            expressions.push('(@id = "' + rest + '")');
        } else if (first == ',') {
        } else {
            out += current;
        }
    }

    if (expressions.length > 0) out += '[';
    for (var i = 0; i < expressions.length; i++) {
        out += expressions[i];
        if (i < expressions.length - 1) out += ' and ';
    }
    if (expressions.length > 0) out += ']';
    return out;
};


/**
 * Adguard selector library
 * @type {Function}
 */
var AdguardSelectorLib = (function (api, $) {

    // PRIVATE FIELDS

    var PLACEHOLDER_PREFIX = 'adguard-placeholder';
    var placeholdedElements = null;

    var restrictedElements = null;
    var predictionHelper = null;

    var SUGGESTED_CLASS = "sg_suggested";
    var SELECTED_CLASS = "sg_selected";
    var REJECTED_CLASS = "sg_rejected";
    var IGNORED_CLASS = "sg_ignore";

    var selectedElements = [];
    var rejectedElements = [];

    var selectMode = 'exact';
    var unbound = true;
    var onElementSelectedHandler = null;

    var isTouchEventsSupported = (('ontouchstart' in window) || (navigator.msMaxTouchPoints > 0));
    var ignoreTouchEvent = 0;

    var selectionRenderer;


    // PRIVATE METHODS

    var removeClassName = function (className) {
        $('.' + className).removeClass(className);
    };

    var suggestPredicted = function (prediction) {
        if (prediction) {
            $(prediction).each(function () {
                if (!$(this).hasClass(SELECTED_CLASS)
                    && !$(this).hasClass(IGNORED_CLASS)
                    && !$(this).hasClass(REJECTED_CLASS)) {
                    $(this).addClass(SUGGESTED_CLASS);
                }
            });
        }
    };

    var makePredictionPath = function (elem) {
        var w_elem = $(elem);

        if (w_elem.hasClass(SELECTED_CLASS)) {
            w_elem.removeClass(SELECTED_CLASS);
            selectedElements.splice($.inArray(elem, selectedElements), 1);
        } else if (w_elem.hasClass(REJECTED_CLASS)) {
            w_elem.removeClass(REJECTED_CLASS);
            rejectedElements.splice($.inArray(elem, rejectedElements), 1);
        } else if (w_elem.hasClass(SUGGESTED_CLASS)) {
            w_elem.addClass(REJECTED_CLASS);
            rejectedElements.push(elem);
        } else {
            if (selectMode == 'exact' && selectedElements.length > 0) {
                removeClassName(SELECTED_CLASS);
                selectedElements = [];
            }
            //w_elem.addClass('sg_selected');
            selectedElements.push(elem);
        }

        var prediction = predictionHelper.predictCss(selectedElements,
            rejectedElements.concat(restrictedElements));

        if (selectMode == 'similar') {
            removeClassName(SUGGESTED_CLASS);
            suggestPredicted(prediction);
        }

        return prediction;
    };

    var firstSelectedOrSuggestedParent = function (element) {
        if ($(element).hasClass(SUGGESTED_CLASS) || $(element).hasClass(SELECTED_CLASS)) {
            return element;
        }

        while (element.parentNode && (element = element.parentNode)) {
            if (restrictedElements.indexOf(element) == -1) {
                if ($(element).hasClass(SUGGESTED_CLASS) || $(element).hasClass(SELECTED_CLASS)) {
                    return element;
                }
            }
        }

        return null;
    };

    var px = function (p) {
        return p + 'px';
    };

    var getTagPath = function (element) {
        if (element.parentNode) {
            return element.parentNode.tagName.toLowerCase() + ' ' + element.tagName.toLowerCase();
        } else {
            return element.tagName.toLowerCase();
        }
    };

    var clearSelected = function () {
        selectedElements = [];
        rejectedElements = [];

        removeClassName(SELECTED_CLASS);
        removeClassName(REJECTED_CLASS);

        selectionRenderer.remove();
        removeClassName(SUGGESTED_CLASS);
    };

    /**
     * Returns element offset coordinates extended with width and height values.
     *
     * @param elem
     * @returns {{top: number, left: number, outerWidth: number, outerHeight: number}}
     */
    var getOffsetExtended = function (elem) {
        var bodyRect = document.body.getBoundingClientRect();
        var elemRect = elem.getBoundingClientRect();

        var rectTop = elemRect.top - bodyRect.top;
        var rectLeft = elemRect.left - bodyRect.left;

        return {
            top: rectTop,
            left: rectLeft,
            outerWidth: elem.offsetWidth,
            outerHeight: elem.offsetHeight
        };
    };

    /**
     * Adds borders to selected element.
     *
     * Default implementation of selection renderer.
     * Can be overwritten with custom implementation as a parameter of init function.
     *
     * @param element
     * @private
     */
    var BorderSelectionRenderer = (function (api) {
        var BORDER_WIDTH = 5;
        var BORDER_PADDING = 2;
        var BORDER_CLASS = "sg_border";

        var borderTop = null;
        var borderLeft = null;
        var borderRight = null;
        var borderBottom = null;

        var showBorders = function () {
            if (borderTop && borderBottom && borderLeft && borderRight) {
                borderTop.show();
                borderBottom.show();
                borderLeft.show();
                borderRight.show();
            }
        };

        var addBorderToDom = function () {
            document.body.appendChild(borderTop.get(0));
            document.body.appendChild(borderBottom.get(0));
            document.body.appendChild(borderLeft.get(0));
            document.body.appendChild(borderRight.get(0));
        };

        var removeBorderFromDom = function () {
            if (borderTop && borderTop.get(0)) {
                var parent = borderTop.get(0).parentNode;

                if (parent) {
                    parent.removeChild(borderTop.get(0));
                    parent.removeChild(borderBottom.get(0));
                    parent.removeChild(borderLeft.get(0));
                    parent.removeChild(borderRight.get(0));
                }
            }

            borderTop = borderBottom = borderRight = borderLeft = null;
        };

        /**
         * Preparing renderer.
         */
        api.init = function () {
            if (!borderTop) {
                var width = px(BORDER_WIDTH);

                borderTop = $('<div/>').addClass(BORDER_CLASS).css('height', width).hide()
                    .on("click", sgMousedownHandler);
                borderBottom = $('<div/>').addClass(BORDER_CLASS).addClass('sg_bottom_border')
                    .css('height', px(BORDER_WIDTH + 6)).hide()
                    .on("click", sgMousedownHandler);
                borderLeft = $('<div/>').addClass(BORDER_CLASS).css('width', width).hide()
                    .on("click", sgMousedownHandler);
                borderRight = $('<div/>').addClass(BORDER_CLASS).css('width', width).hide()
                    .on("click", sgMousedownHandler);

                addBorderToDom();
            }
        };

        /**
         * Clearing DOM and so on.
         */
        api.finalize = function () {
            removeBorderFromDom();
        };

        /**
         * Adds borders to specified element
         *
         * @param element
         */
        api.add = function (element) {
            api.remove();

            if (!element) {
                return;
            }

            var p = getOffsetExtended(element);

            var top = p.top;
            var left = p.left;
            var width = p.outerWidth;
            var height = p.outerHeight;

            borderTop.css('width', px(width + BORDER_PADDING * 2 + BORDER_WIDTH * 2)).
                css('top', px(top - BORDER_WIDTH - BORDER_PADDING)).
                css('left', px(left - BORDER_PADDING - BORDER_WIDTH));
            borderBottom.css('width', px(width + BORDER_PADDING * 2 + BORDER_WIDTH)).
                css('top', px(top + height + BORDER_PADDING)).
                css('left', px(left - BORDER_PADDING - BORDER_WIDTH));
            borderLeft.css('height', px(height + BORDER_PADDING * 2)).
                css('top', px(top - BORDER_PADDING)).
                css('left', px(left - BORDER_PADDING - BORDER_WIDTH));
            borderRight.css('height', px(height + BORDER_PADDING * 2)).
                css('top', px(top - BORDER_PADDING)).
                css('left', px(left + width + BORDER_PADDING));

            borderBottom.get(0).textContent = getTagPath(element);
            borderRight.get(0).target_elem = borderLeft.get(0).target_elem = borderTop.get(0).target_elem = borderBottom.get(0).target_elem = element;

            showBorders();
        };

        /**
         * Removes borders
         */
        api.remove = function () {
            if (borderTop && borderBottom && borderLeft && borderRight) {
                borderTop.hide();
                borderBottom.hide();
                borderLeft.hide();
                borderRight.hide();
            }
        };

        /**
         * Border class
         *
         * @type {string}
         */
        api.BORDER_CLASS = BORDER_CLASS;

        return api;
    })(BorderSelectionRenderer || {});

    var linkHelper = document.createElement('a');
    var getHost = function (url) {
        if (!url) {
            return "";
        }

        linkHelper.href = url;
        return linkHelper.hostname;
    };

    var makePlaceholderImage = function (element) {
        var placeHolder = document.createElement('div');
        var style = window.getComputedStyle(element);
        placeHolder.style.height = style.height;
        placeHolder.style.width = style.width;
        placeHolder.style.position = style.position;
        placeHolder.style.top = style.top;
        placeHolder.style.bottom = style.bottom;
        placeHolder.style.left = style.left;
        placeHolder.style.right = style.right;
        placeHolder.className += PLACEHOLDER_PREFIX + " " + IGNORED_CLASS;

        var icon = document.createElement('div');
        icon.className += PLACEHOLDER_PREFIX + "-icon " + IGNORED_CLASS;

        var domain = document.createElement('div');
        domain.textContent = getHost(element.src);
        domain.className += PLACEHOLDER_PREFIX + "-domain " + IGNORED_CLASS;

        icon.appendChild(domain);
        placeHolder.appendChild(icon);

        return placeHolder;
    };

    var removePlaceholders = function () {
        if (!placeholdedElements) {
            return;
        }
        var elements = placeholdedElements;
        for (var i = 0; i < elements.length; i++) {
            var current = elements[i];
            var id = PLACEHOLDER_PREFIX + i;

            var placeHolder = $('#' + id).get(0);
            if (placeHolder) {
                var parent = placeHolder.parentNode;
                if (parent) {
                    parent.replaceChild(current, placeHolder);
                }
            }
        }

        placeholdedElements = null;
    };

    var placeholderClick = function (element) {
        selectionRenderer.remove();
        removePlaceholders();

        onElementSelectedHandler(element);
    };

    var makeIFrameAndEmbeddedSelector = function () {
        placeholdedElements = $('iframe:not(.' + IGNORED_CLASS + '),embed,object').filter(function (elem) {
            var isVisible = elem.style["display"] != "none";
            var isHaveSize = elem.offsetWidth != 0 && elem.offsetHeight != 0;
            return isVisible && isHaveSize;
        });

        var elements = placeholdedElements;
        for (var i = 0; i < elements.length; i++) {
            var current = elements[i];
            (function (current) {
                var placeHolder = makePlaceholderImage(current);
                var id = PLACEHOLDER_PREFIX + i;

                placeHolder.setAttribute("id", id);

                var parent = current.parentNode;
                if (parent) {
                    parent.replaceChild(placeHolder, current);
                    if (isTouchEventsSupported) {
                        $(placeHolder).on("gestureend", gestureEndHandler);
                        $(placeHolder).on("touchmove", touchMoveHandler);
                        $(placeHolder).on("touchend", function (e) {
                            e.preventDefault();

                            if (needIgnoreTouchEvent()) {
                                return true;
                            }

                            placeholderClick(current);
                        });
                    } else {
                        $('#' + id).on('click', function (e) {
                            e.preventDefault();

                            placeholderClick(current);
                        });
                    }

                }

            })(current);
        }
    };

    /********** Events ***************/
    var sgMouseoverHandler = function (e) {
        e.stopPropagation();

        if (unbound) {
            return true;
        }

        if (this == document.body || this == document.body.parentNode) {
            return false;
        }

        var parent = firstSelectedOrSuggestedParent(this);
        if (parent != null && parent != this) {
            selectionRenderer.add(parent);
        } else {
            selectionRenderer.add(this);
        }

        return false;
    };

    var sgMouseoutHandler = function () {
        if (unbound) {
            return true;
        }

        if (this == document.body || this == document.body.parentNode) {
            return false;
        }

        selectionRenderer.remove();
        return false;
    };

    var sgMousedownHandler = function (e) {
        if ($(e.target).hasClass(IGNORED_CLASS)) return false;
        e.preventDefault();
        e.stopImmediatePropagation();
        if (unbound) {
            return true;
        }

        var elem = e.target;
        if ($(elem).hasClass(selectionRenderer.BORDER_CLASS)) {
            //Clicked on one of our floating borders, target the element that we are bordering.
            elem = elem.target_elem || elem;
        }

        if (elem == document.body || elem == document.body.parentNode) {
            return;
        }

        makePredictionPath(elem);

        selectionRenderer.remove();

        onElementSelectedHandler(elem);

        return false;
    };

    /********** Touch event handlers ***************/
    var touchElementSelectHandler = function (e) {
        e.preventDefault();
        e.stopImmediatePropagation();

        sgMouseoverHandler.call(this, e);
        sgMousedownHandler.call(this, e);
    };

    var needIgnoreTouchEvent = function () {

        if (ignoreTouchEvent > 0) {

            ignoreTouchEvent--;
            return true;
        }

        return false;
    };

    var elementTouchendHandler = function (e) {
        e.stopPropagation();

        if (needIgnoreTouchEvent()) {
            return true;
        }

        touchElementSelectHandler.call(this, e);
        return false;
    };

    var emptyEventHandler = function (e) {
        e.stopPropagation();

        return false;
    };

    var gestureEndHandler = function () {
        ignoreTouchEvent = 2;
        return true;
    };

    var touchMoveHandler = function () {
        ignoreTouchEvent = 1;
        return true;
    };


    var setupEventHandlers = function () {
        makeIFrameAndEmbeddedSelector();
        var elements = $("body *:not(." + IGNORED_CLASS + ")");

        if (isTouchEventsSupported) {
            elements.forEach(function (el) {
                el.addEventListener("gestureend", gestureEndHandler);
                el.addEventListener("touchmove", touchMoveHandler);
                el.addEventListener("touchend", elementTouchendHandler, true);
                el.addEventListener("touchstart", emptyEventHandler);
            });
        } else {
            elements.forEach(function (el) {
                el.addEventListener("mouseover", sgMouseoverHandler);
                el.addEventListener("mouseout", sgMouseoutHandler);
                el.addEventListener("click", sgMousedownHandler, true);
            });
        }

    };

    var deleteEventHandlers = function () {
        removePlaceholders();

        var elements = $("body *");
        if (isTouchEventsSupported) {
            elements.forEach(function (el) {
                el.removeEventListener("gestureend", gestureEndHandler);
                el.removeEventListener("touchmove", touchMoveHandler);
                el.removeEventListener("touchend", elementTouchendHandler, true);
                el.removeEventListener("touchstart", emptyEventHandler);
            });
        } else {
            elements.forEach(function (el) {
                el.removeEventListener("mouseover", sgMouseoverHandler);
                el.removeEventListener("mouseout", sgMouseoutHandler);
                el.removeEventListener("click", sgMousedownHandler, true);
            });
        }
    };

    //Define default implementation of selection renderer.
    selectionRenderer = BorderSelectionRenderer;

    // PUBLIC API

    /**
     * Starts selector module.
     *
     * @param onElementSelected callback function
     * @param selectionRenderImpl optional object contains selection presentation implementation
     */
    api.init = function (onElementSelected, selectionRenderImpl) {

        onElementSelectedHandler = onElementSelected;
        if (selectionRenderImpl && typeof selectionRenderImpl === "object") {
            selectionRenderer = selectionRenderImpl;
        }

        restrictedElements = ['html', 'body', 'head', 'base'].map(function (selector) {
            return $(selector).get(0);
        });
        predictionHelper = new DomPredictionHelper($, String);

        selectionRenderer.init();
        setupEventHandlers();
        unbound = false;
    };

    /**
     * Resets state of selector.
     * Clears current selection.
     */
    api.reset = function () {
        clearSelected();
    };

    /**
     * Destroys selector module.
     * Removes all selector elements and unbinds event handlers.
     */
    api.close = function () {
        unbound = true;

        selectionRenderer.finalize();
        deleteEventHandlers();
    };

    /**
     * Selects specified element.
     * Marks element as selected and holds selection on it.
     *
     * @param element
     */
    api.selectElement = function (element) {
        deleteEventHandlers();
        selectionRenderer.add(element);

        unbound = true;
    };

    /**
     Returns css class name.
     If this class assigns to HTML element, then Adguard Selector ignores it.
     */
    api.ignoreClassName = function () {
        return IGNORED_CLASS;
    };

    return api;

});

/**
 * Adguard rules constructor
 * @type {Function}
 */
var AdguardRulesConstructorLib = function (api) { // jshint ignore:line

    var CSS_RULE_MARK = '##';
    var RULE_OPTIONS_MARK = '$';

    var URLBLOCK_ATTRIBUTES = ["src", "data"];

    var linkHelper = document.createElement('a');

    /**
     * Constructs css selector for element using tag name, id and classed, like: tagName#id.class1.class2
     *
     * @param element Element
     * @param classList Override element classes (If classList is null, element classes will be used)
     * @param excludeTagName Omit tag name in selector
     * @param excludeId Omit element id in selector
     * @returns {string}
     */
    var makeDefaultCssFilter = function (element, classList, excludeTagName, excludeId) {
        var cssSelector = excludeTagName ? '' : element.tagName.toLowerCase();
        if (element.id && !excludeId) {
            cssSelector += '#' + cssEscape(element.id);
        }
        cssSelector += constructClassCssSelectorByAND(classList || element.classList);
        return cssSelector;
    };

    /**
     * Constructs css selector for element using parent elements and nth-child (first-child, last-child) pseudo classes.
     *
     * @param element Element
     * @param options Construct options. For example: {excludeTagName: false, excludeId: false, classList: []}
     * @returns {string}
     */
    var makeCssNthChildFilter = function (element, options) {

        options = options || {};

        var classList = options.classList;

        var excludeTagNameOverride = 'excludeTagName' in options;
        var excludeTagName = options.excludeTagName;

        var excludeIdOverride = 'excludeId' in options;
        var excludeId = options.excludeId;

        var path = [];
        var el = element;
        while (el.parentNode) {
            var nodeName = el && el.nodeName ? el.nodeName.toUpperCase() : "";
            if (nodeName === "BODY") {
                break;
            }
            if (el.id) {
                /**
                 * Be default we don't include tag name and classes to selector for element with id attribute
                 */
                var cssSelector = '';
                if (el === element) {
                    cssSelector = makeDefaultCssFilter(el, classList || [], excludeTagNameOverride ? excludeTagName : true, excludeIdOverride ? excludeId : false);
                } else {
                    cssSelector = makeDefaultCssFilter(el, [], true, false);
                }
                path.unshift(cssSelector);
                break;
            } else {
                var c = 1;
                for (var e = el; e.previousSibling; e = e.previousSibling) {
                    if (e.previousSibling.nodeType === 1) {
                        c++;
                    }
                }

                var cldCount = 0;
                for (var i = 0; el.parentNode && i < el.parentNode.childNodes.length; i++) {
                    cldCount += el.parentNode.childNodes[i].nodeType === 1 ? 1 : 0;
                }

                var ch;
                if (cldCount === 0 || cldCount === 1) {
                    ch = "";
                } else if (c === 1) {
                    ch = ":first-child";
                } else if (c === cldCount) {
                    ch = ":last-child";
                } else {
                    ch = ":nth-child(" + c + ")";
                }

                /**
                 * By default we include tag name and element classes to selector for element without id attribute
                 */
                if (el === element) {
                    var p = makeDefaultCssFilter(el, classList, excludeTagNameOverride ? excludeTagName : false, excludeId);
                    p += ch;
                    path.unshift(p);
                } else {
                    path.unshift(makeDefaultCssFilter(el, el.classList, false, false) + ch);
                }

                el = el.parentNode;
            }
        }
        return path.join(" > ");
    };

    /**
     * Constructs element selector for matching elements that contain any of classes in original element
     * For example <el class="cl1 cl2 cl3"></el> => .cl1, .cl2, .cl3
     *
     * @param element Element
     * @param classList Override element classes (If classList is null, element classes will be used)
     * @returns {string}
     */
    var makeSimilarCssFilter = function (element, classList) {
        return constructClassCssSelectorByOR(classList || element.classList);
    };

    /**
     * Creates css rule text
     * @param element Element
     * @param options Construct options. For example: {cssSelectorType: 'STRICT_FULL', excludeTagName: false, excludeId: false, classList: []}
     * @returns {string}
     */
    var constructCssRuleText = function (element, options) {

        if (!element) {
            return;
        }

        options = options || {};
        var cssSelectorType = options.cssSelectorType || 'STRICT_FULL';

        var selector;
        switch (cssSelectorType) {
            case 'STRICT_FULL':
                selector = makeCssNthChildFilter(element, options);
                break;
            case 'STRICT':
                selector = makeDefaultCssFilter(element, options.classList, options.excludeTagName, options.excludeId);
                break;
            case 'SIMILAR':
                selector = makeSimilarCssFilter(element, options.classList, true);
                break;
        }

        return selector ? CSS_RULE_MARK + selector : '';
    };

    var constructUrlBlockRuleText = function (element, urlBlockAttribute, oneDomain, domain) {

        if (!urlBlockAttribute) {
            return null;
        }

        var blockUrlRuleText = urlBlockAttribute.replace(/^http:\/\/(www\.)?/, "||");
        if (blockUrlRuleText.indexOf('.') === 0) {
            blockUrlRuleText = blockUrlRuleText.substring(1);
        }

        if (!oneDomain) {
            blockUrlRuleText = blockUrlRuleText + RULE_OPTIONS_MARK + "domain=" + domain;
        }

        return blockUrlRuleText;
    };

    var getUrlBlockAttribute = function (element) {
        if (!element || !element.getAttribute) {
            return null;
        }

        for (var i = 0; i < URLBLOCK_ATTRIBUTES.length; i++) {
            var attr = URLBLOCK_ATTRIBUTES[i];
            var value = element.getAttribute(attr);
            if (isValidUrl(value)) {
                return value;
            }
        }

        return null;
    };

    var haveUrlBlockParameter = function (element) {
        var value = getUrlBlockAttribute(element);
        return value && value !== '';
    };

    var haveClassAttribute = function (element) {
        return element.classList && element.classList.length > 0;
    };

    var haveIdAttribute = function (element) {
        return element.id && element.id.trim() !== '';
    };

    var cropDomain = function (url) {
        var domain = getUrl(url).host;
        return domain.replace("www.", "").replace(/:\d+/, '');
    };

    var getUrl = function (url) {
        var pattern = "^(([^:/\\?#]+):)?(//(([^:/\\?#]*)(?::([^/\\?#]*))?))?([^\\?#]*)(\\?([^#]*))?(#(.*))?$";
        var rx = new RegExp(pattern);
        var parts = rx.exec(url);

        return {
            host: parts[4] || "",
            path: parts[7] || ""
        };
    };

    var isValidUrl = function (value) {
        if (value) {
            linkHelper.href = value;
            if (linkHelper.hostname) {
                return true;
            }
        }

        return false;
    };

    /**
     * Constructs css selector by combining classes by AND
     * @param classList
     * @returns {string}
     */
    var constructClassCssSelectorByAND = function (classList) {
        var selectors = [];
        if (classList) {
            for (var i = 0; i < classList.length; i++) {
                selectors.push('.' + cssEscape(classList[i]));
            }
        }
        return selectors.join('');
    };

    /**
     * Constructs css selector by combining classes by OR
     * @param classList
     * @returns {string}
     */
    var constructClassCssSelectorByOR = function (classList) {
        var selectors = [];
        if (classList) {
            for (var i = 0; i < classList.length; i++) {
                selectors.push('.' + cssEscape(classList[i]));
            }
        }
        return selectors.join(', ');
    };

    /**
     * Utility method
     *
     * @param element
     * @returns {string}
     */
    api.makeCssNthChildFilter = makeCssNthChildFilter;

    /**
     * Returns detailed element info
     *
     * @param element
     */
    api.getElementInfo = function (element) {

        // Convert attributes to array
        var attributes = [];
        var elementAttributes = element.attributes;
        if (elementAttributes) {
            for (var i = 0; i < elementAttributes.length; i++) {
                var attr = elementAttributes[i];
                attributes.push({
                    name: attr.name,
                    value: attr.value
                });
            }
        }

        return {
            tagName: element.tagName,
            attributes: attributes,
            urlBlockAttributeValue: getUrlBlockAttribute(element),
            haveUrlBlockParameter: haveUrlBlockParameter(element),
            haveClassAttribute: haveClassAttribute(element),
            haveIdAttribute: haveIdAttribute(element)
        };
    };

    /**
     * Constructs css selector for specified rule
     *
     * @param ruleText rule text
     * @returns {string} css style selector
     */
    api.constructRuleCssSelector = function (ruleText) {
        if (!ruleText) {
            return null;
        }

        var index = ruleText.indexOf(CSS_RULE_MARK);
        var optionsIndex = ruleText.indexOf(RULE_OPTIONS_MARK);

        if (index >= 0) {
            return ruleText.substring(index + CSS_RULE_MARK.length, optionsIndex >= 0 ? optionsIndex : ruleText.length);
        }

        var s = ruleText.substring(0, optionsIndex);
        s = s.replace(/[\|]|[\^]/g, '');

        if (isValidUrl(s)) {
            return '[src*="' + s + '"]';
        }

        return null;
    };

    /**
     * Constructs adguard rule text from element node and specified options
     *
     * var options = {
	 *	urlMask: url block attributes,
	 *	isBlockOneDomain: boolean,
	 *	url: url,
	 *  attributes: attributesSelectorText,
	 *  ruleType: (URL, CSS)
	 *  cssSelectorType: (STRICT_FULL, STRICT, SIMILAR),
	 *  excludeTagName: false, (Exclude element tag name from selector)
	 *  excludeId: false, (Exclude element identifier from selector)
	 *  classList: [] (Override element classes (If classList is null, element classes will be used))
	 * }
     *
     * @param element
     * @param options
     * @returns {*}
     */
    api.constructRuleText = function (element, options) {

        var croppedDomain = cropDomain(options.url);

        var ruleType = options.ruleType;

        if (ruleType === 'URL') {
            var blockUrlRuleText = constructUrlBlockRuleText(element, options.urlMask, options.isBlockOneDomain, croppedDomain);
            if (blockUrlRuleText) {
                return blockUrlRuleText;
            }
        }

        var result;

        if (ruleType === 'CSS') {

            result = constructCssRuleText(element, options);

            // Append html attributes to css selector
            if (options.attributes) {
                result = (result ? result : CSS_RULE_MARK + result) + options.attributes;
            }
        }

        if (!options.isBlockOneDomain) {
            result = croppedDomain + result;
        }

        return result;
    };

    return api;

};
/**
 * Manages iframe and it's content
 * @param $
 * @param settings
 * @param uiUtils
 * @param gmApi
 * @param log
 * @param selector
 * @param uiValidationUtils
 * @param localization
 * @param resources
 * @returns {{showDetailedMenu: showDetailedMenu, showSelectorMenu: showSelectorMenu, showSliderMenu: showSliderMenu, showBlockPreview: showBlockPreview, showSettingsMenu: showSettingsMenu, setButtonPosition: setButtonPosition, onCloseMenu: CustomEvent, onShowMenuItem: CustomEvent, removeIframe: removeIframe, resizeSliderMenuToAdvanced: resizeSliderMenuToAdvanced, resizeSliderMenuToNormal: resizeSliderMenuToNormal}}
 * @constructor
 */
/* global StringUtils, Ioc, DetailedMenuController, SelectorMenuController, SliderMenuController, BlockPreviewController, SettingsMenuController */
var IframeController = function ($, settings, uiUtils, gmApi, log, selector, uiValidationUtils, localization, resources) { // jshint ignore:line
    var iframe = null;
    var currentItem = null;
    var iframeMaxWidth = 418;
    var iframeMaxHeight = 407;
    var iframePositionOffset = 5;
    var sliderMenuHeight = {advanced: 503, normal: 403};
    var buttonPosition = null;

    var onCloseMenu = new CustomEvent();
    var onShowMenuItem = new CustomEvent();

    var createIframe = function (onIframeLoadCallback) {
        log.debug('Creating iframe');
        iframe = $('<iframe/>');
        var iframePosition = getIframePosition();
        var css = {
            position: 'fixed',
            left: iframePosition.left + 'px',
            top: iframePosition.top + 'px',
            clip: 'auto'
        };
        var attributes = {
            id: settings.Constants.IFRAME_ID,
            'class': selector.ignoreClassName(),
            frameBorder: 0,
            allowTransparency: 'true'
        };
        Object.keys(css).forEach(function (item) {
            iframe.css(item, css[item]);
        });
        Object.keys(attributes).forEach(function (item) {
            iframe.attr(item, attributes[item]);
        });
        var iframeAlreadyLoaded = false;
        $(iframe).on('load', function () {
            if (iframeAlreadyLoaded) {
                //IE calls load each time when we use document.close
                return;
            }
            iframeAlreadyLoaded = true;
            appendDefaultStyle();
            onIframeLoadCallback();
        });
        var body = $('body')[0];
        if (!body) {
            log.error("Body not found");
            return;
        }
        body.appendChild(iframe[0]);
    };

    var getIframePosition = function () {
        var viewPort = uiValidationUtils.getViewPort();

        var defaultPosition = {
            left: buttonPosition.left,
            top: buttonPosition.top
        };
        var sides = [{//left top
            left: buttonPosition.left - iframeMaxWidth - iframePositionOffset,
            top: buttonPosition.top - iframeMaxHeight - iframePositionOffset
        },
            {   //right top
                left: buttonPosition.left + iframePositionOffset,
                checkLeft: buttonPosition.left + iframeMaxWidth + iframePositionOffset,
                top: buttonPosition.top - iframeMaxHeight - iframePositionOffset
            },
            {   //bottom right
                left: buttonPosition.left + iframePositionOffset,
                checkLeft: buttonPosition.left + iframeMaxWidth + iframePositionOffset,
                checkTop: buttonPosition.top + iframeMaxHeight + iframePositionOffset,
                top: buttonPosition.top + iframePositionOffset
            },
            {   //bottom left
                left: buttonPosition.left - iframeMaxWidth - iframePositionOffset,
                checkTop: buttonPosition.top + iframeMaxHeight + iframePositionOffset,
                top: buttonPosition.top + iframePositionOffset
            }];

        for (var i = 0; i < sides.length; i++) {
            var currentSide = sides[i];
            var left = currentSide.checkLeft ? currentSide.checkLeft : currentSide.left;
            var top = currentSide.checkTop ? currentSide.checkTop : currentSide.top;

            if (left < 0 || left > viewPort.width) {
                continue;
            }
            if (top < 0 || top > viewPort.height) {
                continue;
            }
            return currentSide;
        }

        return defaultPosition;
    };

    var specifyIframePosition = function () {
        var viewPort = uiValidationUtils.getViewPort();
        var frameElement = iframe[0];
        if ((frameElement.offsetLeft + frameElement.offsetWidth) > viewPort.width) {
            frameElement.style.left = Math.max(0, (viewPort.width - frameElement.offsetWidth - iframePositionOffset)) + 'px';
        }
        if (frameElement.offsetLeft < 0) {
            frameElement.style.left = iframePositionOffset + 'px';
        }
        if ((frameElement.offsetTop + frameElement.offsetHeight) > viewPort.height) {
            frameElement.style.top = Math.max(0, (viewPort.height - frameElement.offsetHeight - iframePositionOffset)) + 'px';
        }
        if (frameElement.offsetHeight < 0) {
            frameElement.style.top = iframePositionOffset + 'px';
        }

    };

    var appendDefaultStyle = function () {
        try {
            log.info('Iframe loaded writing styles');
            var doc = iframe[0].contentDocument;
            doc.open();
            doc.write(StringUtils.format("<html><head>{0}</head></html>",
                StringUtils.format('<style {0} type="text/css">{1}</style>', getStyleNonce(), resources.getResource('style.css'))));
            doc.close();
        } catch (ex) {
            log.error(ex);
        }
    };

    var getStyleNonce = function () {
        var adgSettings = settings.getAdguardSettings();
        if (adgSettings === null) {
            return '';
        }
        return 'nonce="' + adgSettings.nonce + '"';
    };

    var showMenuItem = function (viewName, controller, width, height, options) {
        log.debug(StringUtils.format("Showing menu item: {0}", viewName));
        if (currentItem === viewName) {
            return;
        }
        var onIframeLoad = function () {
            var frameElement = iframe[0];
            frameElement.width = width;
            frameElement.height = height;
            var view = $(resources.getResource(viewName))[0];
            appendContent(view);
            localize();
            specifyIframePosition();
            if (!options) {
                options = {};
            }
            controller.init(frameElement, options);
            currentItem = viewName;
            onShowMenuItem.notify();
            if (options.dragElement) {
                uiUtils.makeIframeDraggable(iframe, $(frameElement.contentDocument.getElementsByClassName(options.dragElement)));
            }
        };
        if (!iframe) {
            createIframe(onIframeLoad);
            return;
        }
        onIframeLoad();
    };

    var setButtonPosition = function (coords) {
        buttonPosition = coords;
    };

    var showDetailedMenu = function () {
        var controller = Ioc.get(DetailedMenuController);
        var options = {dragElement: 'menu-head'};
        showMenuItem(settings.MenuItemsNames.DetailedMenu, controller, 418, 456, options);
        setCloseEventIfNotHitIframe(true);
    };

    var showSelectorMenu = function () {
        var controller = Ioc.get(SelectorMenuController);
        var options = {dragElement: 'head'};
        showMenuItem(settings.MenuItemsNames.SelectorMenu, controller, 668, 213, options);
        setCloseEventIfNotHitIframe(false);
    };

    var showSliderMenu = function (element) {
        var controller = Ioc.get(SliderMenuController);
        var options = {element: element, dragElement: 'head'};
        showMenuItem(settings.MenuItemsNames.SliderMenu, controller, 668, sliderMenuHeight.normal, options);
        setCloseEventIfNotHitIframe(false);
    };

    var showBlockPreview = function (element, path) {
        var controller = Ioc.get(BlockPreviewController);
        var options = {element: element, path: path, dragElement: 'head'};
        showMenuItem(settings.MenuItemsNames.BlockPreview, controller, 668, 213, options);
        setCloseEventIfNotHitIframe(false);
    };

    var showSettingsMenu = function () {
        var controller = Ioc.get(SettingsMenuController);
        var options = {dragElement: 'head'};
        showMenuItem(settings.MenuItemsNames.SettingsMenu, controller, 458, 414, options);
        setCloseEventIfNotHitIframe(false);
    };

    var localize = function () {
        var elements = iframe[0].contentDocument.querySelectorAll("[i18n]");
        for (var i = 0; i < elements.length; i++) {
            var message = localization.getMessage(elements[i].getAttribute("i18n"));
            localization.translateElement(elements[i], message);
        }
    };

    var resizeIframe = function (width, height) {
        var frame = iframe[0];
        if (width) {
            frame.style.width = width + 'px';
        }
        if (height) {
            frame.style.height = height + 'px';
        }
    };

    var resizeSliderMenuToAdvanced = function () {
        resizeIframe(null, sliderMenuHeight.advanced);
    };

    var resizeSliderMenuToNormal = function () {
        resizeIframe(null, sliderMenuHeight.normal);
    };

    var appendContent = function (view) {
        var body = iframe[0].contentDocument.body;
        for (var i = 0; i < body.children.length; i++) {
            body.removeChild(body.children[i]);
        }
        body.appendChild(view);
    };

    var setCloseEventIfNotHitIframe = function () {
        window.setTimeout(function () {
            $(document).on('click', removeIframe);
        }, 150);
    };

    var removeIframe = function () {
        $(document).off('click', removeIframe);
        $('body')[0].removeChild(iframe[0]);
        iframe = null;
        currentItem = null;
        selector.close();
        onCloseMenu.notify();
    };

    return {
        showDetailedMenu: showDetailedMenu,
        showSelectorMenu: showSelectorMenu,
        showSliderMenu: showSliderMenu,
        showBlockPreview: showBlockPreview,
        showSettingsMenu: showSettingsMenu,
        setButtonPosition: setButtonPosition,
        onCloseMenu: onCloseMenu,
        onShowMenuItem: onShowMenuItem,
        removeIframe: removeIframe,
        resizeSliderMenuToAdvanced: resizeSliderMenuToAdvanced,
        resizeSliderMenuToNormal: resizeSliderMenuToNormal
    };
};

/**
 * Gm api wrapper
 * @param ADG_addRule
 * @param ADG_temporaryDontBlock
 * @param ADG_sendAbuse
 * @param ADG_isFiltered
 * @param ADG_changeFilteringState
 * @returns {{GM_getValue, GM_setValue, GM_getResourceText, GM_addStyle, ADG_addRule: *, ADG_temporaryDontBlock: *, ADG_sendAbuse: *, ADG_isFiltered: *, ADG_changeFilteringState: *}}
 * @constructor
 */
/* global GM_getValue, GM_setValue, GM_getResourceText, GM_addStyle */
var GM = function (ADG_addRule, ADG_temporaryDontBlock, ADG_sendAbuse, ADG_isFiltered, ADG_changeFilteringState) { // jshint ignore:line
    if (!ADG_addRule) {
        ADG_addRule = function (rule, callback) {
            alert('GM_api is not supported. ' + rule + ' rule added');
            callback();
        };
    }

    if (!ADG_sendAbuse) {
        ADG_sendAbuse = function (url, callback) {
            alert('GM_api is not supported. ' + url + 'abused');
            callback();
        };
    }

    if (!ADG_temporaryDontBlock) {
        ADG_temporaryDontBlock = function (timeout, callback) {
            alert('GM_api is not supported. ' + 'Do not block for ' + timeout + ' seconds');
            callback();
        };
    }

    if (!ADG_isFiltered) {
        ADG_isFiltered = function (callback) {
            callback();
            return true;
        };
    }

    if (!ADG_changeFilteringState) {
        ADG_changeFilteringState = function (callback) {
            alert('GM_api is not supported. ' + 'State changed');
            callback();
        };
    }

    return {
        GM_getValue: GM_getValue,
        GM_setValue: GM_setValue,
        GM_getResourceText: GM_getResourceText,
        GM_addStyle: GM_addStyle,
        ADG_addRule: ADG_addRule,
        ADG_temporaryDontBlock: ADG_temporaryDontBlock,
        ADG_sendAbuse: ADG_sendAbuse,
        ADG_isFiltered: ADG_isFiltered,
        ADG_changeFilteringState: ADG_changeFilteringState
    };
};
/**
 * Slider widget
 * @type {Function}
 */
var SliderWidget = (function (api, $) { // jshint ignore:line
    var PLACEHOLDER_CLASS = "adg-slide ui-slider ui-slider-horizontal ui-widget ui-widget-content ui-corner-all";
    var HANDLE_CLASS = "ui-slider-handle";
    var HANDLE_FULL_CLASS = "ui-slider-handle ui-state-default ui-corner-all";
    var TICK_CLASS = "tick";
    var TICK_FULL_CLASS = "tick ui-widget-content";
    var TICK_LEFT_COLOR = "#36BA53";
    var TICK_RIGHT_COLOR = "#E0DFDB";

    var placeholder = null;

    var min = 0;
    var max = 1;
    var value = 0;
    var sliderArea = null;

    var onValueChanged = null;


    var refresh = function () {
        var handle = placeholder.querySelectorAll("." + HANDLE_CLASS);
        $(handle).css('left', (value - 1) * 100 / (max - min) + "%");

        var ticks = placeholder.querySelectorAll("." + TICK_CLASS);
        for (var i = 0; i < ticks.length; i++) {
            if (i + 1 < value) {
                $(ticks[i]).css('background-color', TICK_LEFT_COLOR);
            } else {
                $(ticks[i]).css('background-color', TICK_RIGHT_COLOR);
            }
        }
    };

    var render = function () {
        $(placeholder).addClass(PLACEHOLDER_CLASS);

        var handle = document.createElement('a');
        handle.setAttribute('href', '#');
        handle.setAttribute('class', HANDLE_FULL_CLASS);
        placeholder.appendChild(handle);

        var count = max - min;
        var prepare = function (i) {
            var tick = document.createElement('div');
            tick.setAttribute('class', TICK_FULL_CLASS);
            tick.style.left = (100 / count * i) + '%';
            tick.style.width = (100 / count) + '%';

            placeholder.appendChild(tick);
        };

        for (var i = 0; i < count; i++) {
            prepare(i);
        }

        refresh();
    };

    var setValue = function (v) {
        if (v < min) {
            value = min;
        } else if (v > max) {
            value = max;
        } else {
            value = v;
        }

        refresh();

        onValueChanged(value);
    };

    var bindEvents = function () {
        var $placeholder = $(placeholder);
        var handle = placeholder.querySelectorAll("." + HANDLE_CLASS);
        var $handle = $(handle);
        var $sliderArea = $(sliderArea);

        $(document).on('mouseup', function () {
            $placeholder.off('mousemove');
            $handle.off('mousemove');
        });

        //While the ui-slider-handle is being held down reference it parent.
        $handle.on('mousedown', function (e) {
            e.preventDefault();
            return $(this.parentNode).trigger('mousedown');
        });

        var rect = placeholder.getBoundingClientRect();
        var sliderWidth = rect.width;
        var offsetLeft = rect.left + document.body.scrollLeft;

        var getSliderValue = function (pageX) {
            return Math.round((max - min) / sliderWidth * (pageX - offsetLeft) + min);
        };

        //This will prevent the slider from moving if the mouse is taken out of the
        //slider area before the mouse down has been released.
        $placeholder.on('mouseenter', function () {
            $placeholder.on('click', function (e) {
                //calculate the correct position of the slider set the value
                var value = getSliderValue(e.pageX);
                setValue(value);
            });
            $placeholder.on('mousedown', function () {
                $sliderArea.on('mousemove', function (e) {
                    //calculate the correct position of the slider set the value
                    var value = getSliderValue(e.pageX);
                    setValue(value);
                });
            });
            $sliderArea.on('mouseup', function () {
                $(this).off('mousemove');
            });
        });

        $sliderArea.on('mouseleave', function () {
            $(this).off('mousemove');
            $placeholder.off('click');
        });
    };

    /**
     *
     * @param placeholderElement
     * @param options
     */
    api.init = function (placeholderElement, options) {
        placeholder = placeholderElement;

        min = options.min;
        max = options.max;
        value = options.value;
        onValueChanged = options.onValueChanged;
        sliderArea = options.sliderArea;

        render();
        bindEvents();
    };

    return api;
});

/**
 * Object that manages wot data
 * @returns {{registerWotEventHandler: Function, getWotData: Function, getWotScorecardUrl: Function, WOT_URL: string}}
 * @constructor
 */
/* global StringUtils */
var Wot = function () { // jshint ignore:line
    var wotUrlScorecardTemplate = 'http://adguard.com/wot-scorecard.html?domain={0}';
    var WOT_URL = 'http://adguard.com/wot.html';
    var wotData = null;

    /*
     Waiting for event from wot extension. Send event back to stop
     firing wot extension events
     */
    var registerWotEventHandler = function () {
        document.addEventListener('wot-score', function (e) {
            wotData = e.data.wotData;
            fireEvent('wot-accepted', null);
        });
    };

    var getWotData = function () {
        return wotData;
    };

    var getWotScorecardUrl = function (url) {
        return StringUtils.format(wotUrlScorecardTemplate, url);
    };

    var fireEvent = function (name, data) {
        var event = document.createEvent("Events");
        event.initEvent(name, true, true);
        event.data = data;
        document.dispatchEvent(event);
    };

    return {
        registerWotEventHandler: registerWotEventHandler,
        getWotData: getWotData,
        getWotScorecardUrl: getWotScorecardUrl,
        WOT_URL: WOT_URL
    };
};

var ru = {
    "menu_filtration_status": {
        "message": "\u0424\u0438\u043b\u044c\u0442\u0440\u0430\u0446\u0438\u044f \u043d\u0430 \u044d\u0442\u043e\u043c \u0441\u0430\u0439\u0442\u0435"
    },
    "menu_do_not_filter_30_sec": {
        "message": "\u041d\u0435 \u0444\u0438\u043b\u044c\u0442\u0440\u043e\u0432\u0430\u0442\u044c 30 \u0441\u0435\u043a\u0443\u043d\u0434"
    },
    "menu_block_ad_on_site": {
        "message": "\u0417\u0430\u0431\u043b\u043e\u043a\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0440\u0435\u043a\u043b\u0430\u043c\u0443 \u043d\u0430 \u0441\u0430\u0439\u0442\u0435"
    },
    "menu_report_abuse": {
        "message": "\u041f\u043e\u0436\u0430\u043b\u043e\u0432\u0430\u0442\u044c\u0441\u044f \u043d\u0430 \u0441\u0430\u0439\u0442"
    },
    "menu_site_report": {
        "message": "\u041e\u0442\u0447\u0451\u0442 \u043e \u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u043e\u0441\u0442\u0438 \u0441\u0430\u0439\u0442\u0430"
    },
    "menu_settings": {
        "message": "\u041d\u0430\u0441\u0442\u0440\u043e\u0438\u0442\u044c \u043f\u043e\u043c\u043e\u0449\u043d\u0438\u043a"
    },
    "assistant_select_element": {
        "message": " \u0411\u043b\u043e\u043a\u0438\u0440\u043e\u0432\u043a\u0430 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430"
    },
    "assistant_select_element_ext": {
        "message": "\u0412\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u043d\u0430 \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0435 \u044d\u043b\u0435\u043c\u0435\u043d\u0442, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043d\u0430\u0434\u043e \u0437\u0430\u0431\u043b\u043e\u043a\u0438\u0440\u043e\u0432\u0430\u0442\u044c"
    },
    "assistant_select_element_cancel": {
        "message": "\u041e\u0442\u043c\u0435\u043d\u0430"
    },
    "assistant_block_element": {
        "message": "\u0411\u043b\u043e\u043a\u0438\u0440\u043e\u0432\u043a\u0430 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430"
    },
    "assistant_block_element_explain": {
        "message": "\u041d\u0430\u0441\u0442\u0440\u043e\u0439\u0442\u0435 \u043f\u0440\u0430\u0432\u0438\u043b\u043e \u0431\u043b\u043e\u043a\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430"
    },
    "assistant_slider_explain": {
        "message": "\u041f\u0435\u0440\u0435\u043c\u0435\u0449\u0430\u0439\u0442\u0435 \u0431\u0435\u0433\u0443\u043d\u043e\u043a, \u0447\u0442\u043e\u0431\u044b \u0438\u0437\u043c\u0435\u043d\u0438\u0442\u044c \u0440\u0430\u0437\u043c\u0435\u0440 \u0431\u043b\u043e\u043a\u0430, \u0434\u043b\u044f \u043a\u043e\u0442\u043e\u0440\u043e\u0433\u043e \u0431\u0443\u0434\u0435\u0442 \u0434\u0435\u0439\u0441\u0442\u0432\u043e\u0432\u0430\u0442\u044c \u043f\u0440\u0430\u0432\u0438\u043b\u043e:"
    },
    "assistant_slider_min": {
        "message": "MIN"
    },
    "assistant_slider_max": {
        "message": "MAX"
    },
    "assistant_extended_settings": {
        "message": "\u0420\u0430\u0441\u0448\u0438\u0440\u0435\u043d\u043d\u044b\u0435 \u043d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0438"
    },
    "assistant_apply_rule_to_all_sites": {
        "message": "\u041f\u0440\u0438\u043c\u0435\u043d\u0438\u0442\u044c \u043f\u0440\u0430\u0432\u0438\u043b\u043e \u0434\u043b\u044f \u0432\u0441\u0435\u0445 \u0441\u0430\u0439\u0442\u043e\u0432"
    },
    "assistant_block_by_reference": {
        "message": "\u0411\u043b\u043e\u043a\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u043f\u043e \u0441\u0441\u044b\u043b\u043a\u0435"
    },
    "assistant_block_similar": {
        "message": "\u0411\u043b\u043e\u043a\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u043f\u043e\u0445\u043e\u0436\u0438\u0435"
    },
    "assistant_another_element": {
        "message": "\u0412\u044b\u0431\u0440\u0430\u0442\u044c \u0434\u0440\u0443\u0433\u043e\u0439 \u044d\u043b\u0435\u043c\u0435\u043d\u0442"
    },
    "assistant_preview": {
        "message": "\u041f\u0440\u0435\u0434\u043f\u0440\u043e\u0441\u043c\u043e\u0442\u0440"
    },
    "assistant_block": {
        "message": "\u0417\u0430\u0431\u043b\u043e\u043a\u0438\u0440\u043e\u0432\u0430\u0442\u044c"
    },
    "assistant_settings": {
        "message": "\u041d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0430 \u043f\u043e\u043c\u043e\u0449\u043d\u0438\u043a\u0430"
    },
    "assistant_preview_header": {
        "message": "\u0411\u043b\u043e\u043a\u0438\u0440\u043e\u0432\u043a\u0430 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430 - \u043f\u0440\u0435\u0434\u043f\u0440\u043e\u0441\u043c\u043e\u0442\u0440"
    },
    "assistant_preview_header_info": {
        "message": "\u0423\u0431\u0435\u0434\u0438\u0442\u0435\u0441\u044c, \u0447\u0442\u043e \u044d\u043b\u0435\u043c\u0435\u043d\u0442 \u0437\u0430\u0431\u043b\u043e\u043a\u0438\u0440\u043e\u0432\u0430\u043d \u043a\u0430\u043a \u0437\u0430\u0434\u0443\u043c\u0430\u043d\u043e"
    },
    "assistant_preview_end": {
        "message": "\u0417\u0430\u043a\u043e\u043d\u0447\u0438\u0442\u044c \u043f\u0440\u0435\u0434\u043f\u0440\u043e\u0441\u043c\u043e\u0442\u0440"
    },
    "wot_unknown_description": {
        "message": "\u0420\u0435\u043f\u0443\u0442\u0430\u0446\u0438\u044f \u043d\u0435 \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0430"
    },
    "wot_bad_description": {
        "message": "\u0423 \u0441\u0430\u0439\u0442\u0430 \u043e\u0447\u0435\u043d\u044c \u043f\u043b\u043e\u0445\u0430\u044f \u0440\u0435\u0443\u0442\u0430\u0446\u0438\u044f \u043f\u043e \u0434\u0430\u043d\u043d\u044b\u043c "
    },
    "wot_poor_description": {
        "message": "\u0423 \u0441\u0430\u0439\u0442\u0430 \u043f\u043b\u043e\u0445\u0430\u044f \u0440\u0435\u0443\u0442\u0430\u0446\u0438\u044f \u043f\u043e \u0434\u0430\u043d\u043d\u044b\u043c "
    },
    "wot_unsatisfactory_description": {
        "message": "\u0423 \u0441\u0430\u0439\u0442\u0430 \u043d\u0435\u0443\u0434\u0432\u043e\u043b\u0435\u0442\u0432\u043e\u0440\u0438\u0442\u0435\u043b\u044c\u043d\u0430\u044f \u0440\u0435\u0443\u0442\u0430\u0446\u0438\u044f \u043f\u043e \u0434\u0430\u043d\u043d\u044b\u043c "
    },
    "wot_good_description": {
        "message": "\u0423 \u0441\u0430\u0439\u0442\u0430 \u0445\u043e\u0440\u043e\u0448\u0430\u044f \u0440\u0435\u0443\u0442\u0430\u0446\u0438\u044f \u043f\u043e \u0434\u0430\u043d\u043d\u044b\u043c "
    },
    "wot_excellent_description": {
        "message": "\u0423 \u0441\u0430\u0439\u0442\u0430 \u043e\u0442\u043b\u0438\u0447\u043d\u0430\u044f \u0440\u0435\u0443\u0442\u0430\u0446\u0438\u044f \u043f\u043e \u0434\u0430\u043d\u043d\u044b\u043c "
    },
    "settings_choose_size_and_position": {
        "message": "\u041d\u0430\u0441\u0442\u0440\u043e\u0439\u0442\u0435 \u0440\u0430\u0437\u043c\u0435\u0440 \u0438 \u043f\u043e\u043b\u043e\u0436\u0435\u043d\u0438\u0435 \u043f\u043e\u043c\u043e\u0449\u043d\u0438\u043a\u0430 Adguard"
    },
    "settings_icon_size": {
        "message": "\u0420\u0430\u0437\u043c\u0435\u0440 \u0438\u043a\u043e\u043d\u043a\u0438:"
    },
    "settings_small": {
        "message": "\u041c\u0430\u043b\u0435\u043d\u044c\u043a\u0430\u044f"
    },
    "settings_big": {
        "message": "\u0411\u043e\u043b\u044c\u0448\u0430\u044f"
    },
    "settings_position": {
        "message": "\u0420\u0430\u0441\u043f\u043e\u043b\u043e\u0436\u0435\u043d\u0438\u0435:"
    },
    "settings_left_top": {
        "message": "\u0412\u0432\u0435\u0440\u0445\u0443 \u0441\u043b\u0435\u0432\u0430"
    },
    "settings_right_top": {
        "message": "\u0412\u0432\u0435\u0440\u0445\u0443 \u0441\u043f\u0440\u0430\u0432\u0430"
    },
    "settings_left_bottom": {
        "message": "\u0412\u043d\u0438\u0437\u0443 \u0441\u043b\u0435\u0432\u0430"
    },
    "settings_right_bottom": {
        "message": "\u0412\u043d\u0438\u0437\u0443 \u0441\u043f\u0440\u0430\u0432\u0430"
    },
    "settings_cancel": {
        "message": "\u041e\u0442\u043c\u0435\u043d\u0430"
    },
    "settings_save": {
        "message": "\u0421\u043e\u0445\u0440\u0430\u043d\u0438\u0442\u044c \u043d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0438"
    }
}
var en = {
    "menu_filtration_status": {
        "message": "Filtering on this website"
    },
    "menu_do_not_filter_30_sec": {
        "message": "Do not filter for 30 seconds"
    },
    "menu_block_ad_on_site": {
        "message": "Block ad on this website"
    },
    "menu_report_abuse": {
        "message": "Report the website"
    },
    "menu_site_report": {
        "message": "Website security report"
    },
    "menu_settings": {
        "message": "Assistant settings"
    },
    "assistant_select_element": {
        "message": "Element blocking"
    },
    "assistant_select_element_ext": {
        "message": "Choose an element on the page to block"
    },
    "assistant_select_element_cancel": {
        "message": "Cancel"
    },
    "assistant_block_element": {
        "message": "Element blocking"
    },
    "assistant_block_element_explain": {
        "message": "Adjust element blocking rule"
    },
    "assistant_slider_explain": {
        "message": "Move the slider to change the size of the frame the new rule will work for:"
    },
    "assistant_slider_min": {
        "message": "MIN"
    },
    "assistant_slider_max": {
        "message": "MAX"
    },
    "assistant_extended_settings": {
        "message": "Advanced settings"
    },
    "assistant_apply_rule_to_all_sites": {
        "message": "Apply the rule to all websites"
    },
    "assistant_block_by_reference": {
        "message": "Block by reference link"
    },
    "assistant_block_similar": {
        "message": "Block similar"
    },
    "assistant_another_element": {
        "message": "Select another element"
    },
    "assistant_preview": {
        "message": "Preview"
    },
    "assistant_block": {
        "message": "Block"
    },
    "assistant_settings": {
        "message": "Assistant settings"
    },
    "assistant_preview_header": {
        "message": "Element blocking - preview"
    },
    "assistant_preview_header_info": {
        "message": "Make sure that element is blocked as intended"
    },
    "assistant_preview_end": {
        "message": "Exit preview"
    },
    "wot_unknown_description": {
        "message": "Reputation is not defined"
    },
    "wot_bad_description": {
        "message": "This website has very bad reputation\naccording to "
    },
    "wot_poor_description": {
        "message": "This website has bad reputation\naccording to "
    },
    "wot_unsatisfactory_description": {
        "message": "This website has poor reputation\naccording to "
    },
    "wot_good_description": {
        "message": "This website has good reputation\naccording to "
    },
    "wot_excellent_description": {
        "message": "This website has excellent reputation\naccording to "
    },
    "settings_choose_size_and_position": {
        "message": "Adjust Adguard Assistant size and position"
    },
    "settings_icon_size": {
        "message": "Icon size:"
    },
    "settings_small": {
        "message": "Small"
    },
    "settings_big": {
        "message": "Large"
    },
    "settings_position": {
        "message": "Position:"
    },
    "settings_left_top": {
        "message": "Top left"
    },
    "settings_right_top": {
        "message": "Top right"
    },
    "settings_left_bottom": {
        "message": "Bottom left"
    },
    "settings_right_bottom": {
        "message": "Bottom right"
    },
    "settings_cancel": {
        "message": "Cancel"
    },
    "settings_save": {
        "message": "Save changes"
    }
}
/**
 * Object that manages localizations
 * @returns {{getMessage: Function, translateElement: Function}}
 * @constructor
 */
/* global en, ru, AdguardSettings */

var Localization = function () { // jshint ignore:line
    var currentLocale = null;
    var SupportedLocales = {'en': en, 'ru': ru};

    if (typeof AdguardSettings !== 'undefined') {
        var locale = AdguardSettings.locale;
        if (SupportedLocales[locale]) {
            currentLocale = locale;
        }
    }
    if (!currentLocale) {
        currentLocale = 'en';
    }


    var getMessage = function (messageId) {
        var message = SupportedLocales[currentLocale][messageId];
        if (!message) {
            throw messageId + ' not localized';
        }
        return SupportedLocales[currentLocale][messageId].message;
    };

    var translateElement = function (element, message) {
        try {
            while (element.lastChild) {
                element.removeChild(element.lastChild);
            }
            processString(message, element);
        } catch (ex) {
            // Ignore exceptions
        }
    };

    var processString = function (str, element) {
        var el;

        var match1 = /^([^]*?)<(a|strong|span|i)([^>]*)>(.*?)<\/\2>([^]*)$/m.exec(str);
        var match2 = /^([^]*?)<(br|input)([^>]*)\/?>([^]*)$/m.exec(str);
        if (match1) {

            processString(match1[1], element);

            el = createElement(match1[2], match1[3]);

            processString(match1[4], el);
            element.appendChild(el);

            processString(match1[5], element);

        } else if (match2) {

            processString(match2[1], element);

            el = createElement(match2[2], match2[3]);
            element.appendChild(el);

            processString(match2[4], element);

        } else {
            element.appendChild(document.createTextNode(str.replace(/&nbsp;/g, '\u00A0')));
        }
    };

    var createElement = function (tagName, attributes) {

        var el = document.createElement(tagName);
        if (!attributes) {
            return el;
        }

        var attrs = attributes.split(/([a-z]+='[^']+')/);
        for (var i = 0; i < attrs.length; i++) {
            var attr = attrs[i].trim();
            if (!attr) {
                continue;
            }
            var index = attr.indexOf("=");
            var attrName;
            var attrValue;
            if (index > 0) {
                attrName = attr.substring(0, index);
                attrValue = attr.substring(index + 2, attr.length - 1);
            }
            if (attrName && attrValue) {
                el.setAttribute(attrName, attrValue);
            }
        }
        return el;
    };

    return {
        getMessage: getMessage,
        translateElement: translateElement
    };
};

/**
 * Main menu controller
 * @param $
 * @param wot
 * @param localization
 * @param gmApi
 * @returns {{init: init}}
 * @constructor
 */
/* global Ioc, StringUtils, punycode */
var DetailedMenuController = function($, wot, localization, gmApi, settings, log) { // jshint ignore:line
    var contentDocument = null;
    var iframeCtrl = null;
    var domain = null;
    var FILTERING_STATE_LS_PROPERTY = '__adfstate';

    /*
     Called from IframeController._showMenuItem to initialize view
     */
    var init = function(iframe) {
        contentDocument = iframe.contentDocument;
        iframeCtrl = Ioc.get('iframeController');
        setDomain();
        setWotData();
        bindEvents();
        setInitFilteringState();
    };

    var setDomain = function() {
        domain = punycode.toUnicode(location.hostname);
        contentDocument.getElementsByClassName('menu-head_name')[0].textContent = domain;
    };

    var bindEvents = function() {
        var menuEvents = {
            '.close': iframeCtrl.removeIframe,
            '#block-ad': startAdSelector,
            '#assistant-settings': iframeCtrl.showSettingsMenu,
            '#WotDescriptionText': goToWotUrl,
            '#do-not-block-30-sec': doNotBlock,
            '#report-abuse': reportAbuse,
            '#site-report': goToSiteReport,
            '#is-filter': onIsFilterChange
        };
        Object.keys(menuEvents).forEach(function(item) {
            $(contentDocument.querySelectorAll(item)).on('click', menuEvents[item]);
        });
    };

    var onIsFilterChange = function() {
        var isFilter = contentDocument.getElementById('is-filter').checked;

        // animate class for prevent animation while the state from the application is determined
        $(contentDocument.querySelectorAll(".menu-filter_label")).addClass("animate");

        showHideBlockAdButton(isFilter);
        setFilteringStateToStore(isFilter);
        gmApi.ADG_changeFilteringState(isFilter);
    };

    var setInitFilteringState = function() {
        var input = contentDocument.getElementById('is-filter');
        input.checked = getFilteringStateFromStore();
        gmApi.ADG_isFiltered(function(isFiltered) {
            input.checked = isFiltered;
            setFilteringStateToStore(isFiltered);
            showHideBlockAdButton(isFiltered);
        });
    };

    /**
     * Storing the filtering state for quick initialization
     *
     * @param {Boolean} state  on/off filtering state
     */
    var setFilteringStateToStore = function(state) {
        try {
            localStorage.setItem(FILTERING_STATE_LS_PROPERTY, JSON.stringify({
                "state": state
            }));
        } catch (ex) {
            log.error(ex);
            return null;
        }
    };

    /**
     * Getting the filtering state for quick initialization from the localStorage,
     * while the state from the application is determined
     *
     * @returns {Boolean} on/off filtering state
     */
    var getFilteringStateFromStore = function() {
        try {
            var state = localStorage.getItem(FILTERING_STATE_LS_PROPERTY);
            if (state) {
                return JSON.parse(state).state;
            } else {
                return false;
            }
        } catch (ex) {
            log.error(ex);
            return false;
        }
        return false;
    };

    var doNotBlock = function() {
        gmApi.ADG_temporaryDontBlock(30, function() {
            CommonUtils.reloadPageBypassCache();
        });
    };

    var reportAbuse = function() {
        gmApi.ADG_sendAbuse(function() {
            iframeCtrl.removeIframe();
        });
    };

    var goToSiteReport = function() {
        var url = StringUtils.format(settings.Constants.REPORT_URL, domain);
        window.open(url, '_blank');
    };

    var setWotData = function() {
        var wotData = wot.getWotData();
        var wotReputationSettings = getWotReputationSettings(wotData);

        if (wotReputationSettings) {
            var wotIndication = $(contentDocument.getElementById('WotIndication'));
            var wotDescriptionText = contentDocument.getElementById('WotDescriptionText');
            var confidenceIndication = $(contentDocument.getElementById('ConfidenceIndication'));

            contentDocument.getElementsByClassName('wot-indicator')[0].href = wot.getWotScorecardUrl(domain);
            wotIndication.addClass(wotReputationSettings.class);
            var wotLogo = $('<a id="WotLogo" href="#"><span class="wot-logo"></span></a>')[0];
            wotDescriptionText.textContent = wotReputationSettings.text;
            wotDescriptionText.appendChild(wotLogo);

            var wotConfidenceClass = getWotConfidenceClass(wotData);
            confidenceIndication.addClass(wotConfidenceClass);

            $(contentDocument.getElementsByClassName('wot-hide')).removeClass('wot-hide');
        }
    };

    var goToWotUrl = function() {
        window.open(wot.WOT_URL, '_blank');
    };

    var getWotReputationSettings = function(wotData) {
        if (!wotData) {
            return null;
        }
        var prefix = 'adg-wot-';
        var averageWot = wotData.reputation;
        var wotRatingText = null;
        var wotRating = null;
        if (averageWot === 0) {
            wotRatingText = localization.getMessage('wot_unknown_description');
            wotRating = prefix + 'unknown';
            return {
                text: wotRatingText,
                class: wotRating
            };
        }
        var wotSettings = {
            0: {
                color: 'red',
                string: localization.getMessage('wot_bad_description')
            },
            1: {
                color: 'lightRed',
                string: localization.getMessage('wot_poor_description')
            },
            2: {
                color: 'yellow',
                string: localization.getMessage('wot_unsatisfactory_description')
            },
            3: {
                color: 'lightGreen',
                string: localization.getMessage('wot_good_description')
            },
            4: {
                color: 'green',
                string: localization.getMessage('wot_excellent_description')
            },
            5: {
                color: 'green',
                string: localization.getMessage('wot_excellent_description')
            }
        };
        var current = wotSettings[truncateDecimals(averageWot / 20)];
        wotRatingText = current.string;
        wotRating = prefix + current.color;
        return {
            text: wotRatingText,
            class: wotRating
        };
    };

    var truncateDecimals = function(number) {
        return Math[number < 0 ? 'ceil' : 'floor'](number);
    };

    var getWotConfidenceClass = function(wotData) {
        if (!wotData) {
            return null;
        }
        var prefix = 'adg-wot-confidence-';
        var confidenceWot = wotData.confidence;
        if (confidenceWot >= 0 && confidenceWot < 6) {
            return prefix + '0';
        }
        if (confidenceWot >= 6 && confidenceWot < 12) {
            return prefix + '1';
        }
        if (confidenceWot >= 12 && confidenceWot < 23) {
            return prefix + '2';
        }
        if (confidenceWot >= 23 && confidenceWot < 34) {
            return prefix + '3';
        }
        if (confidenceWot >= 34 && confidenceWot < 45) {
            return prefix + '4';
        }
        if (confidenceWot >= 45) {
            return prefix + '5';
        }
    };

    var startAdSelector = function() {
        iframeCtrl.showSelectorMenu();
    };

    var showHideBlockAdButton = function(isFilter) {
        if (isFilter) {
            $(contentDocument.getElementById('block-ad')).removeClass('hidden');
        } else {
            $(contentDocument.getElementById('block-ad')).addClass('hidden');
        }
    };

    return {
        init: init
    };
};

/**
 * Selector menu controller
 * @param $
 * @param selector
 * @returns {{init: init}}
 * @constructor
 */
/* global Ioc */
var SelectorMenuController = function ($, selector) { // jshint ignore:line
    var contentDocument = null;
    var iframeCtrl = Ioc.get('iframeController');

    /*
     Called from IframeController._showMenuItem to initialize view
     */
    var init = function (iframe) {
        contentDocument = iframe.contentDocument;
        bindEvents();
        startSelector();
    };

    var close = function () {
        iframeCtrl.removeIframe();
    };

    var bindEvents = function () {
        var menuEvents = {
            '.close': close,
            '.btn-default': close
        };
        Object.keys(menuEvents).forEach(function (item) {
            $(contentDocument.querySelectorAll(item)).on('click', menuEvents[item]);
        });
    };
    var startSelector = function () {
        selector.reset();
        selector.init(onElementSelected);
    };

    var onElementSelected = function (element) {
        iframeCtrl.showSliderMenu(element);
    };

    iframeCtrl.onCloseMenu.attach(selector.close);

    return {
        init: init
    };
};
/**
 * Slider menu controller
 * @param $
 * @param selector
 * @param sliderWidget
 * @param settings
 * @param adguardRulesConstructor
 * @param localization
 * @param gmApi
 * @returns {{init: init}}
 * @constructor
 */
/* global Ioc, CommonUtils */
var SliderMenuController = function ($, selector, sliderWidget, settings, adguardRulesConstructor, localization, gmApi) { // jshint ignore:line
    var contentDocument = null;
    var selectedElement = null;
    var iframeCtrl = Ioc.get('iframeController');

    /*
     Called from IframeController._showMenuItem to initialize view
     */
    var init = function (iframe, options) {
        selectedElement = options.element;
        contentDocument = iframe.contentDocument;
        bindEvents();
        createSlider();
        onScopeChange();
        selector.selectElement(selectedElement);
    };

    var close = function () {
        iframeCtrl.removeIframe();
    };

    var bindEvents = function () {
        var menuEvents = {
            '.close': close,
            '#ExtendedSettingsText': expandAdvanced,
            '#adv-settings': onScopeChange,
            '#adg-cancel': iframeCtrl.showSelectorMenu,
            '#adg-preview': showPreview,
            '#adg-accept': blockElement
        };
        Object.keys(menuEvents).forEach(function (item) {
            $(contentDocument.querySelectorAll(item)).on('click', menuEvents[item]);
        });
    };

    var blockElement = function () {
        gmApi.ADG_addRule(getFilterRuleInputText(), function () {
            iframeCtrl.removeIframe();
            CommonUtils.reloadPageBypassCache();
        });
    };

    var expandAdvanced = function () {
        var hidden = !$(contentDocument.getElementById('adv-settings')).hasClass("open");
        if (hidden) {
            iframeCtrl.resizeSliderMenuToAdvanced();
            $(contentDocument.getElementById('adv-settings')).addClass('open');
            $(contentDocument.getElementById('ExtendedSettingsText')).addClass('active');
        } else {
            iframeCtrl.resizeSliderMenuToNormal();
            $(contentDocument.getElementById('adv-settings')).removeClass('open');
            $(contentDocument.getElementById('ExtendedSettingsText')).removeClass('active');
        }
    };

    var showPreview = function () {
        iframeCtrl.showBlockPreview(selectedElement, getFilterRuleInputText());
    };

    var createSlider = function () {
        var parents = CommonUtils.getParentsLevel(selectedElement);
        var children = CommonUtils.getAllChildren(selectedElement);
        var value = Math.abs(parents.length + 1);
        var max = parents.length + children.length + 1;
        var min = 1;
        var options = {value: value, min: min, max: max};
        var slider = contentDocument.getElementById('slider');
        var sliderArea = contentDocument.getElementById('slider-area');
        if (min === max) {
            //hide slider text
            $(slider).hide();
            $(contentDocument.getElementsByClassName('element-rule_text')).hide();
            expandAdvanced();
        }

        options.onSliderMove = function (delta) {
            var elem;
            if (delta > 0) {
                elem = parents[delta - 1];
            }
            if (delta === 0) {
                elem = selectedElement;
            }
            if (delta < 0) {
                elem = children[Math.abs(delta + 1)];
            }
            onSliderMove(elem);
        };

        sliderWidget.init(slider, {
            min: options.min,
            max: options.max,
            value: options.value,
            onValueChanged: function (value) {
                var delta = options.value - value;
                options.onSliderMove(delta);
            },
            sliderArea: sliderArea
        });
    };

    var onSliderMove = function (element) {
        selectedElement = element;
        selector.selectElement(element);

        makeDefaultCheckboxesForDetailedMenu();
        onScopeChange();
        handleShowBlockSettings(haveUrlBlockParameter(element), haveClassAttribute(element));
    };

    var makeDefaultCheckboxesForDetailedMenu = function () {
        contentDocument.getElementById('block-by-url-checkbox').checked = false;
        contentDocument.getElementById('block-similar-checkbox').checked = false;
        contentDocument.getElementById('one-domain-checkbox').checked = false;
    };

    var onScopeChange = function () {

        var isBlockByUrl = contentDocument.getElementById('block-by-url-checkbox').checked;
        var isBlockSimilar = contentDocument.getElementById('block-similar-checkbox').checked;
        var isBlockOneDomain = contentDocument.getElementById('one-domain-checkbox').checked;

        handleShowBlockSettings(haveUrlBlockParameter(selectedElement) && !isBlockSimilar, haveClassAttribute(selectedElement) && !isBlockByUrl);

        var options = {
            urlMask: getUrlBlockAttribute(selectedElement),
            cssSelectorType: isBlockSimilar ? "SIMILAR" : "STRICT_FULL",
            isBlockOneDomain: isBlockOneDomain,
            url: document.location,
            ruleType: isBlockByUrl ? "URL" : "CSS"
        };

        var ruleText = adguardRulesConstructor.constructRuleText(selectedElement, options);
        setFilterRuleInputText(ruleText);
    };

    var haveUrlBlockParameter = function (element) {
        var value = getUrlBlockAttribute(element);
        return value && value !== '';
    };

    var getUrlBlockAttribute = function (element) {
        var urlBlockAttributes = ["src", "data"];
        for (var i = 0; i < urlBlockAttributes.length; i++) {
            var attr = urlBlockAttributes[i];
            var value = element.getAttribute(attr);
            if (value) {
                return value;
            }
        }
        return null;
    };

    var haveClassAttribute = function (element) {
        var className = element.className;
        return className && className.trim() !== '';
    };

    var handleShowBlockSettings = function (showBlockByUrl, showBlockSimilar) {
        var blockByUrlBlock = $(contentDocument.getElementById('block-by-url-checkbox-block'));
        var blockSimilarBlock = $(contentDocument.getElementById('block-similar-checkbox-block'));
        if (showBlockByUrl) {
            blockByUrlBlock.show();
        } else {
            contentDocument.getElementById('block-by-url-checkbox').checked = false;
            blockByUrlBlock.hide();
        }
        if (showBlockSimilar) {
            blockSimilarBlock.show();
        } else {
            contentDocument.getElementById('block-similar-checkbox').checked = false;
            blockSimilarBlock.hide();
        }
    };

    var setFilterRuleInputText = function (ruleText) {
        contentDocument.getElementById('filter-rule').value = ruleText;
    };

    var getFilterRuleInputText = function () {
        return contentDocument.getElementById('filter-rule').value;
    };

    return {
        init: init
    };
};

/**
 * Block preview controller
 * @param $
 * @param selector
 * @param gmApi
 * @returns {{init: init}}
 * @constructor
 */
/* global Ioc */
var BlockPreviewController = function ($, selector, gmApi) { // jshint ignore:line
    var contentDocument = null;
    var selectedElement = null;
    var selectedPath = null;
    var iframeCtrl = Ioc.get('iframeController');

    /*
     Called from IframeController.showMenuItem to initialize view
     */
    var init = function (iframe, options) {
        selectedElement = options.element;
        selectedPath = options.path;
        contentDocument = iframe.contentDocument;
        selector.reset();
        bindEvents();
        hideElement();
    };

    var close = function () {
        showElement();
        iframeCtrl.removeIframe();
    };

    var bindEvents = function () {
        var menuEvents = {
            '.close': close,
            '#select-another-element': selectAnotherElement,
            '#end-preview': showDetailedMenu,
            '#block-element': blockElement
        };
        Object.keys(menuEvents).forEach(function (item) {
            $(contentDocument.querySelectorAll(item)).on('click', menuEvents[item]);
        });
    };

    var hideElement = function () {
        if (!selectedElement) {
            return;
        }
        $(selectedElement).addClass('adguard-hide');
    };

    var showElement = function () {
        if (!selectedElement) {
            return;
        }
        $(selectedElement).removeClass('adguard-hide');
    };

    var selectAnotherElement = function () {
        showElement();
        iframeCtrl.showSelectorMenu();
    };

    var blockElement = function () {
        gmApi.ADG_addRule(selectedPath);
        iframeCtrl.removeIframe();
    };

    var showDetailedMenu = function () {
        showElement();
        iframeCtrl.showSliderMenu(selectedElement);
    };

    return {
        init: init
    };
};

/**
 * Settings menu controller
 * @param $
 * @param settings
 * @param button
 * @returns {{init: init}}
 * @constructor
 */
/* global Ioc */
var SettingsMenuController = function ($, settings, button) { // jshint ignore:line
    var contentDocument = null;
    var iframeCtrl = Ioc.get('iframeController');
    var buttonSides = {
        'position-bottom-right': {top: false, left: false},
        'position-bottom-left': {top: false, left: true},
        'position-top-right': {top: true, left: false},
        'position-top-left': {top: true, left: true}
    };

    /*
     Called from IframeController._showMenuItem to initialize view
     */
    var init = function (iframe) {
        contentDocument = iframe.contentDocument;
        bindEvents();
        setDefaultSettings();
    };

    var close = function () {
        iframeCtrl.removeIframe();
    };

    var bindEvents = function () {
        var menuEvents = {
            '.close': close,
            '#cancel': iframeCtrl.showDetailedMenu,
            '#save-settings': saveSettings
        };
        Object.keys(menuEvents).forEach(function (item) {
            $(contentDocument.querySelectorAll(item)).on('click', menuEvents[item]);
        });
    };

    var saveSettings = function () {
        var largeIcon = contentDocument.getElementById('size-big').checked;
        var sideItem = null;
        Object.keys(buttonSides).forEach(function (item) {
            if (contentDocument.getElementById(item).checked) {
                sideItem = item;
            }
        });
        var config = settings.getSettings();
        config.largeIcon = largeIcon;
        if (sideItem) {
            config.buttonPositionTop = buttonSides[sideItem].top;
            config.buttonPositionLeft = buttonSides[sideItem].left;
            settings.removeUserPositionForButton();
        }
        settings.saveSettings(config);
        close();
        button.remove();
        button.show();
    };

    var setDefaultSettings = function () {
        var currentSettings = settings.getSettings();
        if (currentSettings.largeIcon) {
            contentDocument.getElementById('size-big').checked = true;
        } else {
            contentDocument.getElementById('size-small').checked = true;
        }
        var position = settings.getUserPositionForButton();
        if (position) {
            return;
        }
        var sideFromSettings = {top: currentSettings.buttonPositionTop, left: currentSettings.buttonPositionLeft};
        Object.keys(buttonSides).forEach(function (item) {
            var sideItem = buttonSides[item];
            if ((sideItem.left === sideFromSettings.left) && (sideItem.top === sideFromSettings.top)) {
                contentDocument.getElementById(item).checked = true;
            }
        });
    };

    return {
        init: init
    };
};


/**
 * Adguard assistant button
 * @param log Logger
 * @param settings User settings
 * @param uiValidationUtils Validation utils
 * @param $ balalaika
 * @param gmApi Gm API impl
 * @param uiUtils UI Utils
 * @param iframeController Iframe controller
 * @param resources Resources that generates in compiler
 * @returns {{show: show, remove: remove}}
 * @constructor
 */
var UIButton = function(log, settings, uiValidationUtils, $, gmApi, uiUtils, iframeController, resources) { // jshint ignore:line
    var button = null;
    var isFullScreenEventsRegistered = false;

    /**
     * Shows Adguard initial button
     */
    var show = function() {
        if (!checkRequirements()) {
            log.info("Environment doesn't satisfy requirements, so don't show Adguard");
            return;
        }
        if (button) {
            return;
        }
        log.debug("Requirements checked, all ok");
        button = $(resources.getResource('button.html'));
        gmApi.GM_addStyle(resources.getResource('button.css'));
        gmApi.GM_addStyle(resources.getResource('selector.css'));
        setPositionSettingsToButton(button);
        var body = $('body')[0];
        if (!body) {
            log.error('Cant find body');
        }
        body.appendChild(button[0]);
        registerEvents(button);
    };

    /**
     * Checking browser and other requirements.
     * @private
     */
    var checkRequirements = function() {
        if (!uiValidationUtils.validateBrowser()) {
            return false;
        }

        if (!uiValidationUtils.validatePage()) {
            return false;
        }

        if (!uiValidationUtils.checkVisibleAreaSize()) {
            return false;
        }

        if (isButtonAlreadyInDOM()) {
            return false;
        }
        return true;
    };

    var isButtonAlreadyInDOM = function() {
        return $('.adguard-alert').length > 0;
    };

    var setUserPositionIfExists = function(button) {
        var position = settings.getUserPositionForButton();

        // check if the browser stores old data without a anchor to prevent an error
        if (!position || !position.storedAnchor) {
            return false;
        }

        uiUtils.setAnchorPosition.positionY(button[0], position.storedAnchor.top);
        uiUtils.setAnchorPosition.positionX(button[0], position.storedAnchor.left);

        uiUtils.moveElementTo(button[0], position.x, position.y);

        return true;
    };

    var setPositionSettingsToButton = function(button) {
        var config = settings.getSettings();
        if (!config.largeIcon) {
            $(button[0].getElementsByClassName('adguard-a-logo')[0]).addClass('adguard-a-logo__small');
        }
        if (setUserPositionIfExists(button)) {
            return;
        }

        uiUtils.setAnchorPosition.positionY(button[0], config.buttonPositionTop);
        uiUtils.setAnchorPosition.positionX(button[0], config.buttonPositionLeft);

        respectPageElements(button[0]);
    };

    var registerEvents = function(button) {
        var onDragEnd = function(data) {
            settings.setUserPositionForButton(data);
        };

        var openMenu = function() {
            iframeController.setButtonPosition(getButtonPosition());
            iframeController.showDetailedMenu();
        };

        uiUtils.makeElementDraggable(button[0], onDragEnd, openMenu);
        hideRestoreOnFullScreen();
    };

    /**
     * Get center button position
     * @returns {{left: *, top: *}}
     * @private
     */
    var getButtonPosition = function() {
        var box = button[0].getBoundingClientRect();
        return {
            top: box.top + button[0].offsetHeight / 2,
            left: box.left + button[0].offsetWidth / 2
        };
    };

    var hideRestoreOnFullScreen = function() {
        if (isFullScreenEventsRegistered) {
            return;
        }
        $(document).on('webkitfullscreenchange mozfullscreenchange fullscreenchange', function() {
            if (uiUtils.tryFullScreenPrefix(document, "FullScreen") || uiUtils.tryFullScreenPrefix(document, "IsFullScreen")) {
                hideButton();
            } else {
                showButton();
            }
        });
        isFullScreenEventsRegistered = true;
    };

    var hideButton = function() {
        if (!button) {
            return;
        }
        button.addClass('adguard-hide');
    };

    var showButton = function() {
        if (!button) {
            return;
        }
        button.removeClass('adguard-hide');
    };

    var removeButton = function() {
        if (!button) {
            return;
        }
        $('body')[0].removeChild(button[0]);
        button = null;
    };

    /**
     * Set a special classes for the pages on which
     * under the button there are important elements
     * issue: https://github.com/AdguardTeam/AdguardAssistant/issues/32
     */
    var respectPageElements = function(element) {
        var buttonInRightBottom =
            $(element).hasClass('adguard-assistant-button-bottom') &&
            $(element).hasClass('adguard-assistant-button-right');

        if (buttonInRightBottom && document.location.hostname.indexOf('vk.com') >= 0) {
            $(element).addClass('adguard-assistant-button-respect adguard-assistant-button-respect-vk');
        }
        if (buttonInRightBottom && document.location.hostname.indexOf('facebook.com') >= 0) {
            $(element).addClass('adguard-assistant-button-respect adguard-assistant-button-respect-fb');
        }
        return false;
    };

    iframeController.onCloseMenu.attach(showButton);
    iframeController.onShowMenuItem.attach(hideButton);

    return {
        show: show,
        remove: removeButton
    };
};

/* global Ioc, Log, GM, Resources, Wot, Settings, AdguardSettings, UIValidationUtils, balalaika, UIUtils, Localization, IframeController, SliderWidget, AdguardRulesConstructorLib, AdguardSelectorLib, UIButton */

/* global ADG_addRule, ADG_temporaryDontBlock, ADG_sendAbuse, ADG_isFiltered, ADG_changeFilteringState */

(function () {
    Ioc.register('log', new Log());

    var addRule = typeof (ADG_addRule) === 'undefined' ? null : ADG_addRule;
    var dontBlock = typeof (ADG_temporaryDontBlock) === 'undefined' ? null : ADG_temporaryDontBlock;
    var sendAbuse = typeof (ADG_sendAbuse) === 'undefined' ? null : ADG_sendAbuse;
    var checkRule = typeof (ADG_isFiltered) === 'undefined' ? null : ADG_isFiltered;
    var changeFilteringState = typeof (ADG_changeFilteringState) === 'undefined' ? null : ADG_changeFilteringState;
    var adguardSettings = typeof (AdguardSettings) === 'undefined' ? null : AdguardSettings;

    Ioc.register('gmApi', new GM(addRule, dontBlock, sendAbuse, checkRule, changeFilteringState));
    Ioc.register('resources', new Resources());
    var wot = new Wot();
    wot.registerWotEventHandler();
    Ioc.register('wot', wot);
    var settings = Ioc.get(Settings);
    settings.setAdguardSettings(adguardSettings);
    Ioc.register('settings', settings);
    Ioc.register('uiValidationUtils', Ioc.get(UIValidationUtils));
    Ioc.register('$', balalaika);
    Ioc.register('selector', new AdguardSelectorLib({}, balalaika));
    Ioc.register('uiUtils', Ioc.get(UIUtils));
    Ioc.register('localization', Ioc.get(Localization));
    Ioc.register('iframeController', Ioc.get(IframeController));
    Ioc.register('sliderWidget', new SliderWidget({}, balalaika));
    Ioc.register('adguardRulesConstructor', new AdguardRulesConstructorLib({}));
    settings.loadSettings();
    var button = Ioc.get(UIButton);
    Ioc.register('button', button);
    button.show();

})();

})();